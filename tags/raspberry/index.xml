<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>raspberry on SurprisedCat</title><link>https://surprisedcat.github.io/tags/raspberry/</link><description>Recent content in raspberry on SurprisedCat</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2020–2021, SurprisedCat; all rights reserved.</copyright><lastBuildDate>Wed, 23 May 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://surprisedcat.github.io/tags/raspberry/index.xml" rel="self" type="application/rss+xml"/><item><title>raspberry-kubernetes-node</title><link>https://surprisedcat.github.io/projectnotes/raspberry-kubernetes-node/</link><pubDate>Wed, 23 May 2018 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/raspberry-kubernetes-node/</guid><description>
&lt;h2 id="将树莓派变成kubernetes的一个节点---omit-in-toc---">将树莓派变成Kubernetes的一个节点&lt;!-- omit in toc -->&lt;/h2>
&lt;h2 id="前提">前提&lt;/h2>
&lt;p>我在自己的主机上搭建了一个K8S集群，一个master节点，两个node节点，手边还有三个树莓派，想把他们也并到集群中。昨天我在docker中安装了docker，而kubernetes官网上也有arm的二进制文件，今天打算将这些文件配置到raspberry上，使之成为K8S集群的新节点。&lt;/p>
&lt;p>&lt;strong>需要指出的是&lt;/strong>，我原来的集群是X86_64架构的机器，raspberry是arm架构的，他们用的是不一样的镜像，在master节点需要指定不同架构的镜像给不同的node节点。&lt;/p>
&lt;h2 id="下载kubernetes-node节点">下载kubernetes node节点&lt;/h2>
&lt;p>本人使用的是k8s 1.8版本的（master节点是这个版本）$^{[1]}$
&lt;img src="../../images/k8s-nodes.jpg" alt="K8S node 节点">&lt;/p>
&lt;p>解压后新建文件夹：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>sudo mkdir -p /opt/kubernetes/&lt;span class="o">{&lt;/span>bin,cfg&lt;span class="o">}&lt;/span>
&lt;span class="ln">2&lt;/span>sudo mv kubelet kubectl kube-proxy /opt/kubernetes/bin/
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="编写kubernetes配置文件">编写Kubernetes配置文件&lt;/h2>
&lt;h3 id="创建kubeconfig配置文件">创建kubeconfig配置文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>sudo vim /opt/kubernetes/cfg/kubelet.kubeconfig
&lt;span class="ln"> 2&lt;/span>apiVersion: v1
&lt;span class="ln"> 3&lt;/span>kind: Config
&lt;span class="ln"> 4&lt;/span>clusters:
&lt;span class="ln"> 5&lt;/span> - cluster:
&lt;span class="ln"> 6&lt;/span> server: http://&lt;span class="o">{&lt;/span>master 节点 IP&lt;span class="o">}&lt;/span>:8080
&lt;span class="ln"> 7&lt;/span> name: &lt;span class="nb">local&lt;/span>
&lt;span class="ln"> 8&lt;/span>contexts:
&lt;span class="ln"> 9&lt;/span> - context:
&lt;span class="ln">10&lt;/span> cluster: &lt;span class="nb">local&lt;/span>
&lt;span class="ln">11&lt;/span> name: &lt;span class="nb">local&lt;/span>
&lt;span class="ln">12&lt;/span>current-context: &lt;span class="nb">local&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建配置文件kubeconfig用于kubelet连接master apiserver。&lt;/p>
&lt;h3 id="创建自身配置文件">创建自身配置文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>sudo vim /opt/kubernetes/cfg/kubelet
&lt;span class="ln"> 2&lt;/span>&lt;span class="c1"># 启用日志标准错误&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="nv">KUBE_LOGTOSTDERR&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;--logtostderr=true&amp;#34;&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="c1"># 日志级别&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="nv">KUBE_LOG_LEVEL&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;--v=4&amp;#34;&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="c1"># Kubelet服务IP地址&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="nv">NODE_ADDRESS&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;--address={本机IP}&amp;#34;&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="c1"># Kubelet服务端口&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="nv">NODE_PORT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;--port=10250&amp;#34;&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="c1"># 自定义节点名称&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="nv">NODE_HOSTNAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;--hostname-override={本机IP}&amp;#34;&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="c1"># kubeconfig路径，指定连接API服务器&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="nv">KUBELET_KUBECONFIG&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;--kubeconfig=/opt/kubernetes/cfg/kubelet.kubeconfig&amp;#34;&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="c1"># 允许容器请求特权模式，默认false&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="nv">KUBE_ALLOW_PRIV&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;--allow-privileged=false&amp;#34;&lt;/span>
&lt;span class="ln">16&lt;/span>&lt;span class="c1"># DNS信息&lt;/span>
&lt;span class="ln">17&lt;/span>&lt;span class="nv">KUBELET_DNS_IP&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;--cluster-dns=172.16.76.2&amp;#34;&lt;/span>
&lt;span class="ln">18&lt;/span>&lt;span class="nv">KUBELET_DNS_DOMAIN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;--cluster-domain=cluster.local&amp;#34;&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="c1"># 禁用使用Swap&lt;/span>
&lt;span class="ln">20&lt;/span>&lt;span class="nv">KUBELET_SWAP&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;--fail-swap-on=false&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建systemd服务文件">创建systemd服务文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>sudo vim /lib/systemd/system/kubelet.service
&lt;span class="ln"> 2&lt;/span>&lt;span class="o">[&lt;/span>Unit&lt;span class="o">]&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="nv">Description&lt;/span>&lt;span class="o">=&lt;/span>Kubernetes Kubelet
&lt;span class="ln"> 4&lt;/span>&lt;span class="nv">After&lt;/span>&lt;span class="o">=&lt;/span>docker.service
&lt;span class="ln"> 5&lt;/span>&lt;span class="nv">Requires&lt;/span>&lt;span class="o">=&lt;/span>docker.service
&lt;span class="ln"> 6&lt;/span>&lt;span class="o">[&lt;/span>Service&lt;span class="o">]&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="nv">EnvironmentFile&lt;/span>&lt;span class="o">=&lt;/span>-/opt/kubernetes/cfg/kubelet
&lt;span class="ln"> 8&lt;/span>&lt;span class="nv">ExecStart&lt;/span>&lt;span class="o">=&lt;/span>/opt/kubernetes/bin/kubelet &lt;span class="se">\
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">KUBE_LOGTOSTDERR&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">KUBE_LOG_LEVEL&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">NODE_ADDRESS&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">NODE_PORT&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">NODE_HOSTNAME&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">KUBELET_KUBECONFIG&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">KUBE_ALLOW_PRIV&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">KUBELET_DNS_IP&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">KUBELET_DNS_DOMAIN&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="ln">18&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">KUBELET_SWAP&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="nv">Restart&lt;/span>&lt;span class="o">=&lt;/span>on-failure
&lt;span class="ln">20&lt;/span>&lt;span class="nv">KillMode&lt;/span>&lt;span class="o">=&lt;/span>process
&lt;span class="ln">21&lt;/span>&lt;span class="o">[&lt;/span>Install&lt;span class="o">]&lt;/span>
&lt;span class="ln">22&lt;/span>&lt;span class="nv">WantedBy&lt;/span>&lt;span class="o">=&lt;/span>multi-user.target
&lt;span class="ln">23&lt;/span>
&lt;span class="ln">24&lt;/span>&lt;span class="c1"># systemctl daemon-reload&lt;/span>
&lt;span class="ln">25&lt;/span>&lt;span class="c1"># systemctl enable kubelet&lt;/span>
&lt;span class="ln">26&lt;/span>&lt;span class="c1"># systemctl restart kubelet&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建kube-proxy配置文件">创建kube-proxy配置文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>sudo vim /opt/kubernetes/cfg/kube-proxy
&lt;span class="ln">2&lt;/span>&lt;span class="c1"># 启用日志标准错误&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nv">KUBE_LOGTOSTDERR&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;--logtostderr=true&amp;#34;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="c1"># 日志级别&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="nv">KUBE_LOG_LEVEL&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;--v=4&amp;#34;&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="c1"># 自定义节点名称&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="nv">NODE_HOSTNAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;--hostname-override={本机IP}&amp;#34;&lt;/span>
&lt;span class="ln">8&lt;/span>&lt;span class="c1"># API服务地址&lt;/span>
&lt;span class="ln">9&lt;/span>&lt;span class="nv">KUBE_MASTER&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;--master=http://{master 节点 IP}:8080&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建proxy的systemd服务文件">创建proxy的systemd服务文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>sudo vim /lib/systemd/system/kube-proxy.service
&lt;span class="ln"> 2&lt;/span>&lt;span class="o">[&lt;/span>Unit&lt;span class="o">]&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="nv">Description&lt;/span>&lt;span class="o">=&lt;/span>Kubernetes Proxy
&lt;span class="ln"> 4&lt;/span>&lt;span class="nv">After&lt;/span>&lt;span class="o">=&lt;/span>network.target
&lt;span class="ln"> 5&lt;/span>&lt;span class="o">[&lt;/span>Service&lt;span class="o">]&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="nv">EnvironmentFile&lt;/span>&lt;span class="o">=&lt;/span>-/opt/kubernetes/cfg/kube-proxy
&lt;span class="ln"> 7&lt;/span>&lt;span class="nv">ExecStart&lt;/span>&lt;span class="o">=&lt;/span>/opt/kubernetes/bin/kube-proxy &lt;span class="se">\
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">KUBE_LOGTOSTDERR&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">KUBE_LOG_LEVEL&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">NODE_HOSTNAME&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">KUBE_MASTER&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="nv">Restart&lt;/span>&lt;span class="o">=&lt;/span>on-failure
&lt;span class="ln">13&lt;/span>&lt;span class="o">[&lt;/span>Install&lt;span class="o">]&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="nv">WantedBy&lt;/span>&lt;span class="o">=&lt;/span>multi-user.target
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后将/opt/kubernetes/bin 放到PATH变量中。&lt;/p>
&lt;h2 id="遇到问题">遇到问题&lt;/h2>
&lt;blockquote>
&lt;p>Failed to start ContainerManager system validation failed - Following Cgroup subsystem not mounted: [memory]&lt;/p>
&lt;/blockquote>
&lt;p>新建文件/etc/default/grub,添加：$^{[2]}$&lt;/p>
&lt;blockquote>
&lt;p>GRUB_CMDLINE_LINUX=&amp;quot;cgroup_enable=memory swapaccount=1&amp;quot;&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>sudo update-grub
&lt;span class="ln">2&lt;/span>&lt;span class="c1"># 如果无法找到 update-grub 命令，你可以通过下面的命令安装它。&lt;/span>
&lt;span class="ln">3&lt;/span>sudo apt-get install grub2-common
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者更有效的是，在/boot/cmdline.txt之后加入
cgroup_enable=cpuset cgroup_enable=memory cgroup_memory=1&lt;br>
再reboot。就可以了。$^{[3]}$&lt;/p>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;p>[1]&lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.8.md#node-binaries">Kubernetes Github&lt;/a>&lt;/p>
&lt;p>[2]&lt;a href="https://linux.cn/article-2268-1.html">如何在linux上通过GRUB添加内核参数&lt;/a>&lt;/p>
&lt;p>[3]&lt;a href="https://www.raspberrypi.org/forums/viewtopic.php?p=1312253">树莓派论坛&lt;/a>&lt;/p></description></item><item><title>raspberry-docker-install</title><link>https://surprisedcat.github.io/projectnotes/raspberry-docker-install/</link><pubDate>Tue, 22 May 2018 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/raspberry-docker-install/</guid><description>
&lt;h2 id="树莓派安装-docker---omit-in-toc---">树莓派安装 docker&lt;!-- omit in toc -->&lt;/h2>
&lt;h2 id="系统选择">系统选择&lt;/h2>
&lt;p>我使用的是2018-04-18的RASPBIAN STRETCH LITE版本，我之前用过时间靠前的版本但是安装总是失败，还了这个版本是成功的。
官网上说:&lt;/p>
&lt;blockquote>
&lt;p>To install Docker CE, you need the 64-bit version of one of these Debian or Raspbian versions:&lt;/p>
&lt;ul>
&lt;li>Buster 10 (Docker CE 17.11 Edge only)&lt;/li>
&lt;li>Stretch 9 (stable) / Raspbian Stretch&lt;/li>
&lt;li>Jessie 8 (LTS) / Raspbian Jessie&lt;/li>
&lt;li>Wheezy 7.7 (LTS)&lt;/li>
&lt;/ul>
&lt;p>Docker CE is supported on both x86_64 (or amd64) and armhf architectures for Jessie and Stretch.&lt;/p>
&lt;/blockquote>
&lt;p>但是我看了树莓派目前的官方版本是32位的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>file /bin/dash
&lt;span class="ln">2&lt;/span>/bin/dash: ELF 32-bit LSB executable, ARM, EABI5 version &lt;span class="m">1&lt;/span> &lt;span class="o">(&lt;/span>SYSV&lt;span class="o">)&lt;/span>, dynamically linked, interpreter /lib/ld-linux-armhf.so.3, &lt;span class="k">for&lt;/span> GNU/Linux 3.2.0, BuildID&lt;span class="o">[&lt;/span>sha1&lt;span class="o">]=&lt;/span>18bddc2d67c785bbaaf97cbb2c0dd5420a1861b3, stripped
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是，&lt;strong>也安装成功了&lt;/strong>。&lt;/p>
&lt;h2 id="修改树莓派源">修改树莓派源&lt;/h2>
&lt;p>我认为这是非常重要的一步，我在用官方源的时候opencas的镜像总是无法访问，后来换成了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># /etc/apt/sources.list&lt;/span>
&lt;span class="ln">2&lt;/span>deb http://mirrors.shu.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi
&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后，奇迹的可以用了。&lt;/p>
&lt;h2 id="安装docker">安装docker&lt;/h2>
&lt;p>根据官方文档的说法：一些方式是不适用于rasbian系统的。&lt;/p>
&lt;blockquote>
&lt;p>Raspbian users cannot use this method!&lt;br>
For Raspbian, installing using the repository is not yet supported. You must instead use the &lt;strong>convenience script&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;p>官方推荐是使用一个&lt;strong>便捷脚本&lt;/strong>，我在没有改源之前使用这个脚本也没有成功，换了源就安装成功了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>pi@raspberrypi:~ $ curl -fsSL get.docker.com -o get-docker.sh
&lt;span class="ln"> 2&lt;/span>pi@raspberrypi:~ $ sudo sh get-docker.sh
&lt;span class="ln"> 3&lt;/span>&lt;span class="c1"># Executing docker install script, commit: 36b78b2&lt;/span>
&lt;span class="ln"> 4&lt;/span>+ sh -c apt-get update -qq &amp;gt;/dev/null
&lt;span class="ln"> 5&lt;/span>+ sh -c apt-get install -y -qq apt-transport-https ca-certificates curl &amp;gt;/dev/null
&lt;span class="ln"> 6&lt;/span>+ sh -c curl -fsSL &lt;span class="s2">&amp;#34;https://download.docker.com/linux/raspbian/gpg&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> apt-key add -qq - &amp;gt;/dev/null
&lt;span class="ln"> 7&lt;/span>Warning: apt-key output should not be parsed &lt;span class="o">(&lt;/span>stdout is not a terminal&lt;span class="o">)&lt;/span>
&lt;span class="ln"> 8&lt;/span>+ sh -c &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;deb [arch=armhf] https://download.docker.com/linux/raspbian stretch edge&amp;#34;&lt;/span> &amp;gt; /etc/apt/sources.list.d/docker.list
&lt;span class="ln"> 9&lt;/span>+ &lt;span class="o">[&lt;/span> &lt;span class="nv">raspbian&lt;/span> &lt;span class="o">=&lt;/span> debian &lt;span class="o">]&lt;/span>
&lt;span class="ln">10&lt;/span>+ sh -c apt-get update -qq &amp;gt;/dev/null
&lt;span class="ln">11&lt;/span>+ sh -c apt-get install -y -qq --no-install-recommends docker-ce &amp;gt;/dev/null
&lt;span class="ln">12&lt;/span>+ sh -c docker version
&lt;span class="ln">13&lt;/span>Client:
&lt;span class="ln">14&lt;/span> Version: 18.05.0-ce
&lt;span class="ln">15&lt;/span> API version: 1.37
&lt;span class="ln">16&lt;/span> Go version: go1.9.5
&lt;span class="ln">17&lt;/span> Git commit: f150324
&lt;span class="ln">18&lt;/span> Built: Wed May &lt;span class="m">9&lt;/span> 22:24:36 &lt;span class="m">2018&lt;/span>
&lt;span class="ln">19&lt;/span> OS/Arch: linux/arm
&lt;span class="ln">20&lt;/span> Experimental: &lt;span class="nb">false&lt;/span>
&lt;span class="ln">21&lt;/span> Orchestrator: swarm
&lt;span class="ln">22&lt;/span>
&lt;span class="ln">23&lt;/span>Server:
&lt;span class="ln">24&lt;/span> Engine:
&lt;span class="ln">25&lt;/span> Version: 18.05.0-ce
&lt;span class="ln">26&lt;/span> API version: 1.37 &lt;span class="o">(&lt;/span>minimum version 1.12&lt;span class="o">)&lt;/span>
&lt;span class="ln">27&lt;/span> Go version: go1.9.5
&lt;span class="ln">28&lt;/span> Git commit: f150324
&lt;span class="ln">29&lt;/span> Built: Wed May &lt;span class="m">9&lt;/span> 22:20:37 &lt;span class="m">2018&lt;/span>
&lt;span class="ln">30&lt;/span> OS/Arch: linux/arm
&lt;span class="ln">31&lt;/span> Experimental: &lt;span class="nb">false&lt;/span>
&lt;span class="ln">32&lt;/span>If you would like to use Docker as a non-root user, you should now consider
&lt;span class="ln">33&lt;/span>adding your user to the &lt;span class="s2">&amp;#34;docker&amp;#34;&lt;/span> group with something like:
&lt;span class="ln">34&lt;/span>
&lt;span class="ln">35&lt;/span> sudo usermod -aG docker your-user
&lt;span class="ln">36&lt;/span>
&lt;span class="ln">37&lt;/span>Remember that you will have to log out and back in &lt;span class="k">for&lt;/span> this to take effect!
&lt;span class="ln">38&lt;/span>
&lt;span class="ln">39&lt;/span>WARNING: Adding a user to the &lt;span class="s2">&amp;#34;docker&amp;#34;&lt;/span> group will grant the ability to run
&lt;span class="ln">40&lt;/span> containers which can be used to obtain root privileges on the
&lt;span class="ln">41&lt;/span> docker host.
&lt;span class="ln">42&lt;/span> Refer to https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface
&lt;span class="ln">43&lt;/span> &lt;span class="k">for&lt;/span> more information.
&lt;span class="ln">44&lt;/span>pi@raspberrypi:~ $ sudo usermod -aG docker &lt;span class="sb">`&lt;/span>whoami&lt;span class="sb">`&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>重启下cmd界面（否则还是需要sudo），安装成功。&lt;/p>
&lt;h2 id="测试">测试&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>pi@raspberrypi:~ $ docker run -ti armhf/alpine:3.5 /bin/sh
&lt;span class="ln"> 2&lt;/span>Unable to find image &lt;span class="s1">&amp;#39;armhf/alpine:3.5&amp;#39;&lt;/span> locally
&lt;span class="ln"> 3&lt;/span>3.5: Pulling from armhf/alpine
&lt;span class="ln"> 4&lt;/span>e68f2aaec91c: Pull &lt;span class="nb">complete&lt;/span>
&lt;span class="ln"> 5&lt;/span>Digest: sha256:5959291b202522ad454cab5ee9960d5a7bc2c59a88ddb00a5de01d36fb70ca9e
&lt;span class="ln"> 6&lt;/span>Status: Downloaded newer image &lt;span class="k">for&lt;/span> armhf/alpine:3.5
&lt;span class="ln"> 7&lt;/span>
&lt;span class="ln"> 8&lt;/span>/ &lt;span class="c1"># echo &amp;#34;Hi, this is a tiny Linux distribution!&amp;#34; | base64 &lt;/span>
&lt;span class="ln"> 9&lt;/span>SGksIHRoaXMgaXMgYSB0aW55IExpbnV4IGRpc3RyaWJ1dGlvbiEK
&lt;span class="ln">10&lt;/span>/ &lt;span class="c1"># cat /etc/issue&lt;/span>
&lt;span class="ln">11&lt;/span>Welcome to Alpine Linux 3.5
&lt;span class="ln">12&lt;/span>Kernel &lt;span class="se">\r&lt;/span> on an &lt;span class="se">\m&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="se">\l&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="ln">13&lt;/span>
&lt;span class="ln">14&lt;/span>/ &lt;span class="c1"># exit&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;p>&lt;a href="https://docs.docker.com/install/linux/docker-ce/debian/#install-using-the-repository">Docker官网&lt;/a>&lt;/p></description></item><item><title>树莓派连接Wifi配置</title><link>https://surprisedcat.github.io/projectnotes/raspberry-connect-wifi/</link><pubDate>Tue, 15 May 2018 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/raspberry-connect-wifi/</guid><description>
&lt;h2 id="树莓派连接wifi配置---omit-in-toc---">树莓派连接Wifi配置&lt;!-- omit in toc -->&lt;/h2>
&lt;h2 id="配置网口">配置网口&lt;/h2>
&lt;p>编辑 /etc/network/interfaces 文件，将wlan0配置成dhcp，指定配置文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>auto wlan0
&lt;span class="ln">2&lt;/span>iface wlan0 inet dhcp
&lt;span class="ln">3&lt;/span>wpa_conf /etc/wpa_supplicant/wpa_supplicant.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="修改wpa_supplicantconf">修改wpa_supplicant.conf&lt;/h2>
&lt;p>打开/etc/wpa_supplicant/wpa_supplicant.conf文件，加入如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="nv">network&lt;/span>&lt;span class="o">={&lt;/span>
&lt;span class="ln"> 2&lt;/span>    &lt;span class="nv">ssid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;wifi的ssid&amp;#34;&lt;/span>
&lt;span class="ln"> 3&lt;/span>    &lt;span class="nv">key_mgmt&lt;/span>&lt;span class="o">=&lt;/span>WPA-PSK
&lt;span class="ln"> 4&lt;/span>    &lt;span class="nv">psk&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;wifi的密码&amp;#34;&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="nv">priority&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">5&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="nv">network&lt;/span>&lt;span class="o">={&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="nv">ssid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;WiFi-name2&amp;#34;&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="nv">psk&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;WiFi-password2&amp;#34;&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="nv">priority&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">4&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，priority 是指连接优先级，数字越大优先级越高（不可以是负数）。&lt;/p>
&lt;h2 id="连接断开wifi">连接/断开wifi&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1">#连接wifi&lt;/span>
&lt;span class="ln">2&lt;/span>sudo ifup wlan0
&lt;span class="ln">3&lt;/span>&lt;span class="c1"># 断开wifi&lt;/span>
&lt;span class="ln">4&lt;/span>sudo ifdown wlan0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果不好使的话，重启一下就可以了。&lt;/p>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;p>&lt;a href="http://www.52pi.net/archives/58">树莓派中文站&lt;/a>&lt;/p></description></item><item><title>raspberry-question-and-answer</title><link>https://surprisedcat.github.io/projectnotes/raspberry-question-and-answer/</link><pubDate>Sun, 19 Nov 2017 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/raspberry-question-and-answer/</guid><description>
&lt;h2 id="树莓派常见问题解决有问题时常更新---omit-in-toc---">树莓派常见问题解决（有问题时常更新）&lt;!-- omit in toc -->&lt;/h2>
&lt;p>本页面记录了使用树莓派的过程中遇到的一些问题和解决方案。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>安装好系统后没有显额外示器，新版本树莓派默认关闭ssh服务器，无法连接上树莓派。&lt;/p>
&lt;blockquote>
&lt;p>在SD卡的/boot中，添加一个名为“ssh”的空文件，注意不用使用windows自带的文本编辑器动它！&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>树莓派连接上显示器之后没有反应。&lt;/p>
&lt;blockquote>
&lt;p>修改sd卡/boot分区中的config.txt文件。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nv">hdmi_force_hotplug&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nv">config_hdmi_boost&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">4&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nv">hdmi_group&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">2&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nv">hdmi_mode&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">9&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="nv">hdmi_drive&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">2&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="nv">hdmi_ignore_edid&lt;/span>&lt;span class="o">=&lt;/span>0xa5000080
&lt;span class="ln">7&lt;/span>&lt;span class="nv">disable_overscan&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>解释：&lt;br>
hdmi_force_hotplug：强制使用HDMI输出（强行认为HDMI口已经插入了设备）&lt;br>
config_hdmi_boost：HDMI信号增强。&lt;br>
hdmi_group、hdmi_mode：决定分辨率。group=2, mode=9 代表800×600 @ 60Hz。（参考：&lt;a href="http://elinux.org/RPiconfig">http://elinux.org/RPiconfig&lt;/a>）&lt;br>
hdmi_drive：强制音频输出到HDMI口（注意，仅适用于带音频的HDMI-VGA转换器！！如果想让音频从模拟输出，则去掉此项！！）&lt;br>
hdmi_ignore_edid：强行按hdmi_group和hdmi_mode规定的分辨率输出。不检测显示器自身的分辨率。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>图形性能如何？&lt;/p>
&lt;blockquote>
&lt;p>GPU支持OpenGL ES 2.0、硬件加速的OpenVG，和高至1080p30fps的H.264硬件解码。
GPU的通常计算能力达到1Gpixel/s, 1.5Gtexel/s 或 24 GFLOPs，并且提供一系列材质渲染过滤与DMA功能。
相比较来看，树莓派的图形性能基本上与初代Xbox等同。树莓派的总体性能也许和300MHz的奔腾2接近，不过图形能力是远远超越那个时代的。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>键盘字符打不出来问题。&lt;/p>
&lt;blockquote>
&lt;p>树莓派默认是英国键盘，字符与美式键盘有些地方不一样，所以需要一些设置。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>sudo raspi-config
&lt;span class="ln">2&lt;/span>choose 4. Localisation Options &amp;gt;&amp;gt; I3 Change keyboard Layout &amp;gt;&amp;gt; Gernic 101-Key PC &amp;gt;&amp;gt; Other &amp;gt;&amp;gt; English &lt;span class="o">(&lt;/span>US&lt;span class="o">)&lt;/span>
&lt;span class="ln">3&lt;/span>然后一路选择默认的配置就可以了
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol></description></item><item><title>raspberry-network-ssh</title><link>https://surprisedcat.github.io/projectnotes/raspberry-network-ssh/</link><pubDate>Tue, 31 Oct 2017 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/raspberry-network-ssh/</guid><description>
&lt;h2 id="树莓派首次开机一根网线的控制ssh与配置文件---omit-in-toc---">树莓派首次开机一根网线的控制（ssh与配置文件）&lt;!-- omit in toc -->&lt;/h2>
&lt;p>最近的设备比较多，搞了一个KVM切换器，让多个主机共享一套显示器和键鼠。但是明显树莓派这个东东不太需要单独给他再加个外设，树莓派上的程序基本不会用的GUI，都是shell能搞定的东西，所以ssh就能搞定树莓派上所有的问题。&lt;/p>
&lt;h2 id="开启ssh">开启ssh&lt;/h2>
&lt;p>Raspberry Pi 3自带openssh服务器，可以直接通过ssh连接操作树莓派，但是第一次开机的时候，ssh并未自动开启（之前的版本可以，3代不可以）。官网的解决方案很简单，在树莓派存储介质（SD卡或者U盘）上加一个名为&lt;code>ssh&lt;/code>的空文件，就开启了ssh服务。&lt;/p>
&lt;blockquote>
&lt;p>注意：千万不要用windows的记事本新建这个文件！&lt;/p>
&lt;/blockquote>
&lt;h2 id="获取raspberry的ip">获取Raspberry的IP&lt;/h2>
&lt;p>当ssh服务开启之后，我们还需要树莓派的IP才能登陆树莓派。&lt;/p>
&lt;p>如果你的树莓派插在一个路由器或者交换机上，网络中自然会有DHCP服务器在树莓派分配IP，这是可以借助nmap、ipscan22.exe等扫描工具搜寻Raspberry的地址。树莓派的MAC地址为b8-27-eb-XX-XX-XX，有些能显示网络名称的工具直接会显示Raspberry Pi。&lt;/p>
&lt;p>如果可以登陆路由器，那么树莓派的信息就会显示在路由器管理界面的设备管理页面。&lt;/p>
&lt;p>如果树莓派直接连接电脑上，可以通过在电脑上安装一个DHCP服务器来给树莓派分配IP，例如isc-dhcp-server。&lt;/p>
&lt;p>如果这些都觉得太复杂，可以采取修改cmdline.txt的方法。打开U盘中的cmdline.txt文件，在结尾加入语句ip=&lt;em>&lt;strong>.&lt;/strong>&lt;/em>.&lt;em>&lt;strong>.&lt;/strong>&lt;/em>（IP地址）。然后在把自己的网段配成和cmdline.txt里一样的网段，就可以连接树莓派了。树莓派的默认账户密码：pi -- raspberry&lt;/p>
&lt;h2 id="configtxt">config.txt&lt;/h2>
&lt;p>由于树莓派并没有传统意义上的BIOS, 所以现在各种系统配置参数通常被存在&amp;quot;config.txt&amp;quot;这个文本文件中。树莓派的config.txt文件会在ARM内核初始化之前被&lt;strong>GPU&lt;/strong>读取。这个文件存在引导分区上的。对于Linux, 路径通常是/boot/config.txt, 如果是Windows (或者OS X) 它会被识别为SD卡中可访问部分的一个普通文件。&lt;/p>
&lt;p>你可以使用下列命令去获取当前激活的设置:&lt;/p>
&lt;ul>
&lt;li>列出指定的配置参数.&lt;/li>
&lt;li>例如: vcgencmd get_config arm_freq
&lt;ul>
&lt;li>vcgencmd get_config&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出所有已设置的整形配置参数(非零)
&lt;ul>
&lt;li>vcgencmd get_config int&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列出所有已设置的字符型配置参数(非零)
&lt;ul>
&lt;li>vcgencmd get_config str&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>文件格式:&lt;/p>
&lt;p>当值是整形时格式为”属性=值”。 每行只指定一个参数。 注释使用’#’井号作为一行开头。
注意: 在新版的树莓派里每行都有#注释, 要想使用该行参数只需移除#。&lt;/p>
&lt;p>具体的文件配置强烈推荐一下两篇文章：&lt;/p>
&lt;p>&lt;a href="https://elinux.org/RPiconfig">https://elinux.org/RPiconfig&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://elinux.org/R-Pi_configuration_file">https://elinux.org/R-Pi_configuration_file&lt;/a>&lt;/p>
&lt;h2 id="更新piroot的密码">更新pi、root的密码&lt;/h2>
&lt;h2 id="更新软件源">更新软件源&lt;/h2>
&lt;h2 id="参看文献">参看文献&lt;/h2></description></item><item><title>raspberry-os-install</title><link>https://surprisedcat.github.io/projectnotes/raspberry-os-install/</link><pubDate>Fri, 20 Oct 2017 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/raspberry-os-install/</guid><description>
&lt;h2 id="树莓派系统安装与u盘启动---omit-in-toc---">树莓派系统安装与U盘启动&lt;!-- omit in toc -->&lt;/h2>
&lt;h2 id="系统推荐">系统推荐&lt;/h2>
&lt;p>Raspbian是默认的最常用于Raspberry Pi的免费操作系统。Raspbian是基于Debian的一个版本（针对Raspberry Pi硬件Debian进行了专门的优化，并构建了超过35000个Raspbian包）。Debian的软件策略偏保守，稳定第一，升级是次要的。&lt;/p>
&lt;p>Raspbian也是树莓派官方支持的操作系统。这个系统镜像可以分为带GUI和不带GUI两种：&lt;/p>
&lt;blockquote>
&lt;p>Raspbain Stretch With PIXEL 树莓派官方系统，带PIXEL图形界面。特点是兼容性和性能优秀。&lt;/p>
&lt;p>Raspbain Stretch Lite 树莓派官方系统，不带图形界面。特点是兼容性和性能优秀，比PIXEL版本的安装包更小。&lt;/p>
&lt;/blockquote>
&lt;p>Raspbian仍处于积极开发状态，并把重点放在提升尽可能多Debian包的稳定性和性能。对于初学编程的人来说这是一个很好的起点，Raspbian自带的x windows，因此可以使用它类似WIN风格的GUI界面，Raspbian还包括一个“Pi商店”，你可以免费或付费下载一些应用，比如Libre Office、Free Civ（游戏）等等。&lt;/p>
&lt;p>树莓派在一般情况下可以采用Raspian系统。其他可用操作系统可以参考一下网址：
&lt;a href="http://wiki.nxez.com/rpi:list-of-oses">http://wiki.nxez.com/rpi:list-of-oses&lt;/a>&lt;/p>
&lt;h2 id="必备软件">必备软件&lt;/h2>
&lt;ul>
&lt;li>镜像烧录工具（有一个即可）
&lt;ul>
&lt;li>Win32DiskImager(仅windows)&lt;/li>
&lt;li>Etcher（跨平台）&lt;/li>
&lt;li>USB Image Tool&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="系统安装">系统安装&lt;/h2>
&lt;p>我们首先需要准备一张SD卡，由于我之后打算使用U盘启动，所以SD卡不用准备的太大，能写入镜像就可以了。本文章使用的镜像是2017-09-07-raspbian-stretch-lite.img，一共不到2G，所以我只选用了一个4G的SD卡。如果使用的桌面版的Raspian，最好选用8GB和更大的SD卡。&lt;/p>
&lt;p>然后，我们使用Etcher将镜像文件写入。这个过程很简单，可以参考：官方指南：&lt;a href="https://www.raspberrypi.org/documentation/installation/installing-images/README.md">https://www.raspberrypi.org/documentation/installation/installing-images/README.md&lt;/a>&lt;/p>
&lt;h2 id="使用u盘启动beta">使用U盘启动（BETA）&lt;/h2>
&lt;p>目前我们手中的U盘应该比SD更多，所以我非常希望使用U盘取代SD卡来启动，Raspian的国外大神真有做到这点的。&lt;/p>
&lt;p>国外的大神发现，博通芯片2835/6/7内部其实有一个小的boot ROM。这个小boot ROM从SD卡中读取一个叫bootcode.bin的文件，然后在执行它，接下来就可以从SD卡中载入剩余的系统，比如固件和ARM内核。但是，其实BCM芯片是可以支持从U盘启动的，只不过默认不开启。所以我们需要先做一个系统进入树莓派，通过OTP开启USB boot功能。&lt;/p>
&lt;p>当我们从SD卡启动树莓派后，首先执行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>me~$ sudo apt-get update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> sudo apt-get upgrade
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果安装的镜像是2017-04-10以后的Raspbian 则不用&lt;code>sudo apt-get upgrade&lt;/code>。&lt;/p>
&lt;p>找到&lt;code>/boot&lt;/code>文件夹，执行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>me~$ &lt;span class="nb">echo&lt;/span> &lt;span class="nv">program_usb_boot_mode&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="p">|&lt;/span> sudo tee -a /boot/config.txt
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样将usb boot模式开启。接着&lt;code>sudo reboot&lt;/code>重启树莓派，开机后执行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>me~$ vcgencmd otp_dump &lt;span class="p">|&lt;/span> grep 17:
&lt;span class="ln">2&lt;/span>17:3020000a
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你输出的是&lt;code>0x3020000a&lt;/code>那说明可以使用USB启动了。&lt;strong>注意config.txt文件结尾不要空格。&lt;/strong>
接下来，要将2017-04-10日期之后 Raspbian镜像烧录到U盘中，和烧录的SD卡中的步骤一样。再把U盘插入树莓派，拔掉SD卡就可以执行中U盘启动了。自己&lt;strong>感觉&lt;/strong>（未测试）从U盘启动的树莓派要比从SD卡慢一些。&lt;/p>
&lt;p>几点注意：&lt;/p>
&lt;ul>
&lt;li>仅树莓派3支持使用U盘启动&lt;/li>
&lt;li>文件系统格式最好为FAT32&lt;/li>
&lt;li>并不是所有的U盘都作为启动盘，明确可用的U盘有：
&lt;ul>
&lt;li>Sandisk Force 8GB（本人使用，亲测可用）&lt;/li>
&lt;li>Sandisk Cruzer Fit 16GB&lt;/li>
&lt;li>Sandisk Cruzer Blade 16Gb&lt;/li>
&lt;li>Samsung 32GB USB 3.0 drive&lt;/li>
&lt;li>MeCo 16GB USB 3.0&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="u盘复原">U盘复原&lt;/h2>
&lt;p>被当成树莓派系统盘的U盘通常会被划分成&lt;code>/boot&lt;/code>和实际存储区，我们在电脑上插入U盘的时候，这回显示&lt;code>/boot&lt;/code>分区，不能显示完整的U盘空间。如果不在需要这个系统U盘，就需要还原U盘大小。&lt;/p>
&lt;ol>
&lt;li>打开cmd 输入diskpart&lt;/li>
&lt;li>非常重要：右键我的电脑--&amp;gt;管理--&amp;gt;磁盘管理。查看磁盘信息，一般情况下U盘会显示成磁盘1。&lt;/li>
&lt;li>在diskpart的cmd中输入 select disk 1 (非常重要，这个磁盘一定要是U盘的磁盘)。&lt;/li>
&lt;li>输入clean删除其他分区。（如果之前磁盘选错，会删除电脑中其他分区！！！）&lt;/li>
&lt;li>创建新的分区: create partition primary。&lt;/li>
&lt;li>激活分区: active。&lt;/li>
&lt;li>U盘已经恢复原来大小，选择合适的格式将他格式化，就可以重新当U盘使用了。&lt;/li>
&lt;li>找到我的电脑中的U盘盘符，格式化即可。&lt;/li>
&lt;/ol>
&lt;h2 id="疑问">疑问&lt;/h2>
&lt;p>如果我直接把镜像写到U盘里，然后修改config.txt是否就不需要用SD卡现状个系统了？？&lt;/p>
&lt;blockquote>
&lt;p>显然不可能。树莓派默认直接中SD卡启动，如果上来就插U盘的系统，树莓派的usb boot根本没Enable。&lt;/p>
&lt;/blockquote></description></item><item><title>raspberry-general</title><link>https://surprisedcat.github.io/projectnotes/raspberry-general/</link><pubDate>Tue, 03 Oct 2017 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/raspberry-general/</guid><description>
&lt;h2 id="新玩具--树莓派3b---omit-in-toc---">新玩具--树莓派3B+&lt;!-- omit in toc -->&lt;/h2>
&lt;h2 id="树莓派raspberry-pi">树莓派Raspberry Pi&lt;/h2>
&lt;p>Raspberry Pi(中文名为“树莓派”,简写为 RPi，或者 RasPi/RPi)是为学生计算机编程教育而设计，只有信用卡大小的卡片式电脑，其系统基于 Linux。&lt;/p>
&lt;p>树莓派由注册于英国的慈善组织“Raspberry Pi 基金会”开发，Eben·Upton /埃·厄普顿为项目带头人。2012 年 3 月，英国剑桥大学埃本·阿普顿（Eben Epton）正式发售世界上最小的台式机，又称卡片式电脑，外形只有信用卡大小，却具有电脑的所有基本功能，这就是Raspberry Pi 电脑板，中文译名&amp;quot;树莓派&amp;quot;！这一基金会以提升学校计算机科学及相关学科的教育，让计算机变得有趣为宗旨。基金会期望这 一款电脑无论是在发展中国家还是在发达国家，会有更多的其它应用不断被开发出来，并应用到更多领域。$^{[1]}$&lt;/p>
&lt;h3 id="raspberry-pi-3-model-b">Raspberry Pi 3 Model B&lt;/h3>
&lt;p>树莓派3B于2016年2月29日发布，从外观上来看，Raspberry Pi 3B和2B没有太大的区别，同样是85.6 x 56.5 mm x 17mm（重量45g略有增加）。然而在内在配置上提升很可观的，具体配置包括：$^{[2]}$&lt;/p>
&lt;ul>
&lt;li>Broadcom BCM2837 SoC, with quad-core ARM Cortex-A53 1200 MHz processor&lt;/li>
&lt;li>博通 BCM2847 芯片，集成了ARM Cortex-A53四核处理器，1200MHz主频。&lt;/li>
&lt;li>VideoCore IV dual-core 400 MHz GPU&lt;/li>
&lt;li>VideoCore IV双核400MHz GPU&lt;/li>
&lt;li>1 GB SDRAM - shared by the GPU and CPU&lt;/li>
&lt;li>1GB SDRAM -由GPU和CPU共享&lt;/li>
&lt;li>MicroSD card slot for boot and storage&lt;/li>
&lt;li>启动和存储的MicroSD card卡槽&lt;/li>
&lt;li>4 x USB 2.0 ports (via on-board 5 port hub)&lt;/li>
&lt;li>4个USB2.0端口&lt;/li>
&lt;li>RJ45 10/100 MBit/s Ethernet port&lt;/li>
&lt;li>RJ45 10/100 MBit/s 以太网口&lt;/li>
&lt;li>HDMI and Composite video, audio through TRRS jack&lt;/li>
&lt;li>HDMI和音频TRRS复合段端子&lt;/li>
&lt;li>40 pin GPIO Interface connector&lt;/li>
&lt;li>40引脚的GPIO连接柱&lt;/li>
&lt;li>CSI (camera) and DSI (display) connectors&lt;/li>
&lt;li>CSI 和 DSI 接口&lt;/li>
&lt;li>4 squarely positioned mounting holes&lt;/li>
&lt;li>4个角的固定孔&lt;/li>
&lt;/ul>
&lt;p>此外，Raspberry Pi 3B还集成了802.11n和Bluetooth4.1无线功能，这算是功能上最新颖的扩展了。&lt;/p>
&lt;h2 id="型号与版本对照">型号与版本对照&lt;/h2>
&lt;p>&lt;img src="../../images/raspberrypi-version-compare.png" alt="树莓派型号对比图">$^{[3]}$&lt;/p>
&lt;h2 id="raspberry-pi-3b-电气参数">Raspberry Pi 3B 电气参数&lt;/h2>
&lt;h3 id="电源供电能力">电源供电能力&lt;/h3>
&lt;p>The board takes fixed 5V input, (with the 1.2 V core voltage generated directly from the input using the internal switch-mode supply on the BCM2835 die). This permits adoption of the micro USB form factor, which, in turn, prevents the user from inadvertently plugging in out-of-range power inputs; that would be dangerous, since the 5 V would go straight to HDMI and output USB ports, even though the problem should be mitigated by some protections applied to the input power: The board provides a polarity protection diode, a voltage clamp, and a self-resetting semiconductor fuse.&lt;/p>
&lt;p>Premier Farnell recommend the following power supplies:&lt;/p>
&lt;p>Model A: 5 V DC, 500-700 mA
Model B: 5 V DC, 700-1500 mA&lt;/p>
&lt;p>Power consumption of the Raspberry Pi device is&lt;/p>
&lt;p>Board A: 5 V, 500 mA (2.5 W) without any devices connected (e.g. USB, Ethernet, HDMI)
Board B: 5 V, 700 mA (3.5 W) without any devices connected (e.g. USB, Ethernet, HDMI) (Is this correct? The 700 mA is only required if &amp;quot;using networking and high-current USB peripherals&amp;quot;.)
You will need to provide a power supply that can provide enough current to power the device plus any connected peripherals, and taking into account inefficiencies of the supply itself and the cable between the power supply and Raspberry Pi. The community advises opting for a power supply that can supply &lt;strong>at least 1 A&lt;/strong> if using USB peripherals or Pi plates that draw more than a few tens of milliamperes of current.&lt;/p>
&lt;p>As the 5 V rail is brought out in the GPIO pins, you can power the Raspberry Pi from there too. You should mind however, that those are behind the power protection circuitry, so you should provide your own.&lt;/p>
&lt;p>It is possible to power the Raspberry Pi from a powered USB hub the Raspberry Pi controls, but only on 'dumb' devices, that allow the port to supply the full current without waiting for the USB device to ask for it. As the power input of the Raspberry Pi doesn't have its data leads connected, there is no chance for a communication loop of some sorts.&lt;/p>
&lt;p>POE (power over Ethernet) is currently &lt;strong>not available&lt;/strong> for the Raspberry Pi (but nobody stops you from taking your soldering iron and doing it yourself - mind though that the Ethernet jack on the board is a 'magjack' - &lt;a href="http://www.sparkfun.com/datasheets/Prototyping/MagJack.pdf">http://www.sparkfun.com/datasheets/Prototyping/MagJack.pdf&lt;/a> - which means that the usual 'dumb or passive PoE' power pins 47 and 78 are &lt;strong>not&lt;/strong> wired through to the board. So this is not an entirely trivial exercise).&lt;/p>
&lt;p>Back-Powering; (powering the Raspberry Pi from a USB hub through the uplink/data port, single cable) Back powering is possible on the Raspberry Pi, but not advisable. Revision 1.0 boards have to be modified to back power, this is due to the 140 mA &amp;quot;polyfuses&amp;quot; that are installed in the USB port circuit. Revision 1.1 boards do not need modifications to back-power, they have replaced the polyfuses with 0 ohm resistors in their place. Revision 2.0 boards do not need modification, they have neither resistors nor polyfuses. It is advised that short (12&amp;quot; (.3 meter) or less) USB cables be used for back-powering a Raspberry Pi. Cable resistance plus connector resistance can quickly reduce operating voltages below the proper range (5.25 V to 4.75 V). But do note that if you do not power the Raspberry Pi in the &amp;quot;official manner&amp;quot;, that is through its micro-USB port, but use any alternative way (such as through the GPIO header, the test points TP1 and TP2), but also by back-powering it, you are actually bypassing the Raspberry Pi's input polyfuse protection device! This can have extreme consequences if ever you manage to put more than 6 V on the Raspberry Pi, even for a very short period. As this causes the overvoltage device D17 on the Raspberry Pi to trigger and short the 5 V supply! Without the polyfuse limiting the current through D17, it will burn out, probably melting the Raspberry Pi's enclosure with it, (if you have any) and possibly causing a fire-hazard. It will probably also create a permanent short of the 5 V supply! So be warned, and if you use back power make sure your hub or its PSU has a fuse to prevent this from happening. If not, add your own fuse.&lt;/p>
&lt;h3 id="power-supply-problems">Power supply problems&lt;/h3>
&lt;p>There have been a number of problems reported that seem to be caused by inadequate power, this is an attempt to explain what is needed and the consequences of not having enough power.&lt;/p>
&lt;p>The power required by the Pi will vary depending on how busy it is and what peripherals are connected.&lt;/p>
&lt;ul>
&lt;li>Running a GUI will take more power.&lt;/li>
&lt;li>The USB devices and Ethernet connection will take power.&lt;/li>
&lt;li>Running the GPU will take extra power.&lt;/li>
&lt;/ul>
&lt;p>This means that it's difficult to say exactly how much power is needed. People have reported current requirements of between 300 mA and 550 mA. But it could in reality take more, especially for short periods. A simple multimeter will not show short surges on the power requirement. A surge in the power requirement for a few milliseconds will not be detectable by a meter but will be enough to cause problems. If the board does not get enough power the voltage will drop. If it drops enough parts of the system will run unreliably because data can get corrupted. The &lt;strong>USB IC&lt;/strong> runs on 5 V and handles the USB and Ethernet ports so it's likely that this will be the first thing to fail. Problems seen are unreliable Ethernet connection and unreliable operation of the Keyboard and/or mouse.&lt;/p>
&lt;p>Each of the two USB ports on the Pi has a polyfuse rated at 140 mA, so any connected USB devices should draw less than this amount of current. In addition the polyfuse will cause a significant voltage drop, so that USB devices get less voltage than is available on the Raspberry Pi itself, sometimes up to half a volt less (maybe more if the fuse has recently been hot). For regular &amp;quot;low power&amp;quot; USB devices this doesn't cause a problem as they are designed to work with voltages as low as 4.4 volt. This isn't the case however with some USB devices such as Wi-Fi dongles which may need 4.75 volt, and are also known to draw more than 150 mA when configured and active. Because of the problems these polyfuses caused Raspberry Pi's produced after August 25, 2012 have the USB polyfuses F1 &amp;amp; F2 removed (replaced with shorts).&lt;/p>
&lt;p>The microUSB input port also has a 1.1 A polyfuse (700 mA &amp;quot;hold current&amp;quot;) which may also have enough resistance (although much smaller than the 140 mA fuses) to cause a significant voltage drop on the board, even below its 1.1 A total current.&lt;/p>
&lt;p>A extended explanation of the consequences of the use of these polyfuses can be found here Polyfuses explained&lt;/p>
&lt;p>There are several reasons why the power to the board may be inadequate:&lt;/p>
&lt;p>The PSU may not deliver enough power. Although the maximum power requirement is said to be 700 mA, that is with no peripherals connected (USB, Ethernet etc), so a 1000 mA PSU should be regarded as a minimum. This allows some leeway in case the power supply cannot deliver its full power without the voltage dropping.&lt;/p>
&lt;p>The PSU is not regulated.&lt;/p>
&lt;p>The cable connecting the PSU to the Pi may not be good. People have reported cables with 4 ohms resistance on the power connections. At 500 mA drain this would reduce a 5 V supply to 3 V.&lt;/p>
&lt;p>If the PSU is unregulated it can also output too high a voltage, which may trigger the overvoltage device in the Raspberry Pi, which will temporarily short the 5 V to ground, this will then &amp;quot;blow&amp;quot; polyfuse F3, which will take several days to recover from. Meanwhile (possibly with another PSU) the Raspberry Pi might not get enough power because the (partly) blown polyfuse is consuming some of the power. The solution is when this happens to ways a few days to give the polyfuse time to recover before attempting to use the better PSU. If you suspect a blow polyfuse, measure the voltage across F3, which should be less than 0.05 volt.
How can I tell if the power supply is inadequate?&lt;/p>
&lt;h3 id="common-symptoms-of-an-inadequate-power-supply">Common symptoms of an inadequate power supply&lt;/h3>
&lt;ul>
&lt;li>Unreliable Ethernet or keyboard operation, especially if it's OK at first but not when the GUI is started.&lt;/li>
&lt;li>SD card errors at start up seems to be another symptom of poor power.&lt;/li>
&lt;/ul>
&lt;p>If you think you have a problem with your power supply, it is a good idea to check the actual voltage on the Raspberry Pi circuit board. Two test points labelled TP1 and TP2 are provided on the circuit board to facilitate voltage measurements.&lt;/p>
&lt;p>Use a multimeter which is set to the range 20 volts DC (or 20 V =). You should see a voltage between 4.75 and 5.25 volts. Anything outside this range indicates that you have a problem with your power supply or your power cable, or the input polyfuse F3. Anything inside, but close to the limits, of this range may indicate a problem.&lt;/p>
&lt;h3 id="gpio口电气信息">GPIO口电气信息&lt;/h3>
&lt;p>In addition to the familiar USB, Ethernet and HDMI ports, the Raspberry Pi offers the ability to connect directly to a variety of electronic devices. These include:&lt;/p>
&lt;blockquote>
&lt;p>Digital outputs: turn lights, motors, or other devices on or off
Digital inputs: read an on or off state from a button, switch, or other sensor
Communication with chips or modules using low-level protocols: SPI, I²C, or serial UART
Connections are made using GPIO (&amp;quot;General Purpose Input/Output&amp;quot;) pins. Unlike USB, etc., these interfaces are &lt;strong>not &amp;quot;plug and play&amp;quot;&lt;/strong> and require care to avoid miswiring. The Raspberry PI GPIOs use &lt;strong>3.3V&lt;/strong> logic levels, and can be damaged if connected directly to 5V levels (as found in many older digital systems) without level-conversion circuitry.&lt;/p>
&lt;/blockquote>
&lt;p>Note that &lt;strong>no analogue input or output is available&lt;/strong>. However, add-on boards such as the Rpi Gertboard provide this capability.$^{[4]}$&lt;/p>
&lt;h2 id="40pin引脚对照表">40pin引脚对照表&lt;/h2>
&lt;p>&lt;img src="../../images/300px-B_plus_hdr_sm.jpg" alt="B+图">$^{[5]}$
&lt;img src="../../images/300px-Pi-GPIO-header.png" alt="40pin引脚">$^{[5]}$&lt;/p>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;p>[1]&lt;a href="http://wiki.jikexueyuan.com/project/raspberry-pi/overview.html">http://wiki.jikexueyuan.com/project/raspberry-pi/overview.html&lt;/a>&lt;/p>
&lt;p>[2]&lt;a href="https://elinux.org/RPi_Hardware">https://elinux.org/RPi_Hardware&lt;/a>&lt;/p>
&lt;p>[3]&lt;a href="http://shumeipai.nxez.com/raspberry-pi-version-compare">http://shumeipai.nxez.com/raspberry-pi-version-compare&lt;/a>&lt;/p>
&lt;p>[4]&lt;a href="https://elinux.org/RPi_Hardware">https://elinux.org/RPi_Hardware&lt;/a>&lt;/p>
&lt;p>[5]&lt;a href="https://elinux.org/RPi_Low-level_peripherals">https://elinux.org/RPi_Low-level_peripherals&lt;/a>&lt;/p></description></item></channel></rss>