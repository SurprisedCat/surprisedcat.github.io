<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>shell on SurprisedCat</title><link>https://surprisedcat.github.io/categories/shell/</link><description>Recent content in shell on SurprisedCat</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2020–2021, SurprisedCat; all rights reserved.</copyright><lastBuildDate>Wed, 05 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://surprisedcat.github.io/categories/shell/index.xml" rel="self" type="application/rss+xml"/><item><title>shell-骨干流程4——命令执行与job控制</title><link>https://surprisedcat.github.io/projectnotes/shell-%E9%AA%A8%E5%B9%B2%E6%B5%81%E7%A8%8B4%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B8%8Ejob%E6%8E%A7%E5%88%B6/</link><pubDate>Wed, 05 Jan 2022 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/shell-%E9%AA%A8%E5%B9%B2%E6%B5%81%E7%A8%8B4%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B8%8Ejob%E6%8E%A7%E5%88%B6/</guid><description>
&lt;ul>
&lt;li>&lt;a href="#%E5%91%BD%E4%BB%A4%E6%9F%A5%E6%89%BE">命令查找&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C">命令执行&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%94%A8%E6%88%B7%E6%89%8B%E5%8A%A8%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1">用户手动管理任务&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E4%B8%8Etrap">信号机制与trap&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6">作业控制&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#linux%E4%BF%A1%E5%8F%B7%E8%A1%A8">Linux信号表&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>总体流程图镇楼：&lt;/p>
&lt;p>&lt;img src="../../images/shell%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.drawio.svg" alt="shell执行流程">&lt;/p>
&lt;h2 id="命令执行与job控制---omit-in-toc---">命令执行与job控制&lt;!-- omit in toc -->&lt;/h2>
&lt;p>经过前面12个步骤的处理，shell命令中引号引用、保留字、别名、展开、替换、重定向等内容都已经设置完成，到了真正来执行命令的阶段。前面所有的步骤都是为了能够顺利执行命令而存在的，可以说命令执行是shell流程的&lt;strong>核心&lt;/strong>。命令执行的流程只有两步（如图中蓝色部分所示），包括寻找可执行命令的第13步和执行该命令的第14步。&lt;/p>
&lt;p>第13步中，&lt;strong>我们要明确哪些地方能够查找到所需要的可执行命令，以及查找这些地方的顺序&lt;/strong>。在非复合命令中，&lt;strong>首个单词&lt;/strong>（word）通常指的是需要执行的命令，后面的部分都是该命令的参数。如果找到了可执行命令，那么最终在第14步执行命令（首个单词）+参数（后面所有的单词），并返回结果，命令执行的过程中，还会涉及到执行环境的问题，不同的执行环境会对执行的过程结果有不同影响。如果存在未执行命令则读取下一条命令从第一步再开始处理，若遇到文件结束符（EOF）则完成shell流程。&lt;/p>
&lt;p>到这里，shell的骨干流程算是结束了。&lt;/p>
&lt;p>然而，对于一个多任务操作系统，bash shell可能启动了多个任务同时运行，因此还需要进行作业的管理和监控。除了Linux内核自动运行的任务/作业管理机制，bash shell也提供了手动调整任务/作业执行流程、方式的机制，主要包括两个机制：作业控制机制和信号机制。&lt;strong>作业控制&lt;/strong>（job control）是针对即将执行和正在执行命令的一套控制机制，也是shell流程中不可缺少的一部分。此外，还可以通过&lt;strong>信号&lt;/strong>的捕获与处理，来与正在运行的任务/作业进行通信，从而实现特定的控制功能。这一部分内容严格来说并不是shell命令处理的骨干流程，但是能够让我们更深刻地理解bash shell的运行方式。&lt;/p>
&lt;h2 id="命令查找">命令查找&lt;/h2>
&lt;p>根据shell分词的结果，shell会产生**一个简单的命令（首个单词）和一个可选的参数列表。首个单词将会被认为是shell需要执行的命令名称。**这里需要在强调下，shell中的单词和一般语言中的单词是不一样的：单词，word，可以被shell认为是一个单元的一串字符，单词不能包括不带引号的元字符。也就是说，一个字符串只要不能被元字符分割，那就是shell中所谓的单词。&lt;/p>
&lt;p>根据《shell骨干流程1——形成初始命令》一文中的说明，shell的分割元字符包括&lt;code>()&amp;lt;&amp;gt;;&amp;amp;| \t\n&lt;/code>这几个，因此我们来举几个shell中的单词例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>./exec
&lt;span class="ln">2&lt;/span>/bin/more
&lt;span class="ln">3&lt;/span>../../test.sh
&lt;span class="ln">4&lt;/span>&lt;span class="s2">&amp;#34;hello world&amp;#34;&lt;/span> &lt;span class="c1"># 必须要在引号中&lt;/span>
&lt;span class="ln">5&lt;/span>cat
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的例子都可以称为一个单词来作为简单命令。&lt;/p>
&lt;p>那么bash如何来查找这个命令呢？&lt;/p>
&lt;p>首先如果这个命令以&lt;code>.&lt;/code>或者&lt;code>/&lt;/code>开头，则说明用户指定了命令的路径，bash必须&lt;strong>根据用户指定的路径去查找是否存在该命令&lt;/strong>。其中，如果以&lt;code>.&lt;/code>开头，则以当前文件夹为基准使用相对路径；如果以&lt;code>/&lt;/code>开头，则使用绝对路径。&lt;/p>
&lt;p>如果命令中不以&lt;code>.&lt;/code>或者&lt;code>/&lt;/code>开头，则依以下顺序来查找命令：&lt;/p>
&lt;ol>
&lt;li>查看命令名称是否为shell函数，如果这个名称是shell函数，那么命令将按照Shell函数中的描述被调用。（可以用&lt;code>set&lt;/code>命令查看当前所有定义的函数）&lt;/li>
&lt;li>查看命令是否为内建命令（&lt;code>builtins&lt;/code>），如果找到匹配，则调用该内建命令。&lt;/li>
&lt;li>查看&lt;code>$PATH&lt;/code>路径，按顺序从左到右依次查找&lt;code>$PATH&lt;/code>路径中的每一项，查看该元素下所有可执行文件，直到匹配到命令。&lt;/li>
&lt;li>如果&lt;code>$PATH&lt;/code>中没有找到匹配的路径，那么shell会抛出&lt;code>command_not_found&lt;/code>错误。&lt;/li>
&lt;/ol>
&lt;p>在shell实现时，bash使用哈希表来记住可执行文件的完整路径名，以避免频繁的&lt;code>$PATH&lt;/code>搜索。只有在哈希表中找不到该命令时，才会执行&lt;code>$PATH&lt;/code>目录中的完整搜索，这通常发生在修改了&lt;code>$PATH&lt;/code>变量之后。&lt;/p>
&lt;h2 id="命令执行">命令执行&lt;/h2>
&lt;p>如果我们在第13步中找到了可行性文件，那么将来到最后一步，执行该命令。&lt;strong>这一步是shell运行的最终目的&lt;/strong>，但也是bash管的最少的一步，因为接下来如何执行该命令就完全交由可执行文件自己决定。&lt;/p>
&lt;p>bash要做的只是将执行的命令为位置参数0，并把后面的所有单词作为位置参数传递给可执行文件，之后就等待可执行文件运行结束并收集其退出状态。当然如果该命令是异步执行的，shell就不必等待其结束。&lt;/p>
&lt;p>最核心的一步也是shell最简单的一步，颇有一种功成身退，翩然而去的风味。&lt;/p>
&lt;p>如果我们在深入的了解一下执行流程，会发现shell在执行命令之前还做了一些环境设置的工作，这些环境设置工作虽然不显山不露水，但是若是不了解，就会产生不少奇怪的问题。&lt;/p>
&lt;p>此外，当执行一个简单的命令，而不是一个内建函数或shell函数时，它将在一个&lt;strong>独立的执行环境中调用&lt;/strong>，该环境由以下几部分组成。 除非另有说明，否则这些值是从原shell继承而来的。&lt;/p>
&lt;p>我们先来看看shell有哪些命令执行环境：&lt;/p>
&lt;ol>
&lt;li>打开的文件信息。Linux中一切皆文件，因此这个打开的“文件”是一个广义概念，目前正在使用的设备、socket等都是文件的范畴，最常见的文件信息就是标准输入输出文件，它们记录了文件输入输出的位置。&lt;/li>
&lt;li>当前的工作目录。这个环境可通过&lt;code>cd, pushd, popd&lt;/code>修改也可继承自启动该bash的程序。&lt;/li>
&lt;li>umask信息和文件的读写执行权限有关。&lt;/li>
&lt;li>trap(后面会提，常用于信号的处理)&lt;/li>
&lt;li>通过set设置或从父shell继承的shell参数&lt;/li>
&lt;li>在执行期间定义的shell函数或从环境中的shell父项继承的函数&lt;/li>
&lt;li>在调用时启用的选项（默认或通过命令行参数或set设置）&lt;/li>
&lt;li>由shopt启用的选项&lt;/li>
&lt;li>使用alias定义的shell别名&lt;/li>
&lt;li>各种进程ID，包括包括后台作业信息，$$和$PPID的值&lt;/li>
&lt;/ol>
&lt;p>当执行一个&lt;code>$PATH&lt;/code>中的命令，而不是一个内建函数或shell函数时，它将在一个&lt;strong>独立的执行环境中&lt;/strong>调用，该环境由以下几部分组成。&lt;/p>
&lt;ol>
&lt;li>打开的文件信息。&lt;/li>
&lt;li>当前的工作目录。&lt;/li>
&lt;li>umask信息&lt;/li>
&lt;li>trap&lt;/li>
&lt;li>在环境中传递的标记为&lt;code>export&lt;/code>的shell变量和函数以及为命令导出的变量&lt;/li>
&lt;/ol>
&lt;p>在这个单独的环境中调用的命令不会影响shell的执行环境。&lt;/p>
&lt;h2 id="用户手动管理任务">用户手动管理任务&lt;/h2>
&lt;p>shell每执行一个命令，Linux就相当于启动了一个任务。任务之间未必是一个接一个顺序执行的，bash shell可能启动了多个任务同时运行，因此还需要进行任务管理和调度。对于大多数小型计算机系统来说，任务（进程）都是由内核自动进行调度的，用户几乎无法直接控制任务的执行顺序，至多给他们设置任务优先级，进行间接调控。&lt;strong>Unix系统是第一个让用户能够直接控制多个进程的小型操作系统&lt;/strong>，这个做法评价不一，Linux也继承这个功能，被称为&lt;strong>用户控制的多任务&lt;/strong>。&lt;/p>
&lt;p>首先，要区别的进程ID（Process ID）和作业号（Job Number）。当shell开始执行一个命令时，Linux会创建对应的进程并给进程标号，这个标号就是&lt;strong>进程ID&lt;/strong>。进程执行时，默认情况下让bash等待其运行完，如果命令后面加个&lt;code>&amp;amp;&lt;/code>符号，进程会被放到后台执行，bash仍能够和用户交互。示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ which ls &lt;span class="p">&amp;amp;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span> &lt;span class="m">7091&lt;/span>
&lt;span class="ln">3&lt;/span>/usr/bin/ls
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，7091是Linux系统分配的&lt;strong>进程ID&lt;/strong>，[1]是当前shell给它分配的&lt;strong>作业号&lt;/strong>。作业号只是当前shell给它所启动的任务分配的编号，而进程ID是整个系统中，所有用户正在执行任务的编号。&lt;/p>
&lt;h3 id="信号机制与trap">信号机制与trap&lt;/h3>
&lt;p>信号（Signal）是在软件层次上对中断机制的一种&lt;strong>模拟&lt;/strong>，一个进程通过给另一个进程发送信号，使其执行相应的处理函数，属于一种进程间通信（Interprocess Communication, IPC）。在shell语境下，bash通常使用&lt;code>kill&lt;/code>命令发送信号命令给某一进程（常用进程ID指定），而收到信号的进程使用&lt;code>trap&lt;/code>命令处理信号。当然，bash也支持从键盘快捷键直接输入信号，如ctrl+c, ctrl+z等。Linux支持的信号用1-64的数字表示，分为非实时信号(不可靠信号)和实时信号(可靠信号)两种类型，对应于 Linux 的信号值为 1-31 和 34-64。非实时信号，不支持队列，信号可能会丢失，比如发送多次相同的信号，进程只能收到一次，如果第一个信号没有处理完，第二个信号将会丢弃。实时信号支持队列，发多少次进程就可以收到多少次。&lt;/p>
&lt;p>我们先看看&lt;code>kill&lt;/code>命令格式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">kill&lt;/span> &lt;span class="o">[&lt;/span>-s sigspec &lt;span class="p">|&lt;/span> -n signum &lt;span class="p">|&lt;/span> -sigspec&lt;span class="o">]&lt;/span> pid &lt;span class="p">|&lt;/span> jobspec ... &lt;span class="c1"># 给特定进程发送信号&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="c1"># 默认发送信号为 TERM （15）&lt;/span>
&lt;span class="ln">3&lt;/span>-l &lt;span class="o">[&lt;/span>sigspec/signum&lt;span class="o">]&lt;/span> &lt;span class="c1"># 打印名称/编号对应的特定信号编号/名称&lt;/span>
&lt;span class="ln">4&lt;/span>-s  &lt;span class="c1"># 使用信号名称&lt;/span>
&lt;span class="ln">5&lt;/span>-n  &lt;span class="c1"># 使用信号编号&lt;/span>
&lt;span class="ln">6&lt;/span>-l  &lt;span class="c1"># 打印编号1-31信号名称&lt;/span>
&lt;span class="ln">7&lt;/span>pid &lt;span class="c1"># 进程ID&lt;/span>
&lt;span class="ln">8&lt;/span>jobapec &lt;span class="c1"># 作业号，使用的时候前面加%，例如作业号为1的作业为%1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>kill&lt;/code>虽然名字叫&lt;code>杀&lt;/code>，却是发送任意信号的命令。之所以叫杀，是因为默认发送的是杀死进程的命令（SIGTERM）。举个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1"># 我们在后台启动一个cat程序&lt;/span>
&lt;span class="ln"> 2&lt;/span>$ cat &lt;span class="p">&amp;amp;&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span> &lt;span class="m">31930&lt;/span> &lt;span class="c1"># [1]是作业号，属于当前shell，31930是进程ID，属于系统&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="c1"># 我们用kill 发送一个信号终止cat进程&lt;/span>
&lt;span class="ln"> 5&lt;/span>$ &lt;span class="nb">kill&lt;/span> -n &lt;span class="m">15&lt;/span> &lt;span class="m">31930&lt;/span> &lt;span class="c1"># 或者 kill -s SINTERM 31930&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span>+ Stopped cat
&lt;span class="ln"> 7&lt;/span>$ cat &lt;span class="p">&amp;amp;&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="o">[&lt;/span>2&lt;span class="o">]&lt;/span> &lt;span class="m">31931&lt;/span>
&lt;span class="ln"> 9&lt;/span>$ &lt;span class="nb">kill&lt;/span> -s SIGTERM %2 &lt;span class="c1"># 使用作业号&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="o">[&lt;/span>2&lt;span class="o">]&lt;/span>+ Stopped cat
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果SIGTERM（15）信号无法终止，可以再尝试SIGKILL（9）信号，该信号要求立即停止进程，不能捕获，不能忽略。&lt;/p>
&lt;p>&lt;strong>Linux支持的信号见&lt;/strong>&lt;a href="#linux%E4%BF%A1%E5%8F%B7%E8%A1%A8">Linux信号表&lt;/a>。&lt;/p>
&lt;p>如果一个进程收到了信号，可以通过三种方式来响应一个信号：&lt;/p>
&lt;ol>
&lt;li>忽略信号，即对信号不做任何处理，其中有两个信号不能忽略：SIGKILL及SIGSTOP。&lt;/li>
&lt;li>执行缺省操作，Linux对每种信号都规定了默认操作。&lt;/li>
&lt;li>捕捉信号。&lt;/li>
&lt;/ol>
&lt;p>默认情况下，当一个进程接收到信号之后，会根据&lt;a href="#linux%E4%BF%A1%E5%8F%B7%E8%A1%A8">Linux信号表&lt;/a>的默认（缺省）操作行事，或者根据系统情况直接忽略信号。然后，bash给我们提供了一个能够按需要自行处理信号的功能，&lt;code>trap&lt;/code>。&lt;code>trap&lt;/code>命令定义shell脚本在运行时根据接收的信号做相应的处理，该命令对于编写较复杂shell程序有很大意义，提供了类似其他编程语言中异常处理的功能。其使用如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">trap&lt;/span> &lt;span class="o">[&lt;/span>-lp&lt;span class="o">]&lt;/span> &lt;span class="o">[[&lt;/span>arg&lt;span class="o">]&lt;/span> sigspec ...&lt;span class="o">]&lt;/span>
&lt;span class="ln">2&lt;/span>-l &lt;span class="c1"># 打印编号1-64编号信号名称&lt;/span>
&lt;span class="ln">3&lt;/span>-p &lt;span class="c1"># 查看当前已经设置的trap内容&lt;/span>
&lt;span class="ln">4&lt;/span>arg &lt;span class="c1"># 捕获信号后执行的命令或者函数&lt;/span>
&lt;span class="ln">5&lt;/span>signal_spec &lt;span class="c1"># 信号名或编号，可以是一个或多个&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当接收到特定信号后，&lt;code>trap&lt;/code>检查是否是自己需要处理的信号，如果是则执行&lt;code>arg&lt;/code>指定的命令或函数，执行完后，从刚刚程序中断的地方继续执行。如果命令参数&lt;code>arg&lt;/code>为空字符串或者&lt;code>-&lt;/code>，这时shell进程和shell进程内的子进程都会&lt;strong>忽略&lt;/strong>该信号（相当于什么都不执行）。我们新建一个有执行权限的&lt;code>loop.sh&lt;/code>的文件来举例，其内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#! /bin/bash
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1"># 无限循环睡眠60s的操作&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">while&lt;/span> true&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln">4&lt;/span> sleep &lt;span class="m">60&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当我们直接执行上述shell脚本时，bash会处于一直等待状态，直到我们使用键盘的键入中断命令ctrl+c。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ ./loop.sh
&lt;span class="ln">2&lt;/span>^C
&lt;span class="ln">3&lt;/span>$
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Bash所有脚本都自带默认的处理信号的机制&lt;/strong>，当我们输入ctrl+c之后，相当于向正在执行的&lt;code>loop.sh&lt;/code>进程发送了&lt;code>SIGINT(2)&lt;/code>，并触发了默认处理即中断正在运行的任务。&lt;/p>
&lt;p>如果我们希望接收到信号之后，由&lt;code>trap&lt;/code>捕获并按照自己的需求处理信号，而非默认方式，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#! /bin/bash
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="nb">trap&lt;/span> &lt;span class="s2">&amp;#34;echo &amp;#39;You hit control-C!&amp;#39;&amp;#34;&lt;/span> INT &lt;span class="c1"># 使用自定义的命令处理SIGINT信号&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="c1"># 无限循环睡眠60s的操作&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="k">while&lt;/span> true&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln">5&lt;/span> sleep &lt;span class="m">60&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当我们再次执行&lt;code>loop.sh&lt;/code>脚本时有:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ ./loop.sh
&lt;span class="ln">2&lt;/span>^CYou hit control-C
&lt;span class="ln">3&lt;/span>^CYou hit control-C
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们发现，当我们输入ctrl+c之后（即向进程发送&lt;code>SIGINT(2)&lt;/code>），脚本并没有停止运行，只是返回了'You hit control-C'。在脚本中，&lt;code>trap&lt;/code>捕获了&lt;code>SIGINT(2)&lt;/code>信号，并通过用户自定义的&lt;code>echo 'You hit control-C!'&lt;/code>命令来实现对信号的处理，覆盖了默认的终止操作。我们还可以给脚本添加其他信号处理的&lt;code>trap&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#! /bin/bash
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="nb">trap&lt;/span> &lt;span class="s2">&amp;#34;echo &amp;#39;You tried to kill me!&amp;#39;&amp;#34;&lt;/span> TERM &lt;span class="c1"># 使用自定义的命令处理SIGTERM信号(kill的默认信号) &lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nb">trap&lt;/span> &lt;span class="s2">&amp;#34;echo &amp;#39;You hit control-C!&amp;#39;&amp;#34;&lt;/span> INT &lt;span class="c1"># 使用自定义的命令处理SIGINT信号&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="c1"># 无限循环睡眠60s的操作&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="k">while&lt;/span> true&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln">6&lt;/span> sleep &lt;span class="m">60&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在执行&lt;code>loop.sh&lt;/code>后，不管是使用默认的&lt;code>kill&lt;/code>还是直接键盘输入ctrl+c，都不会终止程序，反而会给我们返回信息。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ ./loop.sh
&lt;span class="ln">2&lt;/span>^CYou hit control-C!
&lt;span class="ln">3&lt;/span>^Z &lt;span class="c1"># ctrl+z 放到后台并终止&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span>+ Stopped ./loop.sh
&lt;span class="ln">5&lt;/span>$ &lt;span class="nb">kill&lt;/span> %1
&lt;span class="ln">6&lt;/span>Terminated &lt;span class="c1"># 接收到终止信号，并没有实际终止loop.sh&lt;/span>
&lt;span class="ln">7&lt;/span>You tried to &lt;span class="nb">kill&lt;/span> me!
&lt;span class="ln">8&lt;/span>$ &lt;span class="nb">jobs&lt;/span> &lt;span class="c1"># 表明loop.sh还在运行&lt;/span>
&lt;span class="ln">9&lt;/span>&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span>+ Running ./loop.sh &lt;span class="p">&amp;amp;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果我们希望杀死该运行中的脚本，需要使用其他信号，例如SIGKILL（9）.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nb">kill&lt;/span> -9 %1
&lt;span class="ln">2&lt;/span>$ &lt;span class="nb">jobs&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span>+ Killed ./loop.sh
&lt;span class="ln">4&lt;/span>$ &lt;span class="nb">jobs&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后，还有一点需要说明，如果脚本中针对同一个信号设置了多个&lt;code>trap&lt;/code>，那么后一个&lt;strong>执行的&lt;/strong>&lt;code>trap&lt;/code>会覆盖之前的&lt;code>trap&lt;/code>，即&lt;strong>对于同一个信号，只有最后一次&lt;code>trap&lt;/code>生效&lt;/strong>。另外，&lt;code>trap&lt;/code>只在本进程内有效，它的子进程不会继承&lt;code>trap&lt;/code>的设置。例子如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#! /bin/bash
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="nb">trap&lt;/span> &lt;span class="s2">&amp;#34;echo &amp;#39;Frist trap: You hit control-C!&amp;#39;&amp;#34;&lt;/span> INT
&lt;span class="ln">3&lt;/span>&lt;span class="nb">trap&lt;/span> &lt;span class="s2">&amp;#34;echo &amp;#39;Second trap: You hit control-C!&amp;#39;&amp;#34;&lt;/span> INT
&lt;span class="ln">4&lt;/span>&lt;span class="c1"># 无限循环睡眠60s的操作&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="k">while&lt;/span> true&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln">6&lt;/span> sleep &lt;span class="m">60&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="k">done&lt;/span>
&lt;span class="ln">8&lt;/span>&lt;span class="nb">trap&lt;/span> &lt;span class="s2">&amp;#34;echo &amp;#39;Third trap: You hit control-C!&amp;#39;&amp;#34;&lt;/span> INT
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在执行此脚本后，键盘使用&lt;code>ctrl+c&lt;/code>结果是&lt;code>^CSecond trap: You hit control-C!&lt;/code>。因为shell在顺序执行时，第二个&lt;code>trap&lt;/code>覆盖了第一个&lt;code>trap&lt;/code>的操作，同时由于陷入了&lt;code>while true&lt;/code>死循环，第三个&lt;code>trap&lt;/code>一直没有执行到，因此第三个&lt;code>trap&lt;/code>也一直没有生效。最后结果就是第二个&lt;code>trap&lt;/code>生效。&lt;/p>
&lt;h3 id="作业控制">作业控制&lt;/h3>
&lt;p>我们前一节已经了解了基于信号的任务控制管理机制，例如&lt;code>kill, trap&lt;/code>等，而bash为了方便进程管理，也有自己一套作业控制系统，包括&lt;code>&amp;amp;, bg, fg, disown, suspend&lt;/code>等。作业控制系统不仅支持使用进程ID来指定要管理的进程，也支持通过作业号(&lt;code>%&lt;/code>符号, jobspec)指定。&lt;/p>
&lt;p>最常见的作业控制符号就是&lt;code>&amp;amp;&lt;/code>，当一个命令以&lt;code>&amp;amp;&lt;/code>结尾时，意味着这条命令放到后台执行。现在我们打开三个后台执行的命令:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ less /etc/cron.d/anacron &lt;span class="p">&amp;amp;&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span> &lt;span class="m">17357&lt;/span>
&lt;span class="ln"> 3&lt;/span>$ vim &lt;span class="p">&amp;amp;&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="o">[&lt;/span>2&lt;span class="o">]&lt;/span> &lt;span class="m">18781&lt;/span>
&lt;span class="ln"> 5&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span>+ Stopped less /etc/cron.d/anacron
&lt;span class="ln"> 7&lt;/span>$ cat &lt;span class="p">&amp;amp;&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="o">[&lt;/span>3&lt;span class="o">]&lt;/span> &lt;span class="m">20137&lt;/span>
&lt;span class="ln"> 9&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="o">[&lt;/span>2&lt;span class="o">]&lt;/span>+ Stopped vim
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这三个命令分别形成了当前bash的三个作业，如果我们要查看当前bash的作业情况，可使用&lt;code>jobs&lt;/code>命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">jobs&lt;/span> &lt;span class="o">[&lt;/span>-lnprs&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span> jobspec ... &lt;span class="o">]&lt;/span>
&lt;span class="ln">2&lt;/span> -l 列出当前作业信息（包括进程ID）
&lt;span class="ln">3&lt;/span> -n 仅显示有关自上次通知用户以来，状态已更的作业信息。
&lt;span class="ln">4&lt;/span> -p 仅列出作业进程组组长的进程ID。
&lt;span class="ln">5&lt;/span> -r 仅显示running状态的作业。
&lt;span class="ln">6&lt;/span> -s 仅显示stopped状态的作业
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当前shell执行&lt;code>jobs&lt;/code>效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nb">jobs&lt;/span> -l
&lt;span class="ln">2&lt;/span>&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span> &lt;span class="m">17357&lt;/span> Stopped &lt;span class="o">(&lt;/span>tty output&lt;span class="o">)&lt;/span> less /etc/cron.d/anacron
&lt;span class="ln">3&lt;/span>&lt;span class="o">[&lt;/span>2&lt;span class="o">]&lt;/span>- &lt;span class="m">18781&lt;/span> Stopped &lt;span class="o">(&lt;/span>tty output&lt;span class="o">)&lt;/span> vim
&lt;span class="ln">4&lt;/span>&lt;span class="o">[&lt;/span>3&lt;span class="o">]&lt;/span>+ &lt;span class="m">20137&lt;/span> Stopped &lt;span class="o">(&lt;/span>tty input&lt;span class="o">)&lt;/span> cat
&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一行表示的就是作业号(jobspec)，后面的&lt;code>+&lt;/code>表示最近添加到作业列表中的作业，&lt;code>-&lt;/code>表示倒数第二最近添加到作业列表中的作业。第二组数字表示进程号，第三组表示状态，当前三个作业都是停止状态。目前此shell中，有三个处于后台的作业，即我们刚才启动的作业。如果我们希望把后台的作业调到前台来继续执行，可以使用&lt;code>fg&lt;/code>命令，其使用方式为&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="nb">fg&lt;/span> &lt;span class="o">[&lt;/span>%&lt;span class="o">][&lt;/span>jobspec&lt;span class="o">]&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="c1"># 在指定作业号时，加不加%符号没有区别。如果不加任何参数，那么会将最近添加到作业列表中的作业（带+号）放到前台&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="nb">fg&lt;/span> %1
&lt;span class="ln"> 4&lt;/span>&lt;span class="c1"># /etc/cron.d/anacron: crontab entries for the anacron package&lt;/span>
&lt;span class="ln"> 5&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="nv">SHELL&lt;/span>&lt;span class="o">=&lt;/span>/bin/sh
&lt;span class="ln"> 7&lt;/span>&lt;span class="nv">PATH&lt;/span>&lt;span class="o">=&lt;/span>/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="m">30&lt;/span> &lt;span class="m">7&lt;/span> * * * root &lt;span class="nb">test&lt;/span> -x /etc/init.d/anacron &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> /usr/sbin/invoke-rc.d anacron start &amp;gt;/dev/null
&lt;span class="ln">10&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当我们恢复作业号为1的任务时，效果如上，将&lt;code>less /etc/cron.d/anacron&lt;/code>命令调到了前台。如果我们想在把它放回后台，可以使用&lt;code>ctrl+z&lt;/code>，即可挂起该进程变放入后台。&lt;/p>
&lt;p>若我们仅仅是想让一个任务在后台执行起来而不用调到前台，可以使用&lt;code>bg&lt;/code>命令直接在后台恢复执行，用法和&lt;code>fg&lt;/code>相似。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">bg&lt;/span> &lt;span class="o">[&lt;/span>jobspec …&lt;span class="o">]&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="c1"># 在后台恢复每个挂起的作业jobspec，就好像它已经以‘&amp;amp;’开始。 如果不加任何参数，那么启动最近添加到作业列表中的作业（带+号）&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此外，还有两个常用的作业控制命令&lt;code>disown&lt;/code>和&lt;code>suspend&lt;/code>，简要介绍下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1"># 从当前shell的作业列表中移除作业&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="nb">disown&lt;/span> &lt;span class="o">[&lt;/span>-ar&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-h&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>jobspec … &lt;span class="p">|&lt;/span> pid … &lt;span class="o">]&lt;/span>
&lt;span class="ln"> 3&lt;/span> -h 标记每个作业标识符，这些作业将不会在shell接收到sighup信号时接收到sighup信号。
&lt;span class="ln"> 4&lt;/span> -a 移除所有的作业。
&lt;span class="ln"> 5&lt;/span> -r 移除运行的作业。
&lt;span class="ln"> 6&lt;/span> jobspec（可选）：要移除的作业标识符，可以是一到多个。
&lt;span class="ln"> 7&lt;/span> pid（可选）：要移除的作业对应的进程ID，可以是一到多个。
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="c1"># 暂停目前正在执行的shell。若要恢复，则必须使用SIGCONT信息。&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="nb">suspend&lt;/span> &lt;span class="o">[&lt;/span>-f&lt;span class="o">]&lt;/span>
&lt;span class="ln">11&lt;/span>-f 　若目前执行的shell为登入的shell，则suspend预设无法暂停此shell。若要强迫暂停登入的shell，则必须使用-f参数。
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在此，我们完成了对shell骨干流程的梳理。这个笔记涵盖了shell执行流程中的大部分问题，还有一些小的方面比如进程协同、多进程、进程替换等并未说明，这是由于用的比较少，等到用到的时候再去学习吧。Keep going!&lt;/p>
&lt;h2 id="linux信号表">Linux信号表&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">编号&lt;/th>
&lt;th style="text-align:center">信号名称&lt;/th>
&lt;th style="text-align:center">缺省动作&lt;/th>
&lt;th style="text-align:center">描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">SIGHUP&lt;/td>
&lt;td style="text-align:center">终止&lt;/td>
&lt;td style="text-align:center">终止进程，挂起&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">2&lt;/td>
&lt;td style="text-align:center">SIGINT&lt;/td>
&lt;td style="text-align:center">终止&lt;/td>
&lt;td style="text-align:center">键盘输入中断命令，一般是CTRL+C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">3&lt;/td>
&lt;td style="text-align:center">SIGQUIT&lt;/td>
&lt;td style="text-align:center">CoreDump&lt;/td>
&lt;td style="text-align:center">键盘输入退出命令，一般是CTRL+\&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">4&lt;/td>
&lt;td style="text-align:center">SIGILL&lt;/td>
&lt;td style="text-align:center">CoreDump&lt;/td>
&lt;td style="text-align:center">非法指令&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">5&lt;/td>
&lt;td style="text-align:center">SIGTRAP&lt;/td>
&lt;td style="text-align:center">CoreDump&lt;/td>
&lt;td style="text-align:center">trap指令发出，一般调试用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">6&lt;/td>
&lt;td style="text-align:center">SIGABRT&lt;/td>
&lt;td style="text-align:center">CoreDump&lt;/td>
&lt;td style="text-align:center">abort(3)发出的终止信号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">7&lt;/td>
&lt;td style="text-align:center">SIGBUS&lt;/td>
&lt;td style="text-align:center">CoreDump&lt;/td>
&lt;td style="text-align:center">非法地址&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">8&lt;/td>
&lt;td style="text-align:center">SIGFPE&lt;/td>
&lt;td style="text-align:center">CoreDump&lt;/td>
&lt;td style="text-align:center">浮点数异常&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">9&lt;/td>
&lt;td style="text-align:center">SIGKILL&lt;/td>
&lt;td style="text-align:center">终止&lt;/td>
&lt;td style="text-align:center">立即停止进程，不能捕获，不能忽略&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">10&lt;/td>
&lt;td style="text-align:center">SIGUSR&lt;/td>
&lt;td style="text-align:center">终止&lt;/td>
&lt;td style="text-align:center">用户自定义信号1，像Nginx就支持USR1信号，用于重载配置，重新打开日志&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">11&lt;/td>
&lt;td style="text-align:center">SIGSEGV&lt;/td>
&lt;td style="text-align:center">CoreDump&lt;/td>
&lt;td style="text-align:center">无效内存引用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">12&lt;/td>
&lt;td style="text-align:center">SIGUSR&lt;/td>
&lt;td style="text-align:center">终止&lt;/td>
&lt;td style="text-align:center">用户自定义信号2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">13&lt;/td>
&lt;td style="text-align:center">SIGPIPE&lt;/td>
&lt;td style="text-align:center">终止&lt;/td>
&lt;td style="text-align:center">管道不能访问&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">14&lt;/td>
&lt;td style="text-align:center">SIGALRM&lt;/td>
&lt;td style="text-align:center">终止&lt;/td>
&lt;td style="text-align:center">时钟信号，alrm(2)发出的终止信号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">15&lt;/td>
&lt;td style="text-align:center">SIGTERM&lt;/td>
&lt;td style="text-align:center">终止&lt;/td>
&lt;td style="text-align:center">终止信号，进程会先关闭正在运行的任务或打开的文件再终止，有时间进程在有运行的任务而忽略此信号。不能捕捉&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">16&lt;/td>
&lt;td style="text-align:center">SIGSTKFLT&lt;/td>
&lt;td style="text-align:center">终止&lt;/td>
&lt;td style="text-align:center">处理器栈错误&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">17&lt;/td>
&lt;td style="text-align:center">SIGCHLD&lt;/td>
&lt;td style="text-align:center">可忽略&lt;/td>
&lt;td style="text-align:center">子进程结束时，父进程收到的信号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">18&lt;/td>
&lt;td style="text-align:center">SIGCONT&lt;/td>
&lt;td style="text-align:center">可忽略&lt;/td>
&lt;td style="text-align:center">让终止的进程继续执行&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">19&lt;/td>
&lt;td style="text-align:center">SIGSTOP&lt;/td>
&lt;td style="text-align:center">停止&lt;/td>
&lt;td style="text-align:center">停止进程，不能忽略，不能捕获&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">20&lt;/td>
&lt;td style="text-align:center">SIGSTP&lt;/td>
&lt;td style="text-align:center">停止&lt;/td>
&lt;td style="text-align:center">停止进程，一般是CTRL+Z&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">21&lt;/td>
&lt;td style="text-align:center">SIGTTIN&lt;/td>
&lt;td style="text-align:center">停止&lt;/td>
&lt;td style="text-align:center">后台进程从终端读数据&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">22&lt;/td>
&lt;td style="text-align:center">SIGTTOU&lt;/td>
&lt;td style="text-align:center">停止&lt;/td>
&lt;td style="text-align:center">后台进程从终端写数据&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">23&lt;/td>
&lt;td style="text-align:center">SIGURG&lt;/td>
&lt;td style="text-align:center">可忽略&lt;/td>
&lt;td style="text-align:center">紧急数组是否到达socket&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">24&lt;/td>
&lt;td style="text-align:center">SIGXCPU&lt;/td>
&lt;td style="text-align:center">CoreDump&lt;/td>
&lt;td style="text-align:center">超出CPU占用资源限制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">25&lt;/td>
&lt;td style="text-align:center">SIGXFSZ&lt;/td>
&lt;td style="text-align:center">CoreDump&lt;/td>
&lt;td style="text-align:center">超出文件大小资源限制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">26&lt;/td>
&lt;td style="text-align:center">SIGVTALRM&lt;/td>
&lt;td style="text-align:center">终止&lt;/td>
&lt;td style="text-align:center">虚拟时钟信号，类似于SIGALRM，但计算的是进程占用的时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">27&lt;/td>
&lt;td style="text-align:center">SIGPROF&lt;/td>
&lt;td style="text-align:center">终止&lt;/td>
&lt;td style="text-align:center">类似与SIGALRM，但计算的是进程占用CPU的时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">28&lt;/td>
&lt;td style="text-align:center">SIGWINCH&lt;/td>
&lt;td style="text-align:center">可忽略&lt;/td>
&lt;td style="text-align:center">窗口大小改变发出的信号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">29&lt;/td>
&lt;td style="text-align:center">SIGIO&lt;/td>
&lt;td style="text-align:center">终止&lt;/td>
&lt;td style="text-align:center">文件描述符准备就绪，可以输入/输出操作了&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">30&lt;/td>
&lt;td style="text-align:center">SIGPWR&lt;/td>
&lt;td style="text-align:center">终止&lt;/td>
&lt;td style="text-align:center">电源失败&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">31&lt;/td>
&lt;td style="text-align:center">SIGSYS&lt;/td>
&lt;td style="text-align:center">CoreDump&lt;/td>
&lt;td style="text-align:center">非法系统调用&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>CoreDump（核心转储）：当程序运行过程中异常退出时，内核把当前程序在内存状况存储在一个core文件中，以便调试。&lt;/p>
&lt;/blockquote></description></item><item><title>shell-骨干流程3——命令展开</title><link>https://surprisedcat.github.io/projectnotes/shell-%E9%AA%A8%E5%B9%B2%E6%B5%81%E7%A8%8B3%E5%91%BD%E4%BB%A4%E5%B1%95%E5%BC%80/</link><pubDate>Tue, 04 Jan 2022 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/shell-%E9%AA%A8%E5%B9%B2%E6%B5%81%E7%A8%8B3%E5%91%BD%E4%BB%A4%E5%B1%95%E5%BC%80/</guid><description>
&lt;ul>
&lt;li>&lt;a href="#shell%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">shell的模式匹配&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%A4%A7%E6%8B%AC%E5%8F%B7%E5%B1%95%E5%BC%80">大括号展开&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%B3%A2%E6%B5%AA%E7%AC%A6%E5%8F%B7%E5%B1%95%E5%BC%80">波浪符号展开&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#shell%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%A0%86%E6%A0%88">shell文件目录堆栈&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%E5%8F%82%E6%95%B0%E4%B8%8E%E5%8F%98%E9%87%8F%E5%B1%95%E5%BC%80">参数与变量展开&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%E5%8F%82%E6%95%B0%E9%97%B4%E6%8E%A5%E6%89%A9%E5%B1%95">参数间接扩展&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D%E6%89%A9%E5%B1%95">参数匹配扩展&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%A9%BA%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86">空参数处理&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%AD%90%E4%B8%B2%E6%89%A9%E5%B1%95">子串扩展&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%82%E6%95%B0%E9%95%BF%E5%BA%A6%E8%AE%A1%E7%AE%97">参数长度计算&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D%E5%88%A0%E9%99%A4">参数匹配删除&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D%E6%9B%BF%E6%8D%A2">参数匹配替换&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E4%BF%AE%E6%94%B9">大小写修改&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C">变量操作&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2">命令替换&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%89%A9%E5%B1%95">算术表达式扩展&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%86%8D%E6%AC%A1%E5%8D%95%E8%AF%8D%E5%88%86%E5%89%B2">再次单词分割&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%90%8D%E5%B1%95%E5%BC%80">路径与文件名展开&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%82%E8%80%83%E5%86%85%E5%AE%B9">参考内容&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>总体流程图镇楼：&lt;/p>
&lt;p>&lt;img src="../../images/shell%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.drawio.svg" alt="shell执行流程">&lt;/p>
&lt;h2 id="命令展开---omit-in-toc---">命令展开&lt;!-- omit in toc -->&lt;/h2>
&lt;p>命令展开是shell变成语言灵活性的最佳体现，如图中绿色部分所示，包含5-11步。展开是对每一个标记(token)分别进行的，共有以下7步，对应总体流程的5-11步。&lt;/p>
&lt;p>第5-7步都是各式各样的命令展开。基本的命令展开包括3种，分别为：大括号展开、波浪符号展开、参数与变量展开。这三种命令展开本质上是shell语法糖的展开。&lt;/p>
&lt;p>第8，9两步实际上是子命令执行，并非语法糖，原始命令将启动子进程（子shell）来执行子命令，执行的结果作为标记，嵌入到原命令中。5-7步和8-9步的区别在于，5-7步本质是查找语法糖对应的内容进行展开，无需使用子进程；8-9步本质是采纳子进程执行的结果，而非简单的查找替换。&lt;/p>
&lt;p>经过5-9步的处理，原始命令已经能够被shell直接执行，因此我们需要第10步将这些替换过后的内容重组起来，根据系统分隔符（Internal Field Seperator，IFS）再次分割（因为命令展开过程中会带来新的内容）。&lt;/p>
&lt;p>最后我们还需要第11步，展开路径和文件名，这一步和之前5-7步展开又是不同的，之前是语法糖替换，而这次是使用shell模式匹配方式（通配符）替换。第11步的shell模式匹配是正则表达式简化版，主要是利用通配符，并非完整的正则表达式规则。&lt;/p>
&lt;p>当命令展开完成后，造成展开的引号将会被全部移除。作为单词整体引用的引号保持原样。例如，&lt;code>hello &amp;quot;$USER&amp;quot;&lt;/code>的引号在变量展开后会移除，而&lt;code>&amp;quot;hello&amp;quot;&lt;/code>的引号则不会。（&lt;strong>这里理解存疑&lt;/strong>）&lt;/p>
&lt;h2 id="shell的模式匹配">shell的模式匹配&lt;/h2>
&lt;p>在介绍shell中各种各样的展开之前，先说下shell的模式匹配。它是标准正则匹配的简化版，尽量保证了正则匹配中的精华，兼顾了匹配的速度。可用于shell流程中的大括号展开和路径与文件名展开。为了方便说明，我们在&lt;code>/tmp/&lt;/code>文件夹下新建&lt;code>patternMatching&lt;/code>文件夹，并在其中新建&lt;code>a.txt aaa.txt abc.txt a.md b.md c.html cd.html ddd.html 001.txt&lt;/code>这9个文件，作为演示示例。&lt;/p>
&lt;p>&lt;strong>注意，shell中默认使用自带的模式匹配，而非正则匹配。模式匹配将在命令展开的各方面的到应用&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nb">cd&lt;/span> /tmp/ &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> mkdir patternMatching &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">cd&lt;/span> patternMatching
&lt;span class="ln">2&lt;/span>$ touch a.txt aaa.txt abc.txt a.md b.md c.html cd.html ddd.html 001.txt
&lt;span class="ln">3&lt;/span>$ ls
&lt;span class="ln">4&lt;/span>001.txt aaa.txt abc.txt a.md a.txt b.md cd.html c.html ddd.html
&lt;/code>&lt;/pre>&lt;/div>&lt;p>shell的模式匹配主要是使用了&lt;strong>通配符&lt;/strong>，通用的有3种，当启用“extglob” shell选项时，则可以使用另外5个扩展模式匹配运算符。除了通配符，模式匹配中的其他内容都保留其字面意思，如果要匹配通配符的字面意思，则需要使用反斜杠&lt;code>\&lt;/code>进行转义。另外，&lt;code>NULL&lt;/code>字符不允许出现在模式匹配中。&lt;/p>
&lt;p>通用的三种通配符有&lt;code>*, ?, [ ]&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>“*”：匹配&lt;strong>任意&lt;/strong>字符串，包括空字符。&lt;/li>
&lt;li>“?”：匹配任何&lt;strong>单个&lt;/strong>字符，必须是一个字符，不匹配空字符。&lt;/li>
&lt;li>“&lt;input disabled="" type="checkbox"> ”：匹配中括号中给定的&lt;strong>一个字符&lt;/strong>。例如&lt;code>[abdgAD134]&lt;/code>就是匹配中括号中的六个字母和三个数字。如果是连续的字符，可以使用连字符分隔的一对字符，来表示匹配范围内的任一字符。在默认环境中，&lt;code>[a-dx-z]&lt;/code>相当于&lt;code>[abcdxyz]&lt;/code>。如果是不想匹配中括号中的内容，可以在开头加上&lt;code>!&lt;/code>或&lt;code>^&lt;/code>，表示取反，如&lt;code>[!a-z]&lt;/code>或&lt;code>[^a-z]&lt;/code>则只匹配表示不匹配字母'a-z'。
&lt;ul>
&lt;li>
&lt;blockquote>
&lt;p>在'['和']'中，可以使用语法指定字符类&lt;code>[[:class:]]&lt;/code>, 这里的&lt;code>class&lt;/code>是下列类型之一，在 POSIX 标准中定义的类型:&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">alnum&lt;/th>
&lt;th style="text-align:center">alpha&lt;/th>
&lt;th style="text-align:center">ascii&lt;/th>
&lt;th style="text-align:center">blank&lt;/th>
&lt;th style="text-align:center">cntrl&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">digit&lt;/td>
&lt;td style="text-align:center">graph&lt;/td>
&lt;td style="text-align:center">lower&lt;/td>
&lt;td style="text-align:center">print&lt;/td>
&lt;td style="text-align:center">punct&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">space&lt;/td>
&lt;td style="text-align:center">upper&lt;/td>
&lt;td style="text-align:center">word&lt;/td>
&lt;td style="text-align:center">xdigit&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>用法示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ ls * &lt;span class="c1"># 显示任意内容&lt;/span>
&lt;span class="ln"> 2&lt;/span>001.txt aaa.txt abc.txt a.md a.txt b.md cd.html c.html ddd.html
&lt;span class="ln"> 3&lt;/span>$ ls a* &lt;span class="c1"># a开头的所有文件&lt;/span>
&lt;span class="ln"> 4&lt;/span>aaa.txt abc.txt a.md a.txt
&lt;span class="ln"> 5&lt;/span>$ ls a? &lt;span class="c1"># ?只匹配一个字符，因此那个都无法匹配上&lt;/span>
&lt;span class="ln"> 6&lt;/span>ls: cannot access &lt;span class="s1">&amp;#39;a?&amp;#39;&lt;/span>: No such file or directory
&lt;span class="ln"> 7&lt;/span>$ ls c?.html &lt;span class="c1"># ？匹配一位，所以c.html没有匹配 &lt;/span>
&lt;span class="ln"> 8&lt;/span>cd.html
&lt;span class="ln"> 9&lt;/span>$ ls &lt;span class="o">[&lt;/span>a-z&lt;span class="o">]&lt;/span>.* &lt;span class="c1"># 匹配所有单个字母为名的文件&lt;/span>
&lt;span class="ln">10&lt;/span>a.md a.txt b.md c.html
&lt;span class="ln">11&lt;/span>$ $ ls &lt;span class="o">[[&lt;/span>:digit:&lt;span class="o">]]&lt;/span>* &lt;span class="c1"># 匹配文件名第一位是数字的文件&lt;/span>
&lt;span class="ln">12&lt;/span>001.txt
&lt;span class="ln">13&lt;/span>$ ls &lt;span class="o">[[&lt;/span>:alpha:&lt;span class="o">]]&lt;/span>* &lt;span class="c1"># # 匹配文件名第一位是字母的文件&lt;/span>
&lt;span class="ln">14&lt;/span>aaa.txt abc.txt a.md a.txt b.md cd.html c.html ddd.html
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果在shell选项中开启了&lt;code>extglob&lt;/code>选项(&lt;code>shopt -s extglob&lt;/code>)，那么shell在模式匹配中可以使用五种扩展模式。&lt;/p>
&lt;ul>
&lt;li>&lt;code>?(pattern-list)&lt;/code>：匹配零个或一个的给定模式。&lt;/li>
&lt;li>&lt;code>*(pattern-list)&lt;/code>：匹配零个或多个的给定模式。&lt;/li>
&lt;li>&lt;code>+(pattern-list)&lt;/code>：匹配一个或多个的给定模式。&lt;/li>
&lt;li>&lt;code>@(pattern-list)&lt;/code>：匹配一个给定的模式。&lt;/li>
&lt;li>&lt;code>!(pattern-list)&lt;/code>：匹配除了给定的模式的其他模式。&lt;/li>
&lt;/ul>
&lt;p>根据上述给出的文件，例子如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ ls c?&lt;span class="o">([&lt;/span>a-z&lt;span class="o">])&lt;/span>.html &lt;span class="c1"># c后面匹配0或1个字母&lt;/span>
&lt;span class="ln"> 2&lt;/span>cd.html c.html
&lt;span class="ln"> 3&lt;/span>$ ls a*&lt;span class="o">([&lt;/span>a-z&lt;span class="o">])&lt;/span>.* &lt;span class="c1"># 匹配以a开头的任意文件（文件后缀由.*匹配）&lt;/span>
&lt;span class="ln"> 4&lt;/span>aaa.txt abc.txt a.md a.txt
&lt;span class="ln"> 5&lt;/span>$ ls a+&lt;span class="o">([&lt;/span>a-z&lt;span class="o">])&lt;/span>.* &lt;span class="c1"># 匹配以a开头，并且不是单个a的文件，也就是说a后面必须有别的字母（文件后缀由.*匹配）&lt;/span>
&lt;span class="ln"> 6&lt;/span>aaa.txt abc.txt
&lt;span class="ln"> 7&lt;/span>$ ls c@&lt;span class="o">([&lt;/span>a-z&lt;span class="o">])&lt;/span>.html &lt;span class="c1"># 严格仅匹配一次&lt;/span>
&lt;span class="ln"> 8&lt;/span>cd.html
&lt;span class="ln"> 9&lt;/span>$ ls !&lt;span class="o">([&lt;/span>a-z&lt;span class="o">])&lt;/span>.* &lt;span class="c1"># 不匹配任何单个字母为名的文件（文件后缀由.*匹配）&lt;/span>
&lt;span class="ln">10&lt;/span>001.txt aaa.txt abc.txt cd.html ddd.html
&lt;span class="ln">11&lt;/span>$ ls +&lt;span class="o">([[&lt;/span>:digit:&lt;span class="o">]])&lt;/span>.* &lt;span class="c1"># 匹配名称全是数字的文件（文件后缀由.*匹配）&lt;/span>
&lt;span class="ln">12&lt;/span>001.txt
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="大括号展开">大括号展开&lt;/h2>
&lt;p>大括号是shell所有展开中的第一步，这意味着在执行大括号展开的时候，其他展开的标识符都存在与其中，这导致大括号展开&lt;strong>相对严格且固定的格式&lt;/strong>，任何不正确的格式都会让shell无法识别大括号展开而原样输出。大括号扩展的语法有两种形式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>preamble&lt;span class="o">{&lt;/span>pattern1,pattern2,...&lt;span class="o">}&lt;/span>postscript
&lt;span class="ln">2&lt;/span>或者
&lt;span class="ln">3&lt;/span>preamble&lt;span class="o">{&lt;/span>start..end&lt;span class="o">[&lt;/span>..incr&lt;span class="o">]}&lt;/span>postscript
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，前导&lt;code>preamble&lt;/code>和后缀&lt;code>postscript&lt;/code>都是可选的，表示大括号左右的内容。&lt;/p>
&lt;p>大括号展开本质上是一种生成多个字符串的机制（由一变多），可用于生成路径和文件名称的字符串、参数的字符串甚至用户自定义输入的字符串。先举几个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ &lt;span class="nb">echo&lt;/span> a&lt;span class="o">{&lt;/span>a,b&lt;span class="o">}&lt;/span>b &lt;span class="c1"># {a,b}生成两个&lt;/span>
&lt;span class="ln"> 2&lt;/span>aab abb
&lt;span class="ln"> 3&lt;/span>$ &lt;span class="nb">echo&lt;/span> a&lt;span class="o">{&lt;/span>xy,yx,yz&lt;span class="o">}&lt;/span> &lt;span class="c1"># 生成3个字符串，无后缀&lt;/span>
&lt;span class="ln"> 4&lt;/span>axy ayx ayz
&lt;span class="ln"> 5&lt;/span>$ &lt;span class="nb">echo&lt;/span> a&lt;span class="o">{&lt;/span>a..d&lt;span class="o">}&lt;/span>b &lt;span class="c1"># 正向序列，生成a,b,c,d四个&lt;/span>
&lt;span class="ln"> 6&lt;/span>aab abb acb adb
&lt;span class="ln"> 7&lt;/span>$ &lt;span class="nb">echo&lt;/span> a&lt;span class="o">{&lt;/span>d..a&lt;span class="o">}&lt;/span>b &lt;span class="c1"># 反向序列，生成d,c,b,a四个&lt;/span>
&lt;span class="ln"> 8&lt;/span>adb acb abb aab
&lt;span class="ln"> 9&lt;/span>$ &lt;span class="nb">echo&lt;/span> a&lt;span class="o">{&lt;/span>d..a..2&lt;span class="o">}&lt;/span>b &lt;span class="c1"># 反向序列，步长为2的方式生成，d,b两个&lt;/span>
&lt;span class="ln">10&lt;/span>adb abb
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看出，大括号的实际效果&lt;strong>是将大括号外的内容和大括号内的每一个内容（用逗号或序列区分）进行组合&lt;/strong>，生成字符串。在使用&lt;strong>逗号&lt;/strong>进行分割的语法中，大括号内至少只要有一个逗号。若没有逗号，shell将不认为是大括号展开，原样输出内容。这同时意味大括号至少会生成两个字符串，如果为大括号内有空内容，生成的时候也是将空内容和大括号左右组合起来。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nb">echo&lt;/span> a&lt;span class="o">{&lt;/span>b&lt;span class="o">}&lt;/span> &lt;span class="c1"># 没有逗号则原样输出&lt;/span>
&lt;span class="ln">2&lt;/span>a&lt;span class="o">{&lt;/span>b&lt;span class="o">}&lt;/span>
&lt;span class="ln">3&lt;/span>$ $ &lt;span class="nb">echo&lt;/span> a&lt;span class="o">{&lt;/span>a,,c&lt;span class="o">}&lt;/span> &lt;span class="c1"># 大括号展开对空内容的处理&lt;/span>
&lt;span class="ln">4&lt;/span>aa a ac
&lt;/code>&lt;/pre>&lt;/div>&lt;p>而使用序列进行大括号展开，一定要使用&lt;code>..&lt;/code>符号，其左边是起始字符，右边是终止字符，默认包括起始和终止字符。如果需要指定步长（INCR），则使用两次&lt;code>..&lt;/code>符号，步长必须是一个整数。。如果不给定步长，shell会根据起始、终止内容自动判断步长为+1或-1。&lt;/p>
&lt;p>大括号展开可以复合，即大括号展开可以内嵌到另一个大括号开展中，并且展开顺序是由外向内。《Bash参考手册》上有一个很有借鉴意义的例子，如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>chown root /usr/&lt;span class="o">{&lt;/span>ucb/&lt;span class="o">{&lt;/span>ex,edit&lt;span class="o">}&lt;/span>,lib/&lt;span class="o">{&lt;/span>ex?.?*,how_ex&lt;span class="o">}}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先将最外层的大括号开展，结果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>chown root /usr/ucb/&lt;span class="o">{&lt;/span>ex,edit&lt;span class="o">}&lt;/span> /usr/lib/&lt;span class="o">{&lt;/span>ex?.?*,how_ex&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后再次执行大括号展开，最终结果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>chown root /usr/ucb/ex /usr/usb/edit /usr/lib/ex?.?* /usr/lib/how_ex
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后需要强调一点：大括号展开又是优先级最高的展开，因此语法结构固定且严格。单、双引号内的大括号不进行展开（参考《Shell 骨干流程1——形成初步命令》的引号章节）；为避免与参数扩展冲突，字符串&lt;code>'${'&lt;/code>亦不被认为是大括号扩展。&lt;/p>
&lt;h2 id="波浪符号展开">波浪符号展开&lt;/h2>
&lt;p>如果一个单词(word)以不带引号的波浪字符（~）开始，那么所有直到第一个非加引号的斜杠（或所有字符，如果没有未加引号的斜杠出现）的字符都被认为是波浪前缀。一般情况下，&lt;strong>波浪字符与shell的环境变量有关&lt;/strong>（如&lt;code>$HOME,$PWD,$OLDPWD&lt;/code>），如果波浪字符与数字组合，那么会涉及到&lt;strong>shell的&lt;code>dirs&lt;/code>内置命令&lt;/strong>，我们将会单独说明。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>波浪字符最常用方法是表示当前用户的HOME目录，即&lt;code>~&lt;/code>等同于&lt;code>$HOME&lt;/code>。如果波浪字符后面加特定用户名，则表示该用户名的HOME目录。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nb">echo&lt;/span> ~ &lt;span class="c1"># 波浪线单独表示当前用户HOME目录&lt;/span>
&lt;span class="ln">2&lt;/span>/home/lelouch
&lt;span class="ln">3&lt;/span>$ &lt;span class="nb">echo&lt;/span> ~root &lt;span class="c1"># 波浪线后面跟用户名表示该用户名的HOME目录&lt;/span>
&lt;span class="ln">4&lt;/span>/root
&lt;span class="ln">5&lt;/span>$ &lt;span class="nb">echo&lt;/span> ~test
&lt;span class="ln">6&lt;/span>/home/test
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>波浪字符与&lt;code>'+,-'&lt;/code>组合，与当前路径有关，&lt;code>~+&lt;/code>表示当前路径(&lt;code>$PWD&lt;/code>)，&lt;code>~-&lt;/code>表示上个路径。&lt;code>'-'&lt;/code>用在路径名中通常表示上次所在目录。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nb">pwd&lt;/span> &lt;span class="c1"># 原始目录&lt;/span>
&lt;span class="ln">2&lt;/span>/home/lelouch
&lt;span class="ln">3&lt;/span>$ &lt;span class="nb">cd&lt;/span> /tmp &lt;span class="c1"># 切换到/tmp目录&lt;/span>
&lt;span class="ln">4&lt;/span>$ &lt;span class="nb">echo&lt;/span> ~+ &lt;span class="c1"># 显示当前目录&lt;/span>
&lt;span class="ln">5&lt;/span>/tmp
&lt;span class="ln">6&lt;/span>$ &lt;span class="nb">echo&lt;/span> ~- &lt;span class="c1"># 显示前一个目录&lt;/span>
&lt;span class="ln">7&lt;/span>/home/lelouch
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>波浪字符、数字N以及可选的&lt;code>'+,-'&lt;/code>组合，则与目录堆栈有关。目录堆栈可用&lt;code>dirs&lt;/code>命令查看。&lt;code>~N&lt;/code>等同于&lt;code>~+N&lt;/code>表示从目录堆栈&lt;strong>顶部&lt;/strong>开始数，&lt;code>~-N&lt;/code>表示从目录堆栈&lt;strong>底部&lt;/strong>开始数。我们单开一个小节来说明。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="shell文件目录堆栈">shell文件目录堆栈&lt;/h3>
&lt;p>shell为了方便用户在多个目录之间直接切换，提供了目录堆栈功能。目录堆栈是将若干个目录放到一起，目录的增删遵循后入先出的规则（和堆栈一样），并且用户可以直接访问到目录堆栈中的任一目录，与目录堆栈相关的命令有：&lt;code>pushd, popd, dirs&lt;/code>。使用&lt;code>dirs&lt;/code>命令可以看到目录堆栈的内容。使用&lt;code>pushd&lt;/code>命令切换到目录同时，会将该目录添加到堆栈顶部，而使用&lt;code>popd&lt;/code>命令会删除堆栈顶部目录。默认情况下，目录堆栈底部总是保留当前目录位置。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ &lt;span class="nb">dirs&lt;/span>
&lt;span class="ln"> 2&lt;/span>~
&lt;span class="ln"> 3&lt;/span>&lt;span class="c1"># dirs 使用指南&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="nb">dirs&lt;/span> &lt;span class="o">[&lt;/span>-clpv&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>+n&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-n&lt;span class="o">]&lt;/span>
&lt;span class="ln"> 5&lt;/span> 当命令不带任何参数时，显示当前目录堆栈的内容，默认情况下，所有内容显示在一行，并以空格分隔。我们使用 &lt;span class="nb">pushd&lt;/span> 命令向目录堆栈压入新的目录项，使用 &lt;span class="nb">popd&lt;/span> 删除目录项。当前目录项始终放在目录堆栈的底部。
&lt;span class="ln"> 6&lt;/span> -c 清除目录堆栈所有条目。
&lt;span class="ln"> 7&lt;/span> -l 生成一个带有全路径名的列表；默认情况下用波浪线代表用户HOME目录。
&lt;span class="ln"> 8&lt;/span> -p 一个目录一行的方式显示。
&lt;span class="ln"> 9&lt;/span> -v 每行一个目录来显示目录栈的内容，每个目录前加上的编号。
&lt;span class="ln">10&lt;/span> +n 显示从左到右的第n个目录，数字从0开始。
&lt;span class="ln">11&lt;/span> -n 显示从右到左的第n个日录，数字从0开始。
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当前所在目录作为目录堆栈的底部常驻目录，无法将其&lt;code>popd&lt;/code>出来。&lt;/p>
&lt;p>shell通过&lt;code>psuhd&lt;/code>和&lt;code>popd&lt;/code>两个命令操作目录堆栈，不加任何参数的情况下，使用&lt;code>pushd&lt;/code>命令切换到目录同时，会将该目录添加到堆栈顶部，而使用&lt;code>popd&lt;/code>命令会删除堆栈顶部目录。若&lt;code>pushd&lt;/code>命令不加任何参数，则会将位于记录栈最上面的2个目录对换位置。当然，&lt;code>psuhd&lt;/code>和&lt;code>popd&lt;/code>有带参数的使用方式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1"># 注意下面的N是数字，n是字母n参数&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="nb">popd&lt;/span> +N &lt;span class="c1"># 删除栈中（从左边数）第N个元素，由0开始计。&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="nb">popd&lt;/span> -N &lt;span class="c1"># 删除栈中（从右边数）第N个元素，由0开始计。&lt;/span>
&lt;span class="ln"> 5&lt;/span>pop -n &lt;span class="c1"># 不改变当前目录（也就是不改变栈顶元素，操作除了栈顶外栈内其他元素）&lt;/span>
&lt;span class="ln"> 6&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="c1"># usage: pushd [-n] [+N | -N | dir] &lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="nb">pushd&lt;/span> &lt;span class="c1"># 不加参数时，交换栈顶前两个元素&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="nb">pushd&lt;/span> +N &lt;span class="c1"># 将栈内元素循环左移，直到将（从左边数）第N个元素移动到栈顶，由0开始计。&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="nb">pushd&lt;/span> -N &lt;span class="c1"># 将栈内元素循环左移，直到将（从右边数）第N个元素移动到栈顶，由0开始计。&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="nb">pushd&lt;/span> -n dir &lt;span class="c1"># 将目录入栈，但不改变当前元素，即将目录插入栈中作为第二个元素。 注意-n参数要在目录之前。&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>借由&lt;code>pushd&lt;/code>和&lt;code>popd&lt;/code>的特性，可以用shell实现目录间的快速定位。&lt;/p>
&lt;p>那么目录堆栈和波浪符号有什么关系呢？答案是&lt;strong>波浪符号与加减号、数字的组合是&lt;code>dirs&lt;/code>与加减号、数字的组合的简写&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>〜N
&lt;span class="ln">2&lt;/span>等同于&lt;span class="s1">&amp;#39;dirs +N&amp;#39;&lt;/span>显示的字符串
&lt;span class="ln">3&lt;/span>
&lt;span class="ln">4&lt;/span>〜+N
&lt;span class="ln">5&lt;/span>等同于&lt;span class="s1">&amp;#39;dirs +N&amp;#39;&lt;/span>显示的字符串
&lt;span class="ln">6&lt;/span>
&lt;span class="ln">7&lt;/span>〜-N
&lt;span class="ln">8&lt;/span>等同于&lt;span class="s1">&amp;#39;dirs -N&amp;#39;&lt;/span>显示的字符串
&lt;/code>&lt;/pre>&lt;/div>&lt;p>举个例子，我们先将&lt;code>/home /usr /etc /tmp ~&lt;/code>反向压入目录堆栈。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ &lt;span class="nb">dirs&lt;/span>
&lt;span class="ln"> 2&lt;/span>/home /usr /etc /tmp ~
&lt;span class="ln"> 3&lt;/span>$ &lt;span class="nb">dirs&lt;/span> +1
&lt;span class="ln"> 4&lt;/span>/usr
&lt;span class="ln"> 5&lt;/span>$ &lt;span class="nb">echo&lt;/span> ~1 ~+1 &lt;span class="c1"># 二者效果等同于dirs +1&lt;/span>
&lt;span class="ln"> 6&lt;/span>/usr /usr
&lt;span class="ln"> 7&lt;/span>$ &lt;span class="nb">dirs&lt;/span> -1
&lt;span class="ln"> 8&lt;/span>/tmp
&lt;span class="ln"> 9&lt;/span>$ &lt;span class="nb">echo&lt;/span> ~-1 &lt;span class="c1"># 效果等同于dirs -1&lt;/span>
&lt;span class="ln">10&lt;/span>/tmp
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参数与变量展开">参数与变量展开&lt;/h2>
&lt;p>&lt;code>$&lt;/code>在shell中是一个非常重要的符号，参数与变量展开、命令替换、算术表达式计算都与&lt;code>$&lt;/code>相关。接下来三个小结，我们将逐个进行介绍。&lt;/p>
&lt;p>首先，&lt;code>$&lt;/code>最常见的功能是组成参数/变量名称，标准模式为&lt;code>${...}&lt;/code>，在不会产生误解的情形下，大括号可以省略。在大于等于10的位置参数、特殊模式变量以及名称中带有特殊符号导致变量名称有二义性时，必须要有大括号包裹。shell中的变量和一般编程语言中变量作用类似，但是在设置变量是不需要使用&lt;code>$&lt;/code>符合，只有在引用变量时才需要，例子如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nv">a&lt;/span>&lt;span class="o">=&lt;/span>hello
&lt;span class="ln">2&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$a&lt;/span>
&lt;span class="ln">3&lt;/span>hello
&lt;span class="ln">4&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">a&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">5&lt;/span>hello
&lt;span class="ln">6&lt;/span>$ &lt;span class="nv">a&lt;/span>&lt;span class="o">=&lt;/span>world
&lt;span class="ln">7&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$a&lt;/span>
&lt;span class="ln">8&lt;/span>world
&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了常规的使用方法，shell还为变量添加了各种各样便利的功能。这些拓展功能都需要使用大括号包裹。&lt;/p>
&lt;h3 id="参数间接扩展">参数间接扩展&lt;/h3>
&lt;p>如果shell变量中，&lt;strong>&lt;code>$&lt;/code>符号后面的第一个字符是感叹号&lt;code>!&lt;/code>，且后面的内容是一个变量的名称&lt;/strong>，那么引用的参数并不是“名称”而是该名称对应的实际的值。这就构成了变量间的间接引用。举个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nv">name&lt;/span>&lt;span class="o">=&lt;/span>linux
&lt;span class="ln">2&lt;/span>$ &lt;span class="nv">paramter&lt;/span>&lt;span class="o">=&lt;/span>name
&lt;span class="ln">3&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="p">!parameter&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># 这里实际等同于${name}&lt;/span>
&lt;span class="ln">4&lt;/span>linux
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上面例子中，&lt;code>${}&lt;/code>中第一个字符是感叹号，而且&lt;code>parameter&lt;/code>是一个变量的名称，其值为&lt;code>name&lt;/code>，因此在执行时shell把&lt;code>!parameter&lt;/code>转换成其变量的值，即为&lt;code>name&lt;/code>，因此扩展后的结果为&lt;code>${name}&lt;/code>，最终显示&lt;code>name&lt;/code>变量的值&lt;code>linux&lt;/code>。当然，如果感叹号后面跟的内容不是变量的名称，那么就会报&lt;code>-bash: parameters: invalid indirect expansion&lt;/code>错误。&lt;/p>
&lt;h3 id="参数匹配扩展">参数匹配扩展&lt;/h3>
&lt;p>参数的匹配扩展与参数间接扩展&lt;strong>外表相似，但是用法完全不同&lt;/strong>。参数匹配扩展的更像是查找变量名前缀相同的变量，因此还引入了通配符&lt;code>*,@&lt;/code>，所以匹配扩展不会涉及变量实际的值。我们在前一个例子基础上增加几个变量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nv">name1&lt;/span>&lt;span class="o">=&lt;/span>ubuntu
&lt;span class="ln">2&lt;/span>$ &lt;span class="nv">name2&lt;/span>&lt;span class="o">=&lt;/span>redhat
&lt;span class="ln">3&lt;/span>$ &lt;span class="nv">name3&lt;/span>&lt;span class="o">=&lt;/span>slackware
&lt;span class="ln">4&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="p">!name*&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">5&lt;/span>name name1 name2 name3
&lt;span class="ln">6&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="p">!name@&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">7&lt;/span>name name1 name2 name3
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看出，参数间接扩展获取的是参数&lt;strong>值&lt;/strong>，参数匹配扩展获取的符合前缀的参数&lt;strong>名&lt;/strong>。如果我们将二者组合起来，就可以获取有相同前缀变量名的值：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="k">for&lt;/span> var in &lt;span class="si">${&lt;/span>&lt;span class="p">!name*&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="k">do&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$var&lt;/span>&lt;span class="s2">--&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="p">!var&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="k">done&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">2&lt;/span>name--linux
&lt;span class="ln">3&lt;/span>name1--ubuntu
&lt;span class="ln">4&lt;/span>name2--redhat
&lt;span class="ln">5&lt;/span>name3--slackware
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个例子中，&lt;code>${!name*}&lt;/code>使用的是参数匹配扩展，匹配所有以&lt;code>name&lt;/code>为前缀的变量，共找到&lt;code>name, name1, name2, name3&lt;/code>四个，然后在for循环遍历中，再用参数间接扩展&lt;code>${!var}&lt;/code>将&lt;code>var&lt;/code>所指向的变量名称的实际值打印出来。&lt;/p>
&lt;p>我们在上文中提到参数匹配扩展可以用&lt;code>*,@&lt;/code>两种符合，那么使用这两种符号有什么区别吗？区别在于：当表达式被&lt;strong>双引号&lt;/strong>包裹时，&lt;code>@&lt;/code>会扩展成&lt;strong>独立的几个变量&lt;/strong>，而&lt;code>*&lt;/code>则会扩展成&lt;strong>变量组合而成的字符串&lt;/strong>。还是以上面的几个两边为例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="k">for&lt;/span> var in &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="p">!name@&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="k">do&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$var&lt;/span>&lt;span class="s2">--&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="p">!var&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="k">done&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">2&lt;/span>name--linux
&lt;span class="ln">3&lt;/span>name1--ubuntu
&lt;span class="ln">4&lt;/span>name2--redhat
&lt;span class="ln">5&lt;/span>name3--slackware
&lt;span class="ln">6&lt;/span>$ &lt;span class="k">for&lt;/span> var in &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="p">!name*&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="k">do&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$var&lt;/span>&lt;span class="s2">--&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="p">!var&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="k">done&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">7&lt;/span>-bash: name name1 name2 name3: invalid variable name
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在双引号中使用&lt;code>@&lt;/code>符号生成的是一个序列，可以通过&lt;code>for&lt;/code>循环遍历；而通过&lt;code>*&lt;/code>符号生成的是一个字符串，&lt;code>for&lt;/code>循环会直接读取整个字符串&lt;code>name name1 name2 name3&lt;/code>作为&lt;code>$var&lt;/code>的值，因此无法找到对应的变量，从而报&lt;code>invalid variable name&lt;/code>错误。&lt;/p>
&lt;h3 id="空参数处理">空参数处理&lt;/h3>
&lt;p>由于shell是一个弱类型且语法较为宽松的编程语言，因此不会对变量是否存在、变量是否为&lt;code>NULL&lt;/code>以及变量类型进行检测。如果使用了一个未设置的变量，shell直接返回空。这让我们在写程序时很容易携程难以查找的bug，因此shell提供了空参数处理的扩展。&lt;/p>
&lt;p>空参数处理的格式为：&lt;code>${变量名[:][-+=?]变量值}&lt;/code>。其中起不起用冒号有区别，后面&lt;code>[-+=?]&lt;/code>四选一。&lt;/p>
&lt;p>我们首先来解释有没有冒号&lt;code>:&lt;/code>的区别。当没有冒号的时候，即&lt;code>${变量名[-+=?]变量值}&lt;/code>时，shell只检测变量是否存在，相当于&lt;code>test -v 变量名&lt;/code>；而使用冒号的时候，即&lt;code>${变量名:[-+=?]变量值}&lt;/code>时，shell不仅检测变量时候存在，&lt;strong>而且检测变量是否为空&lt;/strong>，相当于&lt;code>test -v 变量名 &amp;amp;&amp;amp; test -z 变量名&lt;/code>。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>test -v&lt;/code>用于检测变量是否存在，变量存在返回结果0，不存在返回结果1；&lt;code>test -z&lt;/code>用于检测变量长度是否为0，如果为0返回0，否则返回1。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;code>${parameter:-word}&lt;/code>，如果变量parameter未设置或者值为空，那么给出word的值；否则给出&lt;code>$parameter&lt;/code>的值。&lt;/li>
&lt;li>&lt;code>${parameter:-word}&lt;/code>，如果变量parameter未设置或者值为空，那么给出word的值同时把word的值赋给&lt;code>$parameter&lt;/code>，否则给出&lt;code>$parameter&lt;/code>的值；注意无法给位置参数和特殊参数赋值；&lt;/li>
&lt;li>&lt;code>${parameter:?word}&lt;/code>，&lt;strong>用于交互式shell&lt;/strong>，如果变量parameter未设置或者值为空，那么将word内容作为标准错误返回给shell界面，否则给出&lt;code>$parameter&lt;/code>的值。&lt;/li>
&lt;li>&lt;code>${parameter:+word}&lt;/code>，&lt;code>${parameter:-word}&lt;/code>的相反操作。如果parameter为空或未设置，则不进行任何替换，否则给出word的值。&lt;/li>
&lt;/ul>
&lt;p>下面举几个简单的例子来帮助理解空参数处理。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ &lt;span class="nv">name&lt;/span>&lt;span class="o">=&lt;/span>linux
&lt;span class="ln"> 2&lt;/span>$ &lt;span class="nv">name1&lt;/span>&lt;span class="o">=&lt;/span>
&lt;span class="ln"> 3&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">name&lt;/span>&lt;span class="k">:-&lt;/span>&lt;span class="nv">windows&lt;/span>&lt;span class="si">}&lt;/span> --- &lt;span class="si">${&lt;/span>&lt;span class="nv">name1&lt;/span>&lt;span class="k">:-&lt;/span>&lt;span class="nv">windows&lt;/span>&lt;span class="si">}&lt;/span> --- &lt;span class="si">${&lt;/span>&lt;span class="nv">name&lt;/span>&lt;span class="p">-windows&lt;/span>&lt;span class="si">}&lt;/span> --- &lt;span class="si">${&lt;/span>&lt;span class="nv">name1&lt;/span>&lt;span class="p">-windows&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln"> 4&lt;/span>linux --- windows --- linux ---
&lt;span class="ln"> 5&lt;/span>&lt;span class="c1"># name 存在且不为空，因此${name:-windows}，${name-windows}给出$name的值，&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="c1"># name1存在但是为空，因此${name1:-windows}给出替代值windows，&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="c1"># 而${name1-windows}只检测到$name1存在，因此直接输出$name1，结果为空值&lt;/span>
&lt;span class="ln"> 8&lt;/span>$ &lt;span class="nb">echo&lt;/span> name1
&lt;span class="ln"> 9&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="c1"># 无论是${name1:-windows}还是${name1-windows}都不会给$name1赋值。&lt;/span>
&lt;span class="ln">11&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">name&lt;/span>&lt;span class="p">:=windows&lt;/span>&lt;span class="si">}&lt;/span> --- &lt;span class="si">${&lt;/span>&lt;span class="nv">name1&lt;/span>&lt;span class="p">:=windows&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">12&lt;/span>linux --- windows
&lt;span class="ln">13&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$name1&lt;/span>
&lt;span class="ln">14&lt;/span>windows
&lt;span class="ln">15&lt;/span>&lt;span class="c1"># 可以看出使用:=会给原变量赋值。&lt;/span>
&lt;span class="ln">16&lt;/span>$ &lt;span class="nv">name1&lt;/span>&lt;span class="o">=&lt;/span>
&lt;span class="ln">17&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">name&lt;/span>&lt;span class="p">=windows&lt;/span>&lt;span class="si">}&lt;/span> --- &lt;span class="si">${&lt;/span>&lt;span class="nv">name1&lt;/span>&lt;span class="p">=windows&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">18&lt;/span>linux ---
&lt;span class="ln">19&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$name1&lt;/span>
&lt;span class="ln">20&lt;/span>
&lt;span class="ln">21&lt;/span>&lt;span class="c1"># 这里是空值，因为$name1存在，因此${name1=windows}不进行赋值操作&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="子串扩展">子串扩展&lt;/h3>
&lt;p>shell的子串扩展是从shell变量中切割出一部分（字串）的快捷方法，功能和python的切片类似。格式为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">parameter&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">offset&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">parameter&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">offset&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">length&lt;/span>&lt;span class="si">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，&lt;code>offset&lt;/code>代表偏移值，为开始切割字符的序数，&lt;strong>从0开始算&lt;/strong>，&lt;code>length&lt;/code>为切割的长度，如果不指定，默认截取到最后。例子如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nv">string&lt;/span>&lt;span class="o">=&lt;/span>01234567890abcdefgh
&lt;span class="ln">2&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">string&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">7&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># 不指定length默认到末尾，第一位索引序数为0&lt;/span>
&lt;span class="ln">3&lt;/span>7890abcdefgh
&lt;span class="ln">4&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">string&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">7&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">0&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># length长度为0，截取长度也为0&lt;/span>
&lt;span class="ln">5&lt;/span>
&lt;span class="ln">6&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">string&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">7&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">2&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># length长度为2&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="m">78&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>如果&lt;code>offset&lt;/code>值为负数，那么子串是从最后开始计算起始点，-1表示最后一位，-2表示倒数第二位。&lt;/li>
&lt;li>如果&lt;code>length&lt;/code>值大于剩余的字符数，那么子串只截取到末尾。&lt;/li>
&lt;li>如果&lt;code>length&lt;/code>值为负数，那么&lt;code>length&lt;/code>表示的是原字符串截取到所在位序数，不包括&lt;code>length&lt;/code>所在的那一位。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>需要指出，冒号&lt;code>:&lt;/code>和负号&lt;code>-&lt;/code>之间至少要用一个空格隔开，否在会被当成是空参数处理&lt;code>:-&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;p>例子如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nv">string&lt;/span>&lt;span class="o">=&lt;/span>01234567890abcdefgh
&lt;span class="ln">2&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">string&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">7&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">100&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># 当length大于剩余字符串长度时，只截取到末尾&lt;/span>
&lt;span class="ln">3&lt;/span>7890abcdefgh
&lt;span class="ln">4&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">string&lt;/span>&lt;span class="p">: -7:&lt;/span>&lt;span class="nv">2&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># 注意中间有个空格&lt;/span>
&lt;span class="ln">5&lt;/span>bc
&lt;span class="ln">6&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">string&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">0&lt;/span>&lt;span class="p">: -5&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># -5(d)是原变量倒数第5个索引，但是不包括-5(d)&lt;/span>
&lt;span class="ln">7&lt;/span>01234567890abc
&lt;span class="ln">8&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">string&lt;/span>&lt;span class="p">: -2: -1&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># 这个例子更明显的表现出只包含开头，不包含结尾&lt;/span>
&lt;span class="ln">9&lt;/span>g
&lt;/code>&lt;/pre>&lt;/div>&lt;p>一般情况下，子串扩展都是从0开头，-1结尾，但是有一种例外，&lt;strong>位置参数是按1开始从头计算偏移值&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># 设置位置参数&lt;/span>
&lt;span class="ln">2&lt;/span>$ &lt;span class="nb">set&lt;/span> -- &lt;span class="m">0&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="m">5&lt;/span> &lt;span class="m">6&lt;/span> &lt;span class="m">7&lt;/span> &lt;span class="m">8&lt;/span> &lt;span class="m">9&lt;/span> &lt;span class="m">0&lt;/span> a b c d e f g h
&lt;span class="ln">3&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="p">@:&lt;/span>&lt;span class="nv">7&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># 位置参数开头从1开始计算&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="m">6&lt;/span> &lt;span class="m">7&lt;/span> &lt;span class="m">8&lt;/span> &lt;span class="m">9&lt;/span> &lt;span class="m">0&lt;/span> a b c d e f g h
&lt;span class="ln">5&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">string&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">7&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># 其他参数都是从0开始计算&lt;/span>
&lt;span class="ln">6&lt;/span>7890abcdefgh
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="参数长度计算">参数长度计算&lt;/h3>
&lt;p>bash shell在参数扩展中还提供了一种计算参数长度的便捷方式，即为&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="si">${#&lt;/span>&lt;span class="nv">parameter&lt;/span>&lt;span class="si">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于一般变量，&lt;code>${#parameter}&lt;/code>会计算字符串长度，对于位置参数，它会计算位置参数的个数，如果parameter是一个数组名，并且下标为*或者@，表达式扩展为数组的元素个数。例子如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nb">set&lt;/span> -- a b c d
&lt;span class="ln">2&lt;/span>$ &lt;span class="nv">var&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">123456789&lt;/span>
&lt;span class="ln">3&lt;/span>$ &lt;span class="nv">arr&lt;/span>&lt;span class="o">=(&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="m">2&lt;/span> 3&lt;span class="o">)&lt;/span>
&lt;span class="ln">4&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${#&lt;/span>&lt;span class="p">@&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="si">${#&lt;/span>&lt;span class="p">*&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="m">4&lt;/span> &lt;span class="m">4&lt;/span>
&lt;span class="ln">6&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${#&lt;/span>&lt;span class="nv">var&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="m">9&lt;/span>
&lt;span class="ln">8&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${#&lt;/span>&lt;span class="nv">arr&lt;/span>&lt;span class="p">[@]&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="si">${#&lt;/span>&lt;span class="nv">arr&lt;/span>&lt;span class="p">[*]&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">9&lt;/span>&lt;span class="m">3&lt;/span> &lt;span class="m">3&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="参数匹配删除">参数匹配删除&lt;/h3>
&lt;p>shell可以通过自带的模式匹配来识别特定的“关键字”，并对识别出来的内容进行操作，例如删除、替换等。这一小节，我们先说参数匹配删除，它可以实现一些很常见的操作，如获取文件名、文件后缀、文件路径、数字等。&lt;/p>
&lt;p>匹配删除共有四种模式，分别是从头最短检索、从头最长检索、从尾最短检索、从尾最长检索。从头、从尾比较容易理解，就是匹配的时候是从前往后找还是从后往前找。最长、最短通常是对&lt;code>*&lt;/code>通配符而言，如果遇到连续多个合适的匹配内容，最短匹配是匹配尽量少的字符、最长匹配是尽量多的匹配字符。按照这个分类方式，我们可以列出参数匹配删除的用法表格：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">&lt;/th>
&lt;th style="text-align:center">从头&lt;/th>
&lt;th style="text-align:center">从尾&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">最短&lt;/td>
&lt;td style="text-align:center">&lt;code>${parameter#word}&lt;/code>&lt;/td>
&lt;td style="text-align:center">&lt;code>${parameter%word}&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">最长&lt;/td>
&lt;td style="text-align:center">&lt;code>${parameter##word}&lt;/code>&lt;/td>
&lt;td style="text-align:center">&lt;code>${parameter%%word}&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>最短最长比较好记，使用一个符号&lt;code>#,%&lt;/code>比较短，是最短匹配；使用两个符号&lt;code>##,%%&lt;/code>比较长，是最长匹配。至于从头从尾，我的记忆方法是通常&lt;code>#&lt;/code>符号在bash shell中放在开头比较多（注释），因此是从头匹配。&lt;/p>
&lt;p>下面还是通过几个例子来方便理解参数匹配删除：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1"># 先设置一些位置参数&lt;/span>
&lt;span class="ln"> 2&lt;/span>$ &lt;span class="nb">set&lt;/span> -- ab-cd-ef&lt;span class="o">==&lt;/span> uv-wx-yz&lt;span class="o">==&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="c1"># 使用从头最短匹配，*-匹配到的是ab- ，然后将其删除&lt;/span>
&lt;span class="ln"> 4&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">1&lt;/span>&lt;span class="p">#*-&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln"> 5&lt;/span>cd-ef&lt;span class="o">==&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="c1"># 使用从头最长匹配，*-匹配到的是ab-cd- ，然后将其删除&lt;/span>
&lt;span class="ln"> 7&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">1&lt;/span>&lt;span class="p">##*-&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="nv">ef&lt;/span>&lt;span class="o">==&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="c1"># 使用从尾最短匹配，-*=匹配到的是-ef== ，然后删除&lt;/span>
&lt;span class="ln">10&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">1&lt;/span>&lt;span class="p">%-*=&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">11&lt;/span>ab-cd
&lt;span class="ln">12&lt;/span>&lt;span class="c1"># 使用从尾最长匹配，-*=匹配到的是-cd-ef== ，然后删除&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">1&lt;/span>&lt;span class="p">%%-*=&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">14&lt;/span>ab
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此外，和计算参数长度的扩展一样，如果是使用&lt;code>@,*&lt;/code>的&lt;strong>位置参数或数组&lt;/strong>，那么参数匹配删除将对其中的&lt;strong>每一个元素&lt;/strong>进行操作。类似于&lt;code>for ... in...&lt;/code>的效果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1"># 在以下几个例子中，表示位置参数或数组的#，@符合可以互换。&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="c1"># 对于使用@，*的位置参数，将会对其中每一个元素进行匹配删除操作&lt;/span>
&lt;span class="ln"> 3&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="p">@#*-&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln"> 4&lt;/span>cd-ef&lt;span class="o">==&lt;/span> wx-yz&lt;span class="o">==&lt;/span>
&lt;span class="ln"> 5&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="p">*%%-*=&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln"> 6&lt;/span>ab uv
&lt;span class="ln"> 7&lt;/span>$ &lt;span class="nv">arr&lt;/span>&lt;span class="o">=(&lt;/span>--a --b --c&lt;span class="o">)&lt;/span>
&lt;span class="ln"> 8&lt;/span>&lt;span class="c1"># 对数组中每一个元素进行从头最短匹配&lt;/span>
&lt;span class="ln"> 9&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">arr&lt;/span>&lt;span class="p">[*]#-?(-)&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># ?(-)需要启用“extglob” shell选项&lt;/span>
&lt;span class="ln">10&lt;/span>-a -b -c
&lt;span class="ln">11&lt;/span>&lt;span class="c1"># 对数组中每一个元素进行从头最长匹配&lt;/span>
&lt;span class="ln">12&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">arr&lt;/span>&lt;span class="p">[@]##-?(-)&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># ?(-)需要启用“extglob” shell选项&lt;/span>
&lt;span class="ln">13&lt;/span>a b c
&lt;span class="ln">14&lt;/span>$ &lt;span class="nv">arr&lt;/span>&lt;span class="o">=(&lt;/span>a-- b-- c--&lt;span class="o">)&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="c1"># 对数组中每一个元素进行从尾最短匹配&lt;/span>
&lt;span class="ln">16&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">arr&lt;/span>&lt;span class="p">[*]%-?(-)&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">17&lt;/span>a- b- c-
&lt;span class="ln">18&lt;/span>&lt;span class="c1"># 对数组中每一个元素进行从尾最长匹配&lt;/span>
&lt;span class="ln">19&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">arr&lt;/span>&lt;span class="p">[@]%%-?(-)&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">20&lt;/span>a b c
&lt;span class="ln">21&lt;/span>
&lt;span class="ln">22&lt;/span>&lt;span class="c1"># 几个实用的例子&lt;/span>
&lt;span class="ln">23&lt;/span>&lt;span class="c1"># 获取文件名，文件后缀&lt;/span>
&lt;span class="ln">24&lt;/span>$ &lt;span class="nv">FILENAME&lt;/span>&lt;span class="o">=&lt;/span>linux_bash.sh
&lt;span class="ln">25&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">FILENAME&lt;/span>&lt;span class="p">%.*&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">26&lt;/span>linux_bash
&lt;span class="ln">27&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">FILENAME&lt;/span>&lt;span class="p">##*.&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">28&lt;/span>sh
&lt;span class="ln">29&lt;/span>&lt;span class="c1"># 判断某字符串是否以某字符开头&lt;/span>
&lt;span class="ln">30&lt;/span>$ &lt;span class="nv">OPT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;-option&amp;#39;&lt;/span>
&lt;span class="ln">31&lt;/span>$ &lt;span class="k">if&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">OPT&lt;/span>&lt;span class="p">#-&lt;/span>&lt;span class="si">}&lt;/span> !&lt;span class="o">=&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">OPT&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">32&lt;/span>&amp;gt; &lt;span class="k">then&lt;/span>
&lt;span class="ln">33&lt;/span>&amp;gt; &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;start with -&amp;#34;&lt;/span>
&lt;span class="ln">34&lt;/span>&amp;gt; &lt;span class="k">else&lt;/span>
&lt;span class="ln">35&lt;/span>&amp;gt; &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;not start with -&amp;#34;&lt;/span>
&lt;span class="ln">36&lt;/span>&amp;gt; &lt;span class="k">fi&lt;/span>
&lt;span class="ln">37&lt;/span>start with -
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="参数匹配替换">参数匹配替换&lt;/h3>
&lt;p>前面介绍了参数的匹配删除，bash还提供了匹配替换的功能，也是通过自带的模式匹配来识别特定的“关键字”再进行替换。其格式为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">parameter&lt;/span>&lt;span class="p">/[/#%]pattern/string&lt;/span>&lt;span class="si">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，&lt;code>parameter&lt;/code>是待替换的原变量，&lt;code>pattern&lt;/code>是匹配的模式，即需要匹配的内容，&lt;code>string&lt;/code>是替换的内容。如果&lt;code>pattern&lt;/code>匹配到了符合的字符子串，那么就用&lt;code>string&lt;/code>替换匹配到的内容；如果&lt;code>pattern&lt;/code>未匹配到相关内容，则不做任何操作。需要指出的是，参数匹配替换都是用的是&lt;strong>最长匹配&lt;/strong>。参数匹配替换的详细用法有以下6点：&lt;/p>
&lt;ol>
&lt;li>默认情况下，即&lt;code>${parameter/pattern/string}&lt;/code>，是从头匹配&lt;strong>一个&lt;/strong>&lt;code>pattern&lt;/code>内容并替换。&lt;/li>
&lt;li>当&lt;code>pattern&lt;/code>以&lt;code>/&lt;/code>符号开头时，即&lt;code>${parameter//pattern/string}&lt;/code>，将会匹配&lt;strong>所有&lt;/strong>符合&lt;code>pattern&lt;/code>的内容。&lt;/li>
&lt;li>当&lt;code>pattern&lt;/code>以&lt;code>#&lt;/code>符号开头时，即&lt;code>${parameter/#pattern/string}&lt;/code>，将会匹配以&lt;code>pattern&lt;/code>开头的内容。&lt;/li>
&lt;li>当&lt;code>pattern&lt;/code>以&lt;code>%&lt;/code>符号开头时，即&lt;code>${parameter/%pattern/string}&lt;/code>，将会匹配以&lt;code>pattern&lt;/code>结尾的内容。&lt;/li>
&lt;li>如果启用了&lt;code>nocasematch&lt;/code> shell选项，则不考虑字母的大小写。&lt;/li>
&lt;li>和参数长度计算、参数匹配删除一样，如果是使用&lt;code>@,*&lt;/code>的&lt;strong>位置参数或数组&lt;/strong>，那么参数匹配删除将对其中的&lt;strong>每一个元素&lt;/strong>进行操作。类似于&lt;code>for ... in...&lt;/code>的效果。&lt;/li>
&lt;/ol>
&lt;p>我们以字符串&lt;code>string=abceddabceddabcedd&lt;/code>为例说明参数匹配替换的用法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ &lt;span class="nv">string&lt;/span>&lt;span class="o">=&lt;/span>abceddabceddabcedd
&lt;span class="ln"> 2&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">string&lt;/span>&lt;span class="p">/d?a/+&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># 匹配到abce &amp;#34;dda&amp;#34; bceddabcedd&lt;/span>
&lt;span class="ln"> 3&lt;/span>abce+bceddabcedd
&lt;span class="ln"> 4&lt;/span>&lt;span class="c1"># 匹配替换都是使用最长匹配&lt;/span>
&lt;span class="ln"> 5&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">string&lt;/span>&lt;span class="p">/d*a/+&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># 匹配到abce &amp;#34;ddabcedda&amp;#34; bcedd&lt;/span>
&lt;span class="ln"> 6&lt;/span>abce+bcedd
&lt;span class="ln"> 7&lt;/span>&lt;span class="c1"># 替换所有d?a&lt;/span>
&lt;span class="ln"> 8&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">string&lt;/span>&lt;span class="p">//d?a/f&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># 匹配到abce &amp;#34;dda&amp;#34; bce &amp;#34;dda&amp;#34; bcedd&lt;/span>
&lt;span class="ln"> 9&lt;/span>abce+bce+bcedd
&lt;span class="ln">10&lt;/span>&lt;span class="c1"># 替换以a开头的内容&lt;/span>
&lt;span class="ln">11&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">string&lt;/span>&lt;span class="p">/#a??/+&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># 匹配到 &amp;#34;abc&amp;#34; eddabceddabcedd&lt;/span>
&lt;span class="ln">12&lt;/span>+eddabceddabcedd
&lt;span class="ln">13&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">string&lt;/span>&lt;span class="p">/#b??/+&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># 没有b开头的内容，因此未匹配到任何内容&lt;/span>
&lt;span class="ln">14&lt;/span>abceddabceddabcedd
&lt;span class="ln">15&lt;/span>&lt;span class="c1"># 替换以b*d结尾的内容&lt;/span>
&lt;span class="ln">16&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">string&lt;/span>&lt;span class="p">/%b*d/+&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># 匹配到a &amp;#34;bceddabceddabcedd&amp;#34;&lt;/span>
&lt;span class="ln">17&lt;/span>a+
&lt;span class="ln">18&lt;/span>&lt;span class="c1"># 对于位置参数的处理&lt;/span>
&lt;span class="ln">19&lt;/span>$ &lt;span class="nb">set&lt;/span> -- abc abd abe
&lt;span class="ln">20&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="p">@/a/+&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">21&lt;/span>+bc +bd +be
&lt;span class="ln">22&lt;/span>&lt;span class="c1"># 对于数组的处理&lt;/span>
&lt;span class="ln">23&lt;/span>$ &lt;span class="nv">arr&lt;/span>&lt;span class="o">=(&lt;/span>abc abd abe&lt;span class="o">)&lt;/span>
&lt;span class="ln">24&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">arr&lt;/span>&lt;span class="p">[@]/a/+&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">25&lt;/span>+bc +bd +be
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="大小写修改">大小写修改&lt;/h3>
&lt;p>bash shell在匹配的基础上还提供了一个小功能，就是将匹配出来的内容进行大小写修改，实际上用的不多，可以作为了解。注：此操作仅适用于bash4.0往上版本。&lt;/p>
&lt;p>其基本格式为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># 小写转大写: ^会把开头的小写字母转换成大写，^^会转换所有小写成大写&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">parameter&lt;/span>&lt;span class="p">^pattern&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">parameter&lt;/span>&lt;span class="p">^^pattern&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">4&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="c1"># 大写转小写: ,会把开头的大写转换成小写，,,会把所以大写转换成小写&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">parameter&lt;/span>&lt;span class="p">,pattern&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">parameter&lt;/span>&lt;span class="p">,,pattern
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>举几个简单的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1"># 小写转大写&lt;/span>
&lt;span class="ln"> 2&lt;/span>$ &lt;span class="nv">par&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;abc&amp;#39;&lt;/span>
&lt;span class="ln"> 3&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">par&lt;/span>&lt;span class="p">^&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># 首字母&lt;/span>
&lt;span class="ln"> 4&lt;/span>Abc
&lt;span class="ln"> 5&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">par&lt;/span>&lt;span class="p">^^&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># 全部&lt;/span>
&lt;span class="ln"> 6&lt;/span>ABC
&lt;span class="ln"> 7&lt;/span>&lt;span class="c1"># 大写转小写&lt;/span>
&lt;span class="ln"> 8&lt;/span>$ &lt;span class="nv">par&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;ABC&amp;#39;&lt;/span>
&lt;span class="ln"> 9&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">par&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">10&lt;/span>aBC
&lt;span class="ln">11&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">par&lt;/span>&lt;span class="p">,,&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">12&lt;/span>abc
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此外，如果是使用&lt;code>@,*&lt;/code>的&lt;strong>位置参数或数组&lt;/strong>，那么大小写修改将对其中的&lt;strong>每一个元素&lt;/strong>进行操作。类似于&lt;code>for ... in...&lt;/code>的效果。&lt;/p>
&lt;h3 id="变量操作">变量操作&lt;/h3>
&lt;p>在bash4.0 版本以后，添加了一些方便使用的小功能，这些被统合为变量操作，格式为&lt;code>${parameter@operator}&lt;/code>，作用为根据操作符(operator)执行参数转换或者，操作符如下：&lt;/p>
&lt;ul>
&lt;li>Q：将字符串使用引号包裹。&lt;/li>
&lt;li>E：对于使用反斜线&lt;code>\&lt;/code>后的字符一律按转义处理。&lt;/li>
&lt;li>P：如果&lt;code>parameter&lt;/code>含有&lt;code>prompt string&lt;/code>时，按照prompt解释。&lt;/li>
&lt;li>A：拓展成参数赋值的语句。&lt;/li>
&lt;li>a：由参数属性值组成的字符串。&lt;/li>
&lt;/ul>
&lt;p>参数扩展做为bash中最多样，最灵活的扩展为shell提供了多样和简洁的处理方式，其本质上是多种小工具的聚合体，有的是为了弥补bash shell本身的弱点，有的是为了综合了使用率最高的小工具。同时这也是bash shell中非常容易出错的部分，需要我们谨慎地使用。&lt;/p>
&lt;h2 id="命令替换">命令替换&lt;/h2>
&lt;p>shell通过命令替换能够完成一些运行时的动态变化。命令替换，就是在执行bash shell是用&lt;strong>命令的输出替换命令本身&lt;/strong>。有两种格式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># 旧版使用反引号&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="nb">command&lt;/span>&lt;span class="sb">`&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="c1"># 新版使用$()&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="k">$(&lt;/span>&lt;span class="nb">command&lt;/span>&lt;span class="k">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Bash通过在子shell环境中执行命令替换的内容来进行扩展，并将命令替换为命令执行后的标准输出，并删除任何结尾的换行符。嵌入的换行符不会被删除，但在后面再次分词过程中可能会被删除。简单的例子如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="sb">`&lt;/span>whoami&lt;span class="sb">`&lt;/span>
&lt;span class="ln">2&lt;/span>lelouch
&lt;span class="ln">3&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="k">$(&lt;/span>whoami&lt;span class="k">)&lt;/span>
&lt;span class="ln">4&lt;/span>lelouch
&lt;span class="ln">5&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;hello,`whoami`&amp;#34;&lt;/span>
&lt;span class="ln">6&lt;/span>hello,lelouch
&lt;span class="ln">7&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;hello,&lt;/span>&lt;span class="k">$(&lt;/span>whoami&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">8&lt;/span>hello,lelouch
&lt;/code>&lt;/pre>&lt;/div>&lt;p>那为什么用新版的&lt;code>$()&lt;/code>替代旧版的反引号和呢？第一个原因就是反引号&amp;quot;`&amp;quot;太容易和单引号&amp;quot;'&amp;quot;搞混了，二者长得太像不利于排错。第二个原因就是反引号不容易复合，需要使用转义符号&lt;code>\&lt;/code>而使用&lt;code>$()&lt;/code>则直接嵌套就能使用。举个例子，我们要查看当前用户home目录中的一个&lt;code>test.sh&lt;/code>文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1"># 使用反引号命令替代，反引号需要转义&lt;/span>
&lt;span class="ln"> 2&lt;/span>$ cat &lt;span class="sb">`&lt;/span>ls /home/&lt;span class="se">\`&lt;/span>whoami&lt;span class="se">\`&lt;/span>/test.sh&lt;span class="sb">`&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="c1">#!/bin/bash&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="nb">read&lt;/span> filename
&lt;span class="ln"> 5&lt;/span>&lt;span class="nb">read&lt;/span> url
&lt;span class="ln"> 6&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nb">test&lt;/span> -w &lt;span class="nv">$filename&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">test&lt;/span> -n &lt;span class="nv">$url&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="k">then&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$url&lt;/span> &amp;gt; &lt;span class="nv">$filename&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;写入成功&amp;#34;&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="k">else&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;写入失败&amp;#34;&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="k">fi&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="c1"># 使用$()命令替代&lt;/span>
&lt;span class="ln">14&lt;/span>$ cat &lt;span class="k">$(&lt;/span>ls /home/&lt;span class="k">$(&lt;/span>whoami&lt;span class="k">)&lt;/span>/test.sh&lt;span class="k">)&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="c1">#!/bin/bash&lt;/span>
&lt;span class="ln">16&lt;/span>&lt;span class="nb">read&lt;/span> filename
&lt;span class="ln">17&lt;/span>&lt;span class="nb">read&lt;/span> url
&lt;span class="ln">18&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nb">test&lt;/span> -w &lt;span class="nv">$filename&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">test&lt;/span> -n &lt;span class="nv">$url&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="k">then&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$url&lt;/span> &amp;gt; &lt;span class="nv">$filename&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;写入成功&amp;#34;&lt;/span>
&lt;span class="ln">22&lt;/span>&lt;span class="k">else&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;写入失败&amp;#34;&lt;/span>
&lt;span class="ln">24&lt;/span>&lt;span class="k">fi&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>命令替代在shell自适应编程里非常重要。因为面向不同用户编程时，各个用户的环境变量，配置文件路径都有差异，bash shell可以通过命令替代了解当前用户的上下文，为shell脚本提供灵活处理不同环境的能力。&lt;/p>
&lt;h2 id="算术表达式扩展">算术表达式扩展&lt;/h2>
&lt;p>算术表达式扩展允许计算算术表达式和替换结果，广义上也属于一种命令替换。算术表达式扩展使用&lt;code>$&lt;/code>和两个小括号，格式是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">$((&lt;/span> expression &lt;span class="k">))&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>特别地，bash shell中的算术表达式扩展只支持固定长度的证书运算，任何浮点数运算都会被认为是一个错误而不做任何替换操作&lt;/strong>。此外，算术表达式扩展也是可以复合的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="k">$((&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="k">))&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="m">2&lt;/span>
&lt;span class="ln"> 3&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="k">$((&lt;/span>&lt;span class="m">10&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="m">4&lt;/span>&lt;span class="k">))&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="m">2&lt;/span>
&lt;span class="ln"> 5&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="k">$((&lt;/span>&lt;span class="m">6&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="m">5&lt;/span>&lt;span class="k">))&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="m">1&lt;/span>
&lt;span class="ln"> 7&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="k">$((&lt;/span>&lt;span class="m">6&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="m">15&lt;/span>&lt;span class="k">))&lt;/span>
&lt;span class="ln"> 8&lt;/span>-9
&lt;span class="ln"> 9&lt;/span>&lt;span class="c1"># 不支持浮点数运算&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="k">$((&lt;/span>&lt;span class="m">1&lt;/span>.1+3&lt;span class="k">))&lt;/span>
&lt;span class="ln">11&lt;/span>-bash: 1.1+3: syntax error: invalid arithmetic operator &lt;span class="o">(&lt;/span>error token is &lt;span class="s2">&amp;#34;.1+3&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="c1"># 复合的算法表达式&lt;/span>
&lt;span class="ln">13&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="k">$((&lt;/span>&lt;span class="m">10&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="k">$((&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="k">))&lt;/span> &lt;span class="k">))&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="m">16&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>bash shell的计算能力只是辅助作用，虽然除0错误被捕获并标记为错误，但是bash shell没有溢出检查，不支持浮点运算，也没有强大的数学公式库，因此并不推荐使用bash shell做复杂的数学运算。&lt;/p>
&lt;h2 id="再次单词分割">再次单词分割&lt;/h2>
&lt;p>在《shell骨干流程1——形成初步命令》一文中，我们了解到，shell命令处理流程的第一步就是使用元字符把输入内容分割为标记（token），以便bash shell进行保留字识别和流程控制。但是经过大括号展开、波浪符号展开、命令替换、算数运算扩展这些步骤，&lt;strong>会带来新的内容&lt;/strong>。因此，作为shell处理流程的第10步。我们需要将这些替换过后的内容重新整肃，根据系统分隔符（Internal Field Seperator，IFS）再次将命令分割成一个个便于处理的标记（token，包括控制符和单词）。也是说，如果没有前面几步的扩展，也就不需要再次进行分割。&lt;/p>
&lt;p>默认的IFS有&lt;code>space, tab, newline&lt;/code>以及他们的组合，例如连续的空格，&lt;code>tab&lt;/code>或者多个连续的空行。&lt;/p>
&lt;p>在这次处理中，显式的空参数（&amp;quot;&amp;quot; 或 ''）被保留并作为空字符串传递给命令，未加引号的隐式空参数将被删除。&lt;/p>
&lt;h2 id="路径与文件名展开">路径与文件名展开&lt;/h2>
&lt;p>如果bash中没有设置&lt;code>-f&lt;/code>选项，就会支持路径与文件名扩展，其扩展模式也是通过bash shell自带的模式匹配。比如，显示&lt;code>/etc&lt;/code>目录下的所有配置文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>ls /etc/*.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或是列出所有以字母&lt;code>a&lt;/code>或&lt;code>b&lt;/code>开头的配置文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>ls /etc/&lt;span class="o">[&lt;/span>ab&lt;span class="o">]&lt;/span>*.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者是显示所有的以&lt;code>image&lt;/code>开头的后面跟着一个字符格式为&lt;code>.jpg&lt;/code>的文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>ls image?.jpg
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在路径与文件名扩展中，字符&lt;code>.&lt;/code>在文件名开头或斜线后必须显式匹配，除非设置了shell选项&lt;code>dotglob&lt;/code>。匹配文件名时，斜杠字符必须始终显示匹配。更多文件匹配的例子可以看文章开头&lt;a href="#shell%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">shell的模式匹配&lt;/a>小节。&lt;/p>
&lt;p>shell命令展开作为四大步骤中最复杂的步骤，是我花时间精力最多的部分，其多样性和灵活性为shell脚本提供了强大的生命力。经过上述11步的操作，shell命令终于可以真正进入执行阶段了。&lt;/p>
&lt;h2 id="参考内容">参考内容&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://www.gnu.org/software/bash/manual/bash.html">https://www.gnu.org/software/bash/manual/bash.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/65599187">https://zhuanlan.zhihu.com/p/65599187&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Shell 骨干流程2——复合命令与控制流程</title><link>https://surprisedcat.github.io/projectnotes/shell-%E9%AA%A8%E5%B9%B2%E6%B5%81%E7%A8%8B2%E5%A4%8D%E5%90%88%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/shell-%E9%AA%A8%E5%B9%B2%E6%B5%81%E7%A8%8B2%E5%A4%8D%E5%90%88%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/</guid><description>
&lt;ul>
&lt;li>&lt;a href="#shell%E5%A4%8D%E5%90%88%E5%91%BD%E4%BB%A4%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">shell复合命令——流程控制&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">循环结构&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84">条件结构&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7%E4%B8%8E%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7">条件运算符号与算术运算符号&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%BB%84%E5%91%BD%E4%BB%A4">组命令&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8D%8F%E5%90%8C%E8%BF%9B%E7%A8%8B">协同进程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#shell%E5%87%BD%E6%95%B0">shell函数&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89">函数的定义&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8">函数的使用&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#shell%E5%8F%82%E6%95%B0">shell参数&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0">位置参数&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0">特殊参数&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%E5%8F%82%E8%80%83%E5%86%85%E5%AE%B9">参考内容&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="复合命令与控制流程---omit-in-toc---">复合命令与控制流程&lt;!-- omit in toc -->&lt;/h2>
&lt;p>复合命令是通过shell保留字和简单命令组合形成的组合命令，算是shell脚本语言的基本结构。&lt;strong>每一个复合命令结构都由每一个保留字或控制符开始，并以对应的保留字或控制符结束&lt;/strong>，这算是shell编程语言的一个特色，例如以&lt;code>if&lt;/code>开头，&lt;code>fi&lt;/code>结尾；&lt;code>case&lt;/code>开头，&lt;code>esac&lt;/code>结尾等等。对shell复合命令结构的输入、输出重定向将被应用到该结构的每一个简单命令中，除非其中有某个简单命令用显式的重定向覆盖该结构的重定向。写shell语言时，为了保证代码可读性，在复合命令结构之间通常用&lt;code>newline&lt;/code>来分割，而不是用&lt;code>;&lt;/code>来分割，虽然从语法上来讲，二者作用是一样的，但是过长的代码会给后续的维护造成困难。&lt;/p>
&lt;p>The Bourne Again SHell（bash）提供循环、条件、组命令、协同四种复合命令，并用相应的保留字指示bash是哪一种复合命令。bash的保留字如以下表格所示：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">&lt;/th>
&lt;th style="text-align:center">&lt;/th>
&lt;th style="text-align:center">&lt;/th>
&lt;th style="text-align:center">&lt;/th>
&lt;th style="text-align:center">&lt;/th>
&lt;th style="text-align:center">&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">if&lt;/td>
&lt;td style="text-align:center">then&lt;/td>
&lt;td style="text-align:center">elif&lt;/td>
&lt;td style="text-align:center">else&lt;/td>
&lt;td style="text-align:center">fi&lt;/td>
&lt;td style="text-align:center">time&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">for&lt;/td>
&lt;td style="text-align:center">in&lt;/td>
&lt;td style="text-align:center">until&lt;/td>
&lt;td style="text-align:center">while&lt;/td>
&lt;td style="text-align:center">do&lt;/td>
&lt;td style="text-align:center">done&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">case&lt;/td>
&lt;td style="text-align:center">esac&lt;/td>
&lt;td style="text-align:center">coproc&lt;/td>
&lt;td style="text-align:center">select&lt;/td>
&lt;td style="text-align:center">function&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">{&lt;/td>
&lt;td style="text-align:center">}&lt;/td>
&lt;td style="text-align:center">[[&lt;/td>
&lt;td style="text-align:center">]]&lt;/td>
&lt;td style="text-align:center">!&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>需要注意的是，在其他编程语言中，&lt;code>continue, break&lt;/code>算是关键字，而在shell中&lt;code>continue, break&lt;/code>是内置命令。&lt;/p>
&lt;p>我们将循环、条件、组命令、协同作为四种控制流程。此外，还有一种特殊的复合命令叫做&lt;strong>函数&lt;/strong>，基本上有点编程基础的人对此都不陌生，shell的函数定义、使用方式和其他编程语言大同小异。&lt;/p>
&lt;p>总体处理流程上，shell会先检查第一个标记，如果是可前置保留字(&lt;code>if, for, while, until, case, select, time, function, coproc, {, [[, !&lt;/code>)，则开启复合命令流程；如果是非可前置保留字(&lt;code>then, elif, fi, in, do, done, esac, }, ]]&lt;/code>)，且之前没有与之对应的可前置保留字，则报语法错误；如果不是保留字则当作简单命令，执行下一步骤。&lt;/p>
&lt;h2 id="shell复合命令流程控制">shell复合命令——流程控制&lt;/h2>
&lt;p>基本上所有的变成语言流程控制都包含顺序执行、条件执行、循环执行三种流程控制，shell语言也不例外。此外，shell还有分组命令、协同处理两种特殊的流程控制方法。&lt;/p>
&lt;h3 id="循环结构">循环结构&lt;/h3>
&lt;p>until循环: 循环执行一系列命令直至条件&lt;code>test-commands&lt;/code>为&lt;code>true&lt;/code>时停止。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># 单行&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="k">until&lt;/span> test-commands&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span> consequent-commands&lt;span class="p">;&lt;/span> &lt;span class="k">done&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="c1">#多行&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="k">until&lt;/span> test-commands
&lt;span class="ln">5&lt;/span>&lt;span class="k">do&lt;/span>
&lt;span class="ln">6&lt;/span> consequent-commands
&lt;span class="ln">7&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>例子：输出 0 ~ 9 的数字&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nv">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span>
&lt;span class="ln">4&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="k">until&lt;/span> &lt;span class="o">[&lt;/span> ! &lt;span class="nv">$a&lt;/span> -lt &lt;span class="m">10&lt;/span> &lt;span class="o">]&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="k">do&lt;/span>
&lt;span class="ln">7&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$a&lt;/span>
&lt;span class="ln">8&lt;/span> &lt;span class="nv">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="sb">`&lt;/span>expr &lt;span class="nv">$a&lt;/span> + 1&lt;span class="sb">`&lt;/span>
&lt;span class="ln">9&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>while循环：和until循环相反，循环执行一系列命令直至条件&lt;code>test-commands&lt;/code>为&lt;code>false&lt;/code>时停止。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># 单行&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="k">while&lt;/span> test-commands&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span> consequent-commands&lt;span class="p">;&lt;/span> &lt;span class="k">done&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="c1"># 多行&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="k">while&lt;/span> test-commands
&lt;span class="ln">5&lt;/span>&lt;span class="k">do&lt;/span>
&lt;span class="ln">6&lt;/span> consequent-commands
&lt;span class="ln">7&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>例子：输出 0 ~ 9 的数字&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nv">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span>
&lt;span class="ln">4&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="nv">$a&lt;/span> -lt &lt;span class="m">10&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="c1"># 和until相比少了一个取反的&amp;#34;!&amp;#34;&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="k">do&lt;/span>
&lt;span class="ln">7&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$a&lt;/span>
&lt;span class="ln">8&lt;/span> &lt;span class="nv">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="sb">`&lt;/span>expr &lt;span class="nv">$a&lt;/span> + 1&lt;span class="sb">`&lt;/span>
&lt;span class="ln">9&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>for循环：有两种模式，一种是C风格的条件模式，条件需要用shell算数表达式表示，还有一种python风格的遍历模式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1"># 单行C风格&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="k">for&lt;/span> &lt;span class="o">((&lt;/span> expr1 &lt;span class="p">;&lt;/span> expr2 &lt;span class="p">;&lt;/span> expr3 &lt;span class="o">))&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span> commands &lt;span class="p">;&lt;/span> &lt;span class="k">done&lt;/span>
&lt;span class="ln"> 3&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="c1"># 多行C风格&lt;/span>
&lt;span class="ln"> 5&lt;/span>&lt;span class="k">for&lt;/span> &lt;span class="o">((&lt;/span> expr1 &lt;span class="p">;&lt;/span> expr2 &lt;span class="p">;&lt;/span> expr3 &lt;span class="o">))&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="k">do&lt;/span>
&lt;span class="ln"> 7&lt;/span> commands
&lt;span class="ln"> 8&lt;/span>&lt;span class="k">done&lt;/span>
&lt;span class="ln"> 9&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="c1"># 单行 遍历风格&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="k">for&lt;/span> name in &lt;span class="o">[&lt;/span>words …&lt;span class="o">]&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span> commands&lt;span class="p">;&lt;/span> &lt;span class="k">done&lt;/span>
&lt;span class="ln">12&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="c1"># 多行 遍历风格&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="k">for&lt;/span> name in &lt;span class="o">[&lt;/span>words …&lt;span class="o">]&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="k">do&lt;/span>
&lt;span class="ln">16&lt;/span> commands
&lt;span class="ln">17&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>跳出循环：在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两内置命令来实现该功能：&lt;code>break&lt;/code>和&lt;code>continue&lt;/code>。&lt;code>break&lt;/code>命令允许跳出所有循环（终止执行后面的所有循环）。&lt;code>continue&lt;/code>命令与&lt;code>break&lt;/code>命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环，有时甚至是加速循环。&lt;/p>
&lt;h3 id="条件结构">条件结构&lt;/h3>
&lt;p>首先介绍两个各大语言常见的条件结构if和case。其中的分号都可以用&lt;code>newline&lt;/code>替换，反之亦然。&amp;quot;[]&amp;quot;中的内容表示不是一定需要。&lt;/p>
&lt;p>if条件结构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">if&lt;/span> test-commands&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
&lt;span class="ln">2&lt;/span> consequent-commands&lt;span class="p">;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="k">elif&lt;/span> more-test-commands&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
&lt;span class="ln">4&lt;/span> more-consequents&lt;span class="p">;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="k">else&lt;/span> alternate-consequents&lt;span class="p">;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="k">fi&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码实例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="nv">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">10&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="nv">b&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">20&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="nv">$a&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nv">$b&lt;/span> &lt;span class="o">]&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="k">then&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;a 等于 b&amp;#34;&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="k">elif&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="nv">$a&lt;/span> -gt &lt;span class="nv">$b&lt;/span> &lt;span class="o">]&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="k">then&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;a 大于 b&amp;#34;&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="k">elif&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="nv">$a&lt;/span> -lt &lt;span class="nv">$b&lt;/span> &lt;span class="o">]&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="k">then&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;a 小于 b&amp;#34;&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="k">else&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;没有符合的条件&amp;#34;&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="k">fi&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>case条件结构：&lt;code>case ... esac&lt;/code>为多选择语句，与其他语言中的&lt;code>switch ... case&lt;/code>语句类似，是一种多分支选择结构，每个&lt;code>case&lt;/code>分支用&lt;strong>右圆括号&lt;/strong>开始，用&lt;strong>两个分号;;表示&lt;/strong> break，即执行结束，跳出整个&lt;code>case ... esac&lt;/code>语句，&lt;code>esac&lt;/code>（就是&lt;code>case&lt;/code>反过来）作为结束标记。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">case&lt;/span> &lt;span class="nv">$var&lt;/span> in
&lt;span class="ln">2&lt;/span> pattern1 &lt;span class="p">|&lt;/span> pattern2&lt;span class="o">)&lt;/span>
&lt;span class="ln">3&lt;/span> statements &lt;span class="p">;;&lt;/span>
&lt;span class="ln">4&lt;/span> pattern3 &lt;span class="p">|&lt;/span> pattern4&lt;span class="o">)&lt;/span>
&lt;span class="ln">5&lt;/span> statements &lt;span class="p">;;&lt;/span>
&lt;span class="ln">6&lt;/span> ...
&lt;span class="ln">7&lt;/span> *&lt;span class="o">)&lt;/span>
&lt;span class="ln">8&lt;/span> statements &lt;span class="p">;;&lt;/span>
&lt;span class="ln">9&lt;/span>&lt;span class="k">esac&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>case&lt;/code>工作方式如上所示，&lt;code>case&lt;/code>后面跟需要判断的变量&lt;code>$var&lt;/code>，再后面必须为单词&lt;code>in&lt;/code>。该复合语句根据模式匹配&lt;code>case&lt;/code>后面的&lt;code>$var&lt;/code>，模式类似于正则表达式，多个模式之间用“|”分割，最后必须以右括号结束。&lt;code>$var&lt;/code>可以为变量或常数，匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。&lt;/p>
&lt;p>&lt;code>$var&lt;/code>将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后&lt;strong>不再继续其他模式&lt;/strong>。如果无一匹配模式，&lt;strong>使用星号&lt;code>*&lt;/code>捕获该值&lt;/strong>，再执行后面的命令。&lt;/p>
&lt;p>举一个简单的例子&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;输入 1 到 6 之间的数字:&amp;#39;&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;你输入的数字为:&amp;#39;&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="nb">read&lt;/span> aNum
&lt;span class="ln"> 4&lt;/span>&lt;span class="k">case&lt;/span> &lt;span class="nv">$aNum&lt;/span> in
&lt;span class="ln"> 5&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="p">|&lt;/span> 2&lt;span class="o">)&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;你选择了 1或2&amp;#39;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="p">;;&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="p">|&lt;/span> 4&lt;span class="o">)&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;你选择了 3或4&amp;#39;&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="p">;;&lt;/span>
&lt;span class="ln"> 9&lt;/span> 5&lt;span class="o">)&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;你选择了 5&amp;#39;&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="p">;;&lt;/span>
&lt;span class="ln">11&lt;/span> 6&lt;span class="o">)&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;你选择了 6&amp;#39;&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="p">;;&lt;/span>
&lt;span class="ln">13&lt;/span> *&lt;span class="o">)&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;你没有输入 1 到 6 之间的数字&amp;#39;&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="p">;;&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="k">esac&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外，一些版本的shell还提供了&lt;code>select&lt;/code>结构，&lt;code>select in&lt;/code>结构用来增强交互性，它可以显示出带编号的菜单，用户输入不同的编号就可以选择不同的菜单，并执行不同的功能。但是个人觉得在实践中，这种结果使用较少，用起来也比较鸡肋，所以不做介绍了，有兴趣同读者可以自行搜索。&lt;/p>
&lt;h3 id="条件运算符号与算术运算符号">条件运算符号与算术运算符号&lt;/h3>
&lt;p>我们在之前的循环与条件结构中，都会遇到条件判断语句，例如在&lt;code>if&lt;/code>后面的内容、&lt;code>while, until&lt;/code>后面的内容以及&lt;code>for&lt;/code>在C风格下的&lt;code>((...))&lt;/code>表达式。条件结构会&lt;strong>根据判断语句的返回码&lt;/strong>决定执行哪些后续内容，有趣的是，由于在shell中，返回码&lt;code>0&lt;/code>表示进程正常执行完毕，其他返回码表示进程执行遇到错误。在shell中执行&lt;code>true&lt;/code>的返回码为0，执行&lt;code>false&lt;/code>的返回码为1；算数表达式计算结果不为0时，返回码为0，计算结果等于0时，返回码为1。还是要记住，条件结构看的是返回码，不是执行的输出。&lt;/p>
&lt;p>判断语句一般有三种，一是单中括号&lt;code>[]&lt;/code>，二是双中括号&lt;code>[[]]&lt;/code>，三是双小括号&lt;code>(())&lt;/code>。&lt;/p>
&lt;p>单中括号&lt;code>[ ]&lt;/code>是bash特有的&lt;strong>内置命令&lt;/strong>，等同于&lt;code>test&lt;/code>命令。关于test命令的具体用法，可参考《shell-test命令使用》。&lt;/p>
&lt;p>双中括号&lt;code>[[ ]]&lt;/code>是bash程序语言的&lt;strong>关键字&lt;/strong>，并不是一个命令，双中括号中的&lt;strong>表达式被看作一个单独的元素&lt;/strong>，计算此元素结果并返回一个退出状态码。由于&lt;code>[[ ]]&lt;/code>是关键字，因此，它们&lt;strong>和表达式之间都需要空格分割&lt;/strong>，&lt;code>[[ ]]&lt;/code>结构比&lt;code>[ ]&lt;/code>结构更加通用。在&lt;code>[[&lt;/code>和&lt;code>]]&lt;/code>之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。使用&lt;code>[[ ]]&lt;/code>条件判断结构，而不是&lt;code>[ ]&lt;/code>，能够防止脚本中的许多逻辑错误。比如，&lt;code>&amp;amp;&amp;amp;、||、&amp;lt;&lt;/code>和&lt;code>&amp;gt;&lt;/code>操作符能够正常存在于&lt;code>[[ ]]&lt;/code>条件判断结构中，但是如果出现在&lt;code>[ ]&lt;/code>结构中的话，会报错。比如可以直接使用&lt;code>if [[ $a != 1 &amp;amp;&amp;amp; $a != 2 ]]&lt;/code>, 如果不适用双括号, 则为&lt;code>if [ $a -ne 1] &amp;amp;&amp;amp; [ $a != 2 ]&lt;/code>或者&lt;code>if [ $a -ne 1 -a $a != 2 ]&lt;/code>。此外，&lt;code>[[ ]]&lt;/code>支持字符串的模式匹配，使用&lt;code>==, !=&lt;/code>操作符时甚至支持shell的模式匹配，此时会把&lt;strong>运算符右边的表达式作为一个匹配模式&lt;/strong>，而不仅仅是一个字符串，比如&lt;code>[[ hello == hell? ]]&lt;/code>，&lt;code>[[ hello == h* ]]&lt;/code>结果都为真。&lt;code>[[ ]]&lt;/code>中匹配字符串或通配符，不需要引号。&lt;/p>
&lt;blockquote>
&lt;p>关于双中括号&lt;code>[[ ]]&lt;/code>中的匹配，如果我们使用&lt;code>=~&lt;/code>操作符，支持字符串的shell模式匹配可升级为POSIX的正则匹配，提供更加丰富的匹配功能。&lt;/p>
&lt;/blockquote>
&lt;p>双小括号&lt;code>(( ))&lt;/code>是&lt;strong>整数扩展&lt;/strong>。这种扩展计算是&lt;strong>整数型的计算，不支持浮点型&lt;/strong>。&lt;code>(( ))&lt;/code>结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是&amp;quot;false&amp;quot;，而一个非零值的表达式所返回的退出状态码将为0，或者是&amp;quot;true&amp;quot;。单纯用&lt;code>(( ))&lt;/code> 也可重定义变量值，比如&lt;code>a=5; ((a++))&lt;/code>可将&lt;code>$a&lt;/code>重定义为6。注意由于&lt;code>(( ))&lt;/code>是C风格的，因此双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开，只要括号中的表达式符合C语言运算规则,比如可以直接使用&lt;code>for((i=0;i&amp;lt;5;i++))&lt;/code>。&lt;/p>
&lt;h3 id="组命令">组命令&lt;/h3>
&lt;p>shell提供了两种方式来将一组命令（无论是简单命令还是复合命令）做一个单元来执行，一是单个小括号&lt;code>( command list )&lt;/code>，二是单个大括号&lt;code>{ command list; }&lt;/code>。当组命令存在时，可以改变原有的执行流程，组内的命令看作一个小单元一起执行，就像在数学中使用括号改变运算优先级一样；同时，对组命令的重定向将会生效于组内每一条命令。&lt;/p>
&lt;p>举一个组命令改变原有的执行流程的例子，。示例：&lt;code>echo $a&lt;/code>被执行几次？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># 先执行a=1;echo $a，再执行a=1 || echo $a，由于a=1成功执行，||右面的echo $a不会执行了&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="c1"># 最后再执行最后一个echo $a；共输出两次&lt;/span>
&lt;span class="ln">3&lt;/span>$ &lt;span class="nv">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="p">;&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="nv">$a&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="nv">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$a&lt;/span> &lt;span class="p">;&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="nv">$a&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="m">1&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="m">1&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="c1"># 先执行a=1;echo $a，后面a=1 || (echo $a ;echo $a)做为同优先级的组合命令执行，由于a=1成功执行&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="c1"># ||右面的(echo $a ;echo $a)组命令作为一个整体都不会执行，共输出一次&lt;/span>
&lt;span class="ln">8&lt;/span>$ &lt;span class="nv">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="p">;&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="nv">$a&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="nv">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="nv">$a&lt;/span> &lt;span class="p">;&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="nv">$a&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="ln">9&lt;/span>&lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么，使用单个小括号&lt;code>( command list )&lt;/code>和单个大括号&lt;code>{ command list; }&lt;/code>到底有什么区别呢？&lt;/p>
&lt;ol>
&lt;li>语法层面。&lt;code>()&lt;/code>是&lt;strong>shell的操作符&lt;/strong>，因此会被shell解释器自动分割，且不用在小括号左右加空格；而&lt;code>{}&lt;/code>是&lt;strong>shell的保留字&lt;/strong>，因此需要在左大括号后面添加空格（开头不需要，后面那个右大括号也不需要），同时&lt;code>{ }&lt;/code>最后一个命令要加&lt;strong>分号分割&lt;/strong>。&lt;/li>
&lt;li>执行层面。当shell执行&lt;code>( )&lt;/code>中的命令时将再创建一个新的子shell，然后这个子shell去执行圆括弧中的命令。&lt;code>( )&lt;/code>所有的改变只对子shell产生影响，而原shell不受任何干扰，比如在&lt;code>( )&lt;/code>内部定义、改变的变量，外面是不受影响的；&lt;code>{ }&lt;/code>是在当前shell中执行，不会衍生子shell，&lt;code>{ }&lt;/code>中操作都是对当前shell有影响的。&lt;/li>
&lt;/ol>
&lt;p>我们据下面这个例子来说明&lt;code>( )&lt;/code>与&lt;code>{ }&lt;/code>的区别。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1"># {} 内部定义变量。原进程可用&lt;/span>
&lt;span class="ln"> 2&lt;/span>$ &lt;span class="o">{&lt;/span> &lt;span class="nv">b&lt;/span>&lt;span class="o">=&lt;/span>1&lt;span class="p">;&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$b&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="m">1&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="c1"># 没有空格、分号的话会将{b=2}整体当作一个命令&lt;/span>
&lt;span class="ln"> 5&lt;/span>$ &lt;span class="o">{&lt;/span>&lt;span class="nv">b&lt;/span>&lt;span class="o">=&lt;/span>2&lt;span class="o">}&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$b&lt;/span>
&lt;span class="ln"> 6&lt;/span>-bash: &lt;span class="o">{&lt;/span>&lt;span class="nv">b&lt;/span>&lt;span class="o">=&lt;/span>2&lt;span class="o">}&lt;/span>: &lt;span class="nb">command&lt;/span> not found
&lt;span class="ln"> 7&lt;/span>&lt;span class="c1"># 有分号无空格会报语法错误&lt;/span>
&lt;span class="ln"> 8&lt;/span>$ &lt;span class="o">{&lt;/span>&lt;span class="nv">b&lt;/span>&lt;span class="o">=&lt;/span>2&lt;span class="p">;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$b&lt;/span>
&lt;span class="ln"> 9&lt;/span>-bash: syntax error near unexpected token &lt;span class="sb">`&lt;/span>&lt;span class="o">}&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="c1"># ()中的命令会在子shell执行，不影响原本的shell&lt;/span>
&lt;span class="ln">11&lt;/span>$ &lt;span class="o">(&lt;/span>&lt;span class="nv">b&lt;/span>&lt;span class="o">=&lt;/span>2&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$b&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="协同进程">协同进程&lt;/h3>
&lt;p>自bash4.0开始，bash引入了一个保留字&lt;code>coproc&lt;/code>, 用来在后台创建一个&lt;strong>异步执行的子协作进程&lt;/strong>(co-process)。使用&lt;code>coproc&lt;/code>的效果就像在命令结尾加上&lt;code>&amp;amp;&lt;/code>符号一样，但是&lt;code>coproc&lt;/code>还会创建一个&lt;strong>双向管道&lt;/strong>，将协作进程的输入和输出通过管道与文件句柄相连，与原进程进行通信。如果我们希望原进程和子进程交互执行，可以考虑使用&lt;code>coproc&lt;/code>。其语法如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>coproc &lt;span class="o">[&lt;/span>NAME&lt;span class="o">]&lt;/span> &lt;span class="nb">command&lt;/span> &lt;span class="o">[&lt;/span>redirections&lt;span class="o">]&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="c1"># 有没有觉得它跟bash中定义函数的语法 function NAME {cmds} 很类似？&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建的协作子进程被命名为给出的参数&lt;code>NAME&lt;/code>，如果没有给参数&lt;code>NAME&lt;/code>则默认为“COPROC”。但是只有当&lt;code>command&lt;/code>不是简单命令时，才可以给它命名，如果是简单命令，则一定不可以添加&lt;code>NAME&lt;/code>参数，否则&lt;code>NAME&lt;/code>会被当成简单命令的首单词。&lt;/p>
&lt;p>当&lt;code>coproc&lt;/code>命令执行时，shell在当前进程中创建一个名为&lt;code>NAME&lt;/code>的数组变量，命令的&lt;strong>标准输出&lt;/strong>同当前进程的文件描述符&lt;code>NAME[0]&lt;/code>相连，&lt;strong>标准输入&lt;/strong>同&lt;code>NAME[1]&lt;/code>相连（和标准输入输出的默认文件描述符相反）。协作进程的进程号保存在变量&lt;code>NAME_PID&lt;/code>中，我们可以在当前进程使用shell内建命令&lt;code>wait&lt;/code>等待协作进程的结束。&lt;/p>
&lt;p>&lt;code>coproc&lt;/code>的用法和GO语言中的协程有点类似，感觉在shell实际应用中并不太常见。大多数时候，有类似功效的&lt;code>expect&lt;/code>命令更受欢迎。&lt;/p>
&lt;h2 id="shell函数">shell函数&lt;/h2>
&lt;p>shell中函数是另一种复合命令的方式，shell中的函数定义和使用与其他变成语言中函数大同小异。然而，shell的函数设计有一个特点：&lt;strong>函数用起来尽量像个正常的命令&lt;/strong>。这个特点既有有点也有缺点，优点在于函数和命令使用的一致性，可以简化编程语法，二者互相替换会很方便；但是这也让我们无法直接分清哪些是命令哪些是函数，容易产生二义性。&lt;/p>
&lt;h3 id="函数的定义">函数的定义&lt;/h3>
&lt;p>shell函数的定义遵循以下两种方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># 方法一&lt;/span>
&lt;span class="ln">2&lt;/span>fname &lt;span class="o">()&lt;/span> compound-command &lt;span class="o">[&lt;/span> redirections &lt;span class="o">]&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="c1"># 方法二&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="k">function&lt;/span> fname &lt;span class="o">[()]&lt;/span> compound-command &lt;span class="o">[&lt;/span> redirections &lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，&lt;code>function&lt;/code>是shell关于函数的&lt;strong>保留字&lt;/strong>，&lt;code>fname&lt;/code>是给出的&lt;strong>函数名称&lt;/strong>，后面跟的单小括号&lt;code>( )&lt;/code>也表明定义的是个函数，其中里面什么都不要添加。后面跟的是&lt;strong>函数体&lt;/strong>，注意函数体一定要是&lt;strong>复合命令&lt;/strong>。由于保留字&lt;code>function&lt;/code>和单小括号&lt;code>( )&lt;/code>都表明了是定义函数，因此二者至少有一个存在即可。比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>funcName &lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span> command&lt;span class="p">;&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="c1"># 只存在单小括号( )&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="k">function&lt;/span> funcName &lt;span class="o">{&lt;/span> command&lt;span class="p">;&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="c1"># 只存在保留字function&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">function&lt;/span> funcName &lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span> command&lt;span class="p">;&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="c1"># 单小括号( )、保留字function同时存在&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后的&lt;code>[ redirections ]&lt;/code>表示整个函数的重定向。如果，我们想删除定义的函数，可以用&lt;code>unset -f&lt;/code>内置命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># 删除名为funcName的函数&lt;/span>
&lt;span class="ln">2&lt;/span>$ &lt;span class="nb">unset&lt;/span> -f funcName
&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么使用&lt;code>function&lt;/code>保留字和不使用该保留字有什么区别呢？使用&lt;code>function&lt;/code>保留字后，后面的单词&lt;code>funcName&lt;/code>一定会被shell当成函数名，&lt;strong>即使使用已经存在的命令作为名称也可以&lt;/strong>，举个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="k">function&lt;/span> ls &lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span> whoami&lt;span class="p">;&lt;/span> pwd&lt;span class="p">;&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">2&lt;/span>$ ls
&lt;span class="ln">3&lt;/span>lelouch &lt;span class="c1"># 这是我自己用户的名称&lt;/span>
&lt;span class="ln">4&lt;/span>/home/lelouch
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个例子中，我作死把原来的&lt;code>ls&lt;/code>命令名称，定义成了一个新的函数，这个函数会执行&lt;code>whoami; pwd;&lt;/code>两个命令，所以执行结果并不是&lt;code>ls&lt;/code>原本的结果，而是显示当前用户和路径。如果我在作死一点，定义一个另一个函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># 注意这里的ls已经不是过去显示文件的命令，而是之前定义的函数&lt;/span>
&lt;span class="ln">2&lt;/span>$ &lt;span class="k">function&lt;/span> &lt;span class="nb">pwd&lt;/span> &lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span> whoami&lt;span class="p">;&lt;/span> ls&lt;span class="p">;&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我在函数体中，又添加了&lt;code>ls&lt;/code>，你猜猜现在执行&lt;code>pwd&lt;/code>结果会怎么样~~&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ &lt;span class="nb">pwd&lt;/span>
&lt;span class="ln"> 2&lt;/span>lelouch
&lt;span class="ln"> 3&lt;/span>lelouch
&lt;span class="ln"> 4&lt;/span>lelouch
&lt;span class="ln"> 5&lt;/span>lelouch
&lt;span class="ln"> 6&lt;/span>lelouch
&lt;span class="ln"> 7&lt;/span>lelouch
&lt;span class="ln"> 8&lt;/span>lelouch
&lt;span class="ln"> 9&lt;/span>lelouch
&lt;span class="ln">10&lt;/span>lelouch
&lt;span class="ln">11&lt;/span>lelouch
&lt;span class="ln">12&lt;/span>lelouch
&lt;span class="ln">13&lt;/span>lelouch
&lt;span class="ln">14&lt;/span>lelouch
&lt;span class="ln">15&lt;/span>lelouch
&lt;span class="ln">16&lt;/span>lelouch
&lt;span class="ln">17&lt;/span>....
&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果会无限地执行&lt;code>whoami&lt;/code>。因为&lt;code>pwd&lt;/code>函数会调用函数&lt;code>ls&lt;/code>（不是&lt;code>ls&lt;/code>命令），函数&lt;code>ls&lt;/code>又会调用函数&lt;code>pwd&lt;/code>，……，产生循环调用，命令体中的&lt;code>whoami&lt;/code>会被反复执行。这也说明了shell语言并不是一个很严谨的语言，很容易产生能让系统崩溃的错误。&lt;code>function&lt;/code>保留字就是能让后面的单词强制变成函数名，覆盖原来的含义。&lt;/p>
&lt;blockquote>
&lt;p>我们可以设置FUNCNEST环境变量来限制函数嵌套调用的次数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nv">FUNCNEST&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">4&lt;/span>
&lt;span class="ln">2&lt;/span>$ &lt;span class="nb">pwd&lt;/span>
&lt;span class="ln">3&lt;/span>lelouch
&lt;span class="ln">4&lt;/span>lelouch
&lt;span class="ln">5&lt;/span>lelouch
&lt;span class="ln">6&lt;/span>lelouch
&lt;span class="ln">7&lt;/span>-bash: pwd: maximum &lt;span class="k">function&lt;/span> nesting level exceeded &lt;span class="o">(&lt;/span>4&lt;span class="o">)&lt;/span>
&lt;span class="ln">8&lt;/span>&lt;span class="c1"># 让我们结束作死，释放ls,pwd两个函数&lt;/span>
&lt;span class="ln">9&lt;/span>&lt;span class="nv">$unset&lt;/span> -f &lt;span class="nb">pwd&lt;/span> ls
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当函数被嵌套到达4次后，shell会自动停止，防止出现循环调用。&lt;/p>
&lt;/blockquote>
&lt;p>如果不使用&lt;code>function&lt;/code>保留字，那么第一个单词就不能某个命令的名称，因为一个单词会被当成要执行的命令名，后面的内容会被当成命令的参数。&lt;code>( )&lt;/code>显然会因为不符合参数规范而报错。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ ls &lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span> whoami&lt;span class="p">;&lt;/span> pwd&lt;span class="p">;&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="ln">2&lt;/span>-bash: syntax error near unexpected token &lt;span class="sb">`&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于函数名称的规范，shell的要求很松，除了使用&lt;code>function&lt;/code>保留字造成的区别外，只要求是&lt;strong>不含有&lt;code>$&lt;/code>符号的单词(word)就可以（单词中默认不应含有元字符，但是非元字符的符号可以，比如func^@Name）&lt;/strong>。&lt;/p>
&lt;p>关于函数体，只要是复合命令都可以。shell在习惯上，会像C语言一样用&lt;strong>大括号&lt;/strong>包裹函数体，需要注意的是由于大括号&lt;code>{ }&lt;/code>是shell的保留字，所以左边的大括号后面必须要用空格或者&lt;code>newline&lt;/code>分割后面的命令，同时大括号内部的命令也要用分号、&lt;code>&amp;amp;&lt;/code>符号或&lt;code>newline&lt;/code>分割。本质上这些就是使用大括号的组命令的规范啊。&lt;/p>
&lt;p>如果在函数体中定义了局部变量，也是和其他函数一样，函数内定义的局部变量会覆盖外部定义的变量，举个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ func1&lt;span class="o">()&lt;/span>
&lt;span class="ln"> 2&lt;/span>&amp;gt;&lt;span class="o">{&lt;/span>
&lt;span class="ln"> 3&lt;/span>&amp;gt; &lt;span class="nb">local&lt;/span> &lt;span class="nv">var&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;func1 local&amp;#39;&lt;/span>
&lt;span class="ln"> 4&lt;/span>&amp;gt; func2
&lt;span class="ln"> 5&lt;/span>&amp;gt;&lt;span class="o">}&lt;/span>
&lt;span class="ln"> 6&lt;/span>
&lt;span class="ln"> 7&lt;/span>$ func2&lt;span class="o">()&lt;/span>
&lt;span class="ln"> 8&lt;/span>&amp;gt;&lt;span class="o">{&lt;/span>
&lt;span class="ln"> 9&lt;/span>&amp;gt; &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;In func2, var = &lt;/span>&lt;span class="nv">$var&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">10&lt;/span>&amp;gt;&lt;span class="o">}&lt;/span>
&lt;span class="ln">11&lt;/span>$ &lt;span class="nv">var&lt;/span>&lt;span class="o">=&lt;/span>global
&lt;span class="ln">12&lt;/span>$ func1
&lt;span class="ln">13&lt;/span>In func2, &lt;span class="nv">var&lt;/span> &lt;span class="o">=&lt;/span> func1 &lt;span class="nb">local&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="函数的使用">函数的使用&lt;/h3>
&lt;p>shell函数的使用和命令、脚本的使用没有区别，都是&lt;code>命令/函数/脚本名称 参数1 参数2 ...&lt;/code>的形式。之前说过这也是shell语言的特色。&lt;/p>
&lt;p>由于shell也是解释型语言，当函数执行时，会根据控制流程依次一步步执行，如果遇到错误就自动终止执行。&lt;/p>
&lt;p>函数执行完成后的返回值，当函数定义时，如果未检查到语法错误，则定义语句返回状态0。当函数执行时，和其他编程语言一样，shell也用&lt;code>return&lt;/code>来返回状态值。只不过shell的&lt;code>return&lt;/code>后面只能跟一个数字，而非其他东西。如果&lt;code>return&lt;/code>后面什么都没加或者函数体中没有&lt;code>return&lt;/code>，则返回函数体最后执行的简单命令的返回值。&lt;/p>
&lt;p>我们可以使用&lt;code>declare -f&lt;/code>查看当前环境所有的函数名称和定义，&lt;code>declare -F&lt;/code>仅查看当前环境所有的函数名称。此外，shell的函数也支持递归，但是递归的层数也受到FUNCNEST环境变量的限制。&lt;/p>
&lt;p>说到这里，很多读者会发现，我们没有提到函数&lt;strong>最关键的功能——传参执行&lt;/strong>，即根据传入的参数变量执行函数。在Shell中，调用函数时确实可以向其传递参数。但是，传参的方式是shell语言特有的。在函数体内部，传入的参数通过位置参数&lt;code>$n&lt;/code>的形式来代表，例如，&lt;code>$1&lt;/code>表示第一个参数，&lt;code>$2&lt;/code>表示第二个参数...&lt;/p>
&lt;p>下一节，我们将具体说说shell中的参数传递。&lt;/p>
&lt;h2 id="shell参数">shell参数&lt;/h2>
&lt;p>参数是一种存储值的实体，可以是名称、数字或是特殊字符。参数中用&lt;strong>名称&lt;/strong>存储值的叫&lt;strong>变量&lt;/strong>。变量由一个值和0-N个属性。变量值由赋值语句指定；属性由&lt;code>declare&lt;/code>命令指定。赋值语句格式如下，如果要删除变量则用&lt;code>unset&lt;/code>命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># 给名为name的变量赋值为value&lt;/span>
&lt;span class="ln">2&lt;/span>$ &lt;span class="nv">name&lt;/span>&lt;span class="o">=[&lt;/span>value&lt;span class="o">]&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="c1"># 删除变量&lt;/span>
&lt;span class="ln">4&lt;/span>$ &lt;span class="nb">unset&lt;/span> name
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于shell把空字符串也认为是合理的变量值，因此value值可以不用给出即&lt;code>name=&lt;/code>，此时shell给name空字符串作为默认值。&lt;/p>
&lt;h3 id="位置参数">位置参数&lt;/h3>
&lt;p>位置参数是由&lt;code>$&lt;/code>和数字组成的参数。当一条命令、脚本或函数执行时，后面可以跟多个参数，我们使用位置参数变量来表示这些参数。也就是说在shell中&lt;strong>位置参数承担这向函数、脚本传参的使用&lt;/strong>。&lt;/p>
&lt;p>其中，&lt;code>$0&lt;/code>代表命令、脚本本身，注意不是函数名称，&lt;code>$1&lt;/code>代表第1个参数，&lt;code>$2&lt;/code>代表第2个参数，依次类推。当参数个数超过10个时，就必须要用&lt;strong>大括号&lt;/strong>把这个数字括起来，例如，&lt;code>${10}&lt;/code>代表第 10 个参数，&lt;code>${100}&lt;/code>则代表第100个参数。&lt;/p>
&lt;p>举个简单的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ funWithParam&lt;span class="o">(){&lt;/span>
&lt;span class="ln">2&lt;/span>&amp;gt; &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;命令/脚本的名称是：&lt;/span>&lt;span class="nv">$0&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>&amp;gt; &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;第一个参数为 &lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln">4&lt;/span>&amp;gt; &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;第二个参数为 &lt;/span>&lt;span class="nv">$2&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln">5&lt;/span>&amp;gt; &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;第十个参数为 &lt;/span>&lt;span class="nv">$10&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln">6&lt;/span>&amp;gt; &lt;span class="c1"># $10 不能获取第十个参数，获取第十个参数需要${10}。当n&amp;gt;=10时，需要使用${n}来获取参数。&lt;/span>
&lt;span class="ln">7&lt;/span>&amp;gt; &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;第十个参数为 &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">10&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln">8&lt;/span>&amp;gt; &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;第十一个参数为 &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">11&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln">9&lt;/span>&amp;gt; &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ funWithParam &lt;span class="m">1&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="m">5&lt;/span> &lt;span class="m">6&lt;/span> &lt;span class="m">7&lt;/span> &lt;span class="m">8&lt;/span> &lt;span class="m">9&lt;/span> &lt;span class="m">34&lt;/span> &lt;span class="m">73&lt;/span>
&lt;span class="ln">2&lt;/span>函数/命令的名称是：-bash !
&lt;span class="ln">3&lt;/span>第一个参数为 &lt;span class="m">1&lt;/span> !
&lt;span class="ln">4&lt;/span>第二个参数为 &lt;span class="m">2&lt;/span> !
&lt;span class="ln">5&lt;/span>第十个参数为 &lt;span class="m">10&lt;/span> !
&lt;span class="ln">6&lt;/span>第十个参数为 &lt;span class="m">34&lt;/span> !
&lt;span class="ln">7&lt;/span>第十一个参数为 &lt;span class="m">73&lt;/span> !
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="特殊参数">特殊参数&lt;/h3>
&lt;p>除了位置参数，shell为了方便编程，还提供一些特殊参数，如下表所示。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">参数处理&lt;/th>
&lt;th style="text-align:center">说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">$#&lt;/td>
&lt;td style="text-align:center">传递到脚本或函数的参数个数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$*&lt;/td>
&lt;td style="text-align:center">以一个单字符串显示所有向脚本传递的参数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$$&lt;/td>
&lt;td style="text-align:center">脚本运行的当前进程ID号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$!&lt;/td>
&lt;td style="text-align:center">后台运行的最后一个进程的ID号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$@&lt;/td>
&lt;td style="text-align:center">与$*相同，但是使用时加引号，并在引号中返回每个参数。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$-&lt;/td>
&lt;td style="text-align:center">显示Shell使用的当前选项，与set命令功能相同。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$?&lt;/td>
&lt;td style="text-align:center">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>需要指出，我们&lt;strong>不能给这些特殊参数进行赋值操作&lt;/strong>。关于&lt;code>$*,S#&lt;/code>二者的区别。当&lt;code>$*&lt;/code>和&lt;code>$@&lt;/code>不被双引号&lt;code>&amp;quot; &amp;quot;&lt;/code>包围时，它们之间没有任何区别，都是将接收到的每个参数看做一份数据，彼此之间以空格来分隔。但是当它们被双引号&lt;code>&amp;quot; &amp;quot;&lt;/code>包含时，就会有区别了：&lt;/p>
&lt;ul>
&lt;li>&amp;quot;$*&amp;quot;会将所有的参数从整体上看做一份数据，而不是把每个参数都看做一份数据。&lt;/li>
&lt;li>&amp;quot;$@&amp;quot;仍然将每个参数都看作一份数据，彼此之间是独立的。&lt;/li>
&lt;/ul>
&lt;p>比如传递了5个参数，那么对于&lt;code>$*&lt;/code>来说，这5个参数会合并到一起形成一份数据，它们之间是无法分割的；而对于&lt;code>$@&lt;/code>来说，这5个参数是相互独立的，它们是5份数据。如果使用&lt;code>echo&lt;/code>直接输出&lt;code>$*&lt;/code>和&lt;code>$@&lt;/code>做对比，是看不出区别的；但如果使用&lt;code>for&lt;/code>循环来逐个输出数据，立即就能看出区别来。&lt;/p>
&lt;p>我们将上一个例子增加一些功能如下，为了方便，我们新建一个&lt;code>test.sh&lt;/code>文件存放函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="cp">#! /bin/bash
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="cp">&lt;/span>funWithParam&lt;span class="o">(){&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;命令的名称是：&lt;/span>&lt;span class="nv">$0&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;第一个参数为 &lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;第二个参数为 &lt;/span>&lt;span class="nv">$2&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;第十个参数为 &lt;/span>&lt;span class="nv">$10&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="c1"># $10 不能获取第十个参数，获取第十个参数需要${10}。当n&amp;gt;=10时，需要使用${n}来获取参数。&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;第十个参数为 &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">10&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;第十一个参数为 &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">11&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;参数总数有 &lt;/span>&lt;span class="nv">$#&lt;/span>&lt;span class="s2"> 个!&amp;#34;&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;作为一个字符串输出所有参数 &lt;/span>&lt;span class="nv">$*&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;$*与S@的区别：&amp;#39;&lt;/span> &lt;span class="c1"># 这里是单引号防止参数展开&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;使用for循环输出$* !&amp;#39;&lt;/span> &lt;span class="c1"># 这里是单引号防止参数展开&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">for&lt;/span> var in &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$*&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$var&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="k">done&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;使用for循环输出$@ !&amp;#39;&lt;/span> &lt;span class="c1"># 这里是单引号防止参数展开&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="k">for&lt;/span> var in &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$@&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$var&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="k">done&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;脚本运行的当前进程ID号 &lt;/span>&lt;span class="nv">$$&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;显示Shell使用的当前选项 &lt;/span>&lt;span class="nv">$-&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;上一个命令的结束状态 &lt;/span>&lt;span class="nv">$?&lt;/span>&lt;span class="s2"> !&amp;#34;&lt;/span>
&lt;span class="ln">26&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">27&lt;/span>funWithParam &lt;span class="m">1&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="m">5&lt;/span> &lt;span class="m">6&lt;/span> &lt;span class="m">7&lt;/span> &lt;span class="m">8&lt;/span> &lt;span class="m">9&lt;/span> &lt;span class="m">34&lt;/span> &lt;span class="m">73&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ bash test.sh
&lt;span class="ln"> 2&lt;/span>命令的名称是：test.sh !
&lt;span class="ln"> 3&lt;/span>第一个参数为 &lt;span class="m">1&lt;/span> !
&lt;span class="ln"> 4&lt;/span>第二个参数为 &lt;span class="m">2&lt;/span> !
&lt;span class="ln"> 5&lt;/span>第十个参数为 &lt;span class="m">10&lt;/span> !
&lt;span class="ln"> 6&lt;/span>第十个参数为 &lt;span class="m">34&lt;/span> !
&lt;span class="ln"> 7&lt;/span>第十一个参数为 &lt;span class="m">73&lt;/span> !
&lt;span class="ln"> 8&lt;/span>参数总数有 &lt;span class="m">11&lt;/span> 个!
&lt;span class="ln"> 9&lt;/span>作为一个字符串输出所有参数 &lt;span class="m">1&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="m">5&lt;/span> &lt;span class="m">6&lt;/span> &lt;span class="m">7&lt;/span> &lt;span class="m">8&lt;/span> &lt;span class="m">9&lt;/span> &lt;span class="m">34&lt;/span> &lt;span class="m">73&lt;/span> !
&lt;span class="ln">10&lt;/span>&lt;span class="nv">$*&lt;/span>与S@的区别：
&lt;span class="ln">11&lt;/span>使用for循环输出&lt;span class="nv">$*&lt;/span> !
&lt;span class="ln">12&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="m">5&lt;/span> &lt;span class="m">6&lt;/span> &lt;span class="m">7&lt;/span> &lt;span class="m">8&lt;/span> &lt;span class="m">9&lt;/span> &lt;span class="m">34&lt;/span> &lt;span class="m">73&lt;/span>
&lt;span class="ln">13&lt;/span>使用for循环输出&lt;span class="nv">$@&lt;/span> !
&lt;span class="ln">14&lt;/span>&lt;span class="m">1&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="m">2&lt;/span>
&lt;span class="ln">16&lt;/span>&lt;span class="m">3&lt;/span>
&lt;span class="ln">17&lt;/span>&lt;span class="m">4&lt;/span>
&lt;span class="ln">18&lt;/span>&lt;span class="m">5&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="m">6&lt;/span>
&lt;span class="ln">20&lt;/span>&lt;span class="m">7&lt;/span>
&lt;span class="ln">21&lt;/span>&lt;span class="m">8&lt;/span>
&lt;span class="ln">22&lt;/span>&lt;span class="m">9&lt;/span>
&lt;span class="ln">23&lt;/span>&lt;span class="m">34&lt;/span>
&lt;span class="ln">24&lt;/span>&lt;span class="m">73&lt;/span>
&lt;span class="ln">25&lt;/span>脚本运行的当前进程ID号 &lt;span class="m">30483&lt;/span> !
&lt;span class="ln">26&lt;/span>显示Shell使用的当前选项 hB !
&lt;span class="ln">27&lt;/span>上一个命令的结束状态 &lt;span class="m">0&lt;/span> !
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考内容">参考内容&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.gnu.org/software/bash/manual/bash.html">https://www.gnu.org/software/bash/manual/bash.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.runoob.com/linux/linux-shell-process-control.html">https://www.runoob.com/linux/linux-shell-process-control.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.runoob.com/w3cnote/linux-shell-brackets-features.html">https://www.runoob.com/w3cnote/linux-shell-brackets-features.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://c.biancheng.net/view/807.html">http://c.biancheng.net/view/807.html&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Shell 骨干流程1——形成初步命令</title><link>https://surprisedcat.github.io/projectnotes/shell-%E9%AA%A8%E5%B9%B2%E6%B5%81%E7%A8%8B1%E5%BD%A2%E6%88%90%E5%88%9D%E6%AD%A5%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 02 Jan 2022 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/shell-%E9%AA%A8%E5%B9%B2%E6%B5%81%E7%A8%8B1%E5%BD%A2%E6%88%90%E5%88%9D%E6%AD%A5%E5%91%BD%E4%BB%A4/</guid><description>
&lt;ul>
&lt;li>&lt;a href="#%E5%85%83%E5%AD%97%E7%AC%A6%E5%88%86%E5%89%B2%E8%BE%93%E5%85%A5%E5%86%85%E5%AE%B9%E4%B8%BA%E6%A0%87%E8%AE%B0">元字符分割输入内容为标记&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%BC%95%E5%8F%B7%E5%A4%84%E7%90%86">引号处理&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%E8%BD%AC%E4%B9%89%E7%AC%A6">转义符&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#ansi-c%E5%BC%95%E7%94%A8">ANSI-C引用&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%E5%8D%95%E5%BC%95%E5%8F%B7">单引号&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%8C%E5%BC%95%E5%8F%B7">双引号&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#shell%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90">shell命令解析&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%E7%AE%A1%E9%81%93">管道&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8">命令列表&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%A4%8D%E5%90%88%E5%91%BD%E4%BB%A4">复合命令&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%E5%88%AB%E5%90%8Dalias%E5%B1%95%E5%BC%80">别名(alias)展开&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%82%E8%80%83%E5%86%85%E5%AE%B9">参考内容&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>总体流程图镇楼：&lt;/p>
&lt;p>&lt;img src="../../images/shell%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.drawio.svg" alt="shell执行流程">&lt;/p>
&lt;h2 id="shell-骨干流程1形成初步命令---omit-in-toc---">Shell 骨干流程1——形成初步命令&lt;!-- omit in toc -->&lt;/h2>
&lt;p>我们将第1-4步分为第一大步，其主要作用是&lt;strong>形成初步命令&lt;/strong>。在流程图中为橙色部分，其主要处理流程为&lt;strong>元字符分割为标记、shell命令解析、shell命令解析、别名展开&lt;/strong>。元字符将命令分割为标记，做为后续处理的准备工作。引号处理分为单引号、双引号和反斜杠的处理。shell命令解析这步比较复杂，涉及保留字，命令组合方式，条件，循环等内容，我们放到单独的文章里讨论。最后别名展开算是正式处理命令的第一步。&lt;/p>
&lt;h2 id="元字符分割输入内容为标记">元字符分割输入内容为标记&lt;/h2>
&lt;p>首先，对于元字符有哪些这个问题，我在查询资料时，发现资料的说法并不统一。于是，我查看了Bash的源码，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#define shell_meta_chars &amp;#34;()&amp;lt;&amp;gt;;&amp;amp;|&amp;#34;
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">#define shell_break_chars &amp;#34;()&amp;lt;&amp;gt;;&amp;amp;| \t\n&amp;#34;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>按照这个定义元字符应该是&lt;code>()&amp;lt;&amp;gt;;&amp;amp;|&lt;/code>这几个，但是bash源码中又在下一行定义了“shell_break_chars”，添加了&lt;code>space( ), tab(\t), newline(\n)&lt;/code>这三个元素。在源码实操分割的语法分析器（y.tab.c文件）中，使用的是“shell_break_chars”，因此第1步应该是通过&amp;quot;()&amp;lt;&amp;gt;;&amp;amp;| \t\n&amp;quot;这几个元素来分割读取的内容。需要特别指出：引号包裹的部分会作为一个整体来处理，在1-4步中不需要额外处理，后面会有内容展开的步骤。分割完成后的标记分为单词word或操作符operator两种类型。&lt;/p>
&lt;p>单词word，就是按照字面意思的一串字符，一般的单词之间是没有blank（包含空格&lt;code>space&lt;/code>和制表符&lt;code>tab&lt;/code>）和其他元字符的，但是在如果存在引号，则可以有blank和元字符，且引号中内容作为一个单词来处理。单词word还包括等号，数字，算术表达式。操作符operator则包含了控制字符和重定位符，操作符至少由一个元字符组成。我在&lt;a href="https://www.gnu.org/software/bash/manual/html_node/index.html#SEC_Contents">Bash Reference Manual&lt;/a>第二节看到有关操作符的内容，总觉得实际上应用的操作符比书中第二节列出的内容要多，于是我要翻了翻源码，找到了bash中操作符的内容，如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="ln"> 1&lt;/span>&lt;span class="cm">/* other tokens that can be returned by read_token() */&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="n">STRING_INT_ALIST&lt;/span> &lt;span class="n">other_token_alist&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="cm">/* Multiple-character tokens with special values */&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;--&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">TIMEIGN&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;-p&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">TIMEOPT&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;&amp;amp;&amp;amp;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">AND_AND&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;||&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">OR_OR&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;&amp;gt;&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GREATER_GREATER&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;&amp;lt;&amp;lt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">LESS_LESS&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;&amp;lt;&amp;amp;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">LESS_AND&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;&amp;gt;&amp;amp;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GREATER_AND&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;;;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SEMI_SEMI&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;;&amp;amp;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SEMI_AND&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;;;&amp;amp;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SEMI_SEMI_AND&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;&amp;lt;&amp;lt;-&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">LESS_LESS_MINUS&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;&amp;lt;&amp;lt;&amp;lt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">LESS_LESS_LESS&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;&amp;amp;&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">AND_GREATER&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;&amp;amp;&amp;gt;&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">AND_GREATER_GREATER&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;&amp;lt;&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">LESS_GREATER&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;&amp;gt;|&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GREATER_BAR&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;|&amp;amp;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BAR_AND&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;EOF&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">yacc_EOF&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="cm">/* Tokens whose value is the character itself */&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;&amp;gt;&amp;#39;&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;&amp;lt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;&amp;lt;&amp;#39;&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;-&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;-&amp;#39;&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;{&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;{&amp;#39;&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;}&amp;#39;&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">29&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;;&amp;#39;&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">30&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;(&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;(&amp;#39;&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">31&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;)&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;)&amp;#39;&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;|&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;|&amp;#39;&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">33&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;&amp;amp;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;&amp;amp;&amp;#39;&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;newline&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="ln">35&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">36&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>果然，比&lt;a href="https://www.gnu.org/software/bash/manual/html_node/index.html#SEC_Contents">Bash Reference Manual&lt;/a>所述内容多了不少，还是实际代码中最全啊。从操作符的“other_token_alist”列表可以看出，元字符组成的操作符会在此列表中查找，将符合列表内容的多个元字符组成符号会被当成一个操作符。例如，&lt;code>ll $(type -path cc) ~/.*$(($$%1000)) &amp;gt;&amp;gt; /tmp/test.txt 2&amp;gt;&amp;amp;1&lt;/code>会被分割为：&lt;code>ll, $, (, type, -path, cc, ), ~/.*, $, (, (, $$%1000, ), ), &amp;gt;&amp;gt;, /tmp/test.txt, 2, &amp;gt;&amp;amp;, 1&lt;/code>。单词和操作符都被认为是一个独立单元，称为&lt;strong>标记（token）&lt;/strong>。每一个标记都会被单独的处理。&lt;/p>
&lt;h2 id="引号处理">引号处理&lt;/h2>
&lt;p>shell的引号处理作用是&lt;strong>去除特殊字符或单词的特殊作用&lt;/strong>。比如，在shell中，'&amp;amp;'通常会被用来表示后台处理命令或在重定向时表示后面的数字为打开的文件描述符，为了能直接按字面意思显示'&amp;amp;'符号，需要我们使用“引用”的方式。shell中存在三种引用机制：转义符（\），单引号(')和双引号（&amp;quot;）。还有一种特殊的引用，注释（#），这个大多数人应该都了解，就不特别说明了。&lt;/p>
&lt;h3 id="转义符">转义符&lt;/h3>
&lt;p>转义符，我们通常用反斜杠''表示，它的作用是将&lt;strong>紧跟后面的一个字符&lt;/strong>保留原来的字面的意思。在shell中，元字符和通配符通常代表特殊的含义，如果我们想让这些字符按照普通字符显示显示出来，就需要用到转义符了。比如，我们想在shell中输出$' &amp;quot; * ? \ ~ ` ! # $ &amp;amp; |$，这类特殊字符，直接用&lt;code>echo&lt;/code>或&lt;code>printf&lt;/code>输出肯定是不行的，必须加上转义符号：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="se">\&amp;#39;&lt;/span> &lt;span class="se">\&amp;#34;&lt;/span> &lt;span class="se">\*&lt;/span> &lt;span class="se">\?&lt;/span> &lt;span class="se">\\&lt;/span> &lt;span class="se">\~&lt;/span> &lt;span class="se">\`&lt;/span> &lt;span class="se">\!&lt;/span> &lt;span class="se">\#&lt;/span> &lt;span class="se">\$&lt;/span> &lt;span class="se">\&amp;amp;&lt;/span> &lt;span class="se">\|&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="s1">&amp;#39; &amp;#34; * ? \ ~ ` ! # $ &amp;amp; |
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="s1">$ printf \&amp;#39;&lt;/span>&lt;span class="se">\&amp;#34;\*\?\\\~\`\!\#\$\&amp;amp;\|&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="s1">&amp;#39;&amp;#34;*?\~`!#$&amp;amp;|
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="s1"># 如果想让printf也空一格输出，需要在每个字符后面加上空格的转义，即\+SPACE
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="s1">$ printf \&amp;#39;&lt;/span>&lt;span class="se">\ \&amp;#34;\ \*\ \?\ \\\ \~\ \`\ \!\ \#\ \$\ \&amp;amp;\ \|&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="err">&amp;#39;&lt;/span> &lt;span class="s2">&amp;#34; * ? \ ~ ` ! # &lt;/span>$&lt;span class="s2"> &amp;amp; |
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>实际上，转义符不仅仅对特殊字符有效，对一般的字符也是一样的作用，只不过一般字符的字面意思就是字符本身，所以转义符加了和没加一样。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="se">\a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z&lt;/span>
&lt;span class="ln">2&lt;/span>abcdefghijklmnopqrstuvwxyz
&lt;span class="ln">3&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="se">\1\2\3\4\5\6\7\8\9\0&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="m">1234567890&lt;/span>
&lt;span class="ln">5&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="se">\,\;\[\]\{\}\-\@\%&lt;/span>
&lt;span class="ln">6&lt;/span>,&lt;span class="p">;&lt;/span>&lt;span class="o">[]{}&lt;/span>-@%
&lt;/code>&lt;/pre>&lt;/div>&lt;p>虽说，转义符会保留字符原来的字面的意思，但是在键盘上有个按键不同，就是&lt;code>newline&lt;/code>字符（即键盘上的回车/换行）。shell会将转义符&lt;code>\+newline&lt;/code>的组合忽略，这种机制方便了我们在输入时进行换行，而在执行时仍旧是一行，多用于很长的命令，如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ find /etc -exec grep&lt;span class="se">\
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="se">&lt;/span>&amp;gt;&lt;span class="s1">&amp;#39;[0-9][0-9]*[.][0-9][0-9] \
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="s1">&amp;gt; *[.][0-9][0-9]*[0-9][0-9]*&amp;#39;&lt;/span> &lt;span class="o">{}&lt;/span> &lt;span class="se">\;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于&lt;code>find&lt;/code>命令很长且可以明显的分割为多个部分，因此，我们使用转义符&lt;code>\+newline&lt;/code>让输入的时候命令更易读，实际执行起来，等同于&lt;code>find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9] *[.][0-9][0-9]*[0-9][0-9]*' {} \;&lt;/code>&lt;/p>
&lt;h4 id="ansi-c引用">ANSI-C引用&lt;/h4>
&lt;p>转移符还有另一种用法，源自于C语言的字符串输出格式，叫做ANSI-C引用。对于有C语言经验的人来说，这种用法很容易理解。在这种用法下，转义符“\”和后面的一些字母组合起来会有特殊的含义。比如“\n”会被替换成换行，“\t”会被替换成&lt;code>tab&lt;/code>，“\b”会被替换成退格（删除前一个字符）等等。如果想输出“\n，\t”这些字符，要先将转义符转义，再将字母转义，即写成“\\n,\\t”的形式。&lt;/p>
&lt;p>在ANSI-C模式下，转义符特殊使用方法如下表：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">字符&lt;/th>
&lt;th style="text-align:center">含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">\a&lt;/td>
&lt;td style="text-align:center">响铃。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">\b&lt;/td>
&lt;td style="text-align:center">退格。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">\e、\E&lt;/td>
&lt;td style="text-align:center">看作一个转义字符（这不符合 ANSI C 的标准）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">\f&lt;/td>
&lt;td style="text-align:center">换页。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">\n&lt;/td>
&lt;td style="text-align:center">新一行。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">\r&lt;/td>
&lt;td style="text-align:center">回车。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">\t&lt;/td>
&lt;td style="text-align:center">水平制表符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">\v&lt;/td>
&lt;td style="text-align:center">垂直制表符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">\\&lt;/td>
&lt;td style="text-align:center">反斜线。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">'&lt;/td>
&lt;td style="text-align:center">单引号。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&amp;quot;&lt;/td>
&lt;td style="text-align:center">双引号。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">?&lt;/td>
&lt;td style="text-align:center">问号。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">\nnn&lt;/td>
&lt;td style="text-align:center">值是八进制 nnn 的八比特字符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">\xHH&lt;/td>
&lt;td style="text-align:center">值是十六进制 HH 的八比特字符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">\uHHHH&lt;/td>
&lt;td style="text-align:center">值是十六进制 HHHH 的 Unicode（ISO/IEC 10646）字符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">\UHHHHHHHH&lt;/td>
&lt;td style="text-align:center">值是十六进制的 HHHHHHHH 的 Unicode（ISO/IEC 10646）字符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">\cx&lt;/td>
&lt;td style="text-align:center">表示 control-x 字符。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>shell中常见的有三个命令会使用ANSI-C模式。&lt;/p>
&lt;ol>
&lt;li>&lt;code>echo -e 字符串&lt;/code>；&lt;/li>
&lt;li>&lt;code>printf FORMAT [ARGUMENT]&lt;/code>，注意只有用单/双引号引起来的FORMAT，才会使用ANSI-C模式；&lt;/li>
&lt;li>&lt;code>$'字符串'&lt;/code>，注意这里$后面一定是单引号。&lt;/li>
&lt;/ol>
&lt;p>举例子如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ &lt;span class="nb">echo&lt;/span> -e &lt;span class="s1">&amp;#39;a\tb\n&amp;#39;&lt;/span> &lt;span class="c1"># echo命令默认有一个换行，因此会多一个空行&lt;/span>
&lt;span class="ln"> 2&lt;/span>a b
&lt;span class="ln"> 3&lt;/span>
&lt;span class="ln"> 4&lt;/span>$ &lt;span class="nb">printf&lt;/span> &lt;span class="s1">&amp;#39;%s\t%s\n&amp;#39;&lt;/span> a b &lt;span class="c1"># 必须用引号&lt;/span>
&lt;span class="ln"> 5&lt;/span>a b
&lt;span class="ln"> 6&lt;/span>$ &lt;span class="nb">printf&lt;/span> %s&lt;span class="se">\t&lt;/span>%s&lt;span class="se">\n&lt;/span> a b &lt;span class="c1"># 没有引号不行，下面由于没有换行，所以输出内容和$符号挤到了一行。&lt;/span>
&lt;span class="ln"> 7&lt;/span>atbn$ &lt;span class="nb">printf&lt;/span> &lt;span class="s1">&amp;#39;a%sb\n&amp;#39;&lt;/span> &lt;span class="se">\n&lt;/span> &lt;span class="c1"># 在参数[ARGUMENT]里面不行，必须在[FORMAT]里面。&lt;/span>
&lt;span class="ln"> 8&lt;/span>anb
&lt;span class="ln"> 9&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="s1">$&amp;#39;a\tb&amp;#39;&lt;/span>
&lt;span class="ln">10&lt;/span>a b
&lt;span class="ln">11&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="s2">$&amp;#34;a\tb\n&amp;#34;&lt;/span> &lt;span class="c1"># 双引号不行&lt;/span>
&lt;span class="ln">12&lt;/span>a&lt;span class="se">\t&lt;/span>b&lt;span class="se">\n&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="单引号">单引号&lt;/h3>
&lt;p>我们可以使用单引号引用字符串，单引号内的&lt;strong>任何字符&lt;/strong>都会保持其字面意思。单引号不能出现在单引号引用中，即使前面加了反斜线也不行。注：&lt;code>$'字符串'&lt;/code>属于命令扩展，并非单纯的单引号引用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;a\tb\n&amp;#39;&lt;/span>
&lt;span class="ln">2&lt;/span>a&lt;span class="se">\t&lt;/span>b&lt;span class="se">\n&lt;/span>
&lt;span class="ln">3&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;\\\\ $ ! * ? &amp;#34;&amp;#39;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="se">\\\\&lt;/span> $ ! * ? &lt;span class="s2">&amp;#34;
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="s2">&lt;/span>$&lt;span class="s2"> echo &amp;#39;\&amp;#39; &amp;#39; # 不能出现单引号
&lt;/span>&lt;span class="ln">6&lt;/span>&lt;span class="s2">&amp;gt; &amp;#39;
&lt;/span>&lt;span class="ln">7&lt;/span>&lt;span class="s2">\
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="双引号">双引号&lt;/h3>
&lt;p>我们可以使用双引号引用字符串，在双引号（' &amp;quot; '）内的大多数字符保留字符的字面含义，但'$'，'`'，'\'，以及在启用历史记录扩展后，'!'这四个除外。在双引号中可以使用单引号，也可以在转义符后面加双引号或其他特殊字符表示其字面意思（\&amp;quot;,\\,\$,\`,\!）。由于双引号可以将变量、子shell命令、历史记录扩展以及其他特殊字符带入其中，因此双引号比单引号使用起来更加灵活。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nv">VAR&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;a variable&amp;#34;&lt;/span>
&lt;span class="ln">2&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;This is &lt;/span>&lt;span class="nv">$VAR&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="c1"># 变量扩展&lt;/span>
&lt;span class="ln">3&lt;/span>This is a variable
&lt;span class="ln">4&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;list path `pwd`&amp;#34;&lt;/span> &lt;span class="c1"># 子命令扩展&lt;/span>
&lt;span class="ln">5&lt;/span>list path /home/lelouch
&lt;span class="ln">6&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&amp;#39; \&amp;#34; \` \$ \\&amp;#34;&lt;/span> &lt;span class="c1">#特殊字符使用，单引号不用转义&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="s1">&amp;#39; &amp;#34; ` $ \
&lt;/span>&lt;span class="ln">8&lt;/span>&lt;span class="s1">$ echo &amp;#34;!$&amp;#34; # 输出上一个执行的命令内容
&lt;/span>&lt;span class="ln">9&lt;/span>&lt;span class="s1">echo &amp;#34;&amp;#34;&amp;#39;&lt;/span> &lt;span class="se">\&amp;#34;&lt;/span> &lt;span class="se">\`&lt;/span> &lt;span class="se">\$&lt;/span> &lt;span class="se">\\&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="shell命令解析">shell命令解析&lt;/h2>
&lt;p>shell中最常见的是简单命令，我们直接在shell中输入的一般是简单命令，有shell单步执行，返回结果，如&lt;code>ls、echo &amp;quot;hello world&amp;quot;、cat /etc/hosts&lt;/code>。简单命令是组成shell的基石，其他更复杂的命令也是由简单命令组成。&lt;/p>
&lt;blockquote>
&lt;p>简单命令是由一系列有blanks分割的一组单词(word)，并以某个shell操作符(operator)结束，首个单词通常表示需要执行的命令名称/别名，后面的单词都是该命令/别名的参数。&lt;/p>
&lt;ul>
&lt;li>blank：包含空格&lt;code>space&lt;/code>和制表符&lt;code>tab&lt;/code>&lt;/li>
&lt;li>control operator, 控制符：包含&lt;code>newline, '||', '&amp;amp;&amp;amp;', '&amp;amp;', ';', ';;', ';&amp;amp;', ';;&amp;amp;', '|', '|&amp;amp;', '(', ')'&lt;/code>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>简单命令组成复杂命令的方式一般有&lt;strong>管道、命令列表、复合命令&lt;/strong>等。&lt;/p>
&lt;h3 id="管道">管道&lt;/h3>
&lt;p>管道（Pipeline）操作符为“|”，是一系列将&lt;strong>标准输入输出链接起来&lt;/strong>的进程，其中每一个进程的输出被直接作为下一个进程的输入。管道中的组成元素也被称作过滤程序。这个概念是由道格拉斯·麦克罗伊为Unix 命令行发明的，因与物理上的管道相似而得名。&lt;/p>
&lt;p>这是来自Wikipedia的定义。定义中指出，默认情况下，管道只会将上一个程序的标准输出(stdout)，传递给下一个命令，作为标准的输入(stdin)，对标准错误(stderr)信息没有直接处理能力。最后的命令将会把标准输出和标准错误都输出到屏幕上。画个简图来描述他们的关系：&lt;/p>
&lt;p>&lt;img src="../../images/%E7%AE%A1%E9%81%93%E5%91%BD%E4%BB%A4%E7%A4%BA%E6%84%8F%E5%9B%BE.drawio.svg" alt="管道命令示意图">&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ol>
&lt;li>管道命令只处理前一个命令正确输出，不处理错误输出。&lt;/li>
&lt;li>管道命令右边命令，必须能够接收标准输入流命令才行。&lt;/li>
&lt;li>管道触发两个子进程分别执行&amp;quot;|&amp;quot;两边的程序；而重定向是在一个进程内执行。&lt;/li>
&lt;li>如果使用&lt;code>|&amp;amp;&lt;/code>，则表示命令1的标准错误和标准输出都作为命令2的标准输入，这是&lt;code>2&amp;gt;&amp;amp;1 |&lt;/code>的简写。&lt;/li>
&lt;/ol>
&lt;p>总结来说，管道是将命令串成一串，依次执行力，上一个命令的输出作为下一个命令的输入，更多关于管道的内容可以查看《linux-管道pipe与xargs》。&lt;/p>
&lt;h3 id="命令列表">命令列表&lt;/h3>
&lt;p>命令列表是由简单命令和&lt;code>||,&amp;amp;&amp;amp;,&amp;amp;,;&lt;/code>四种符号组成的命令，简单命令之间通过上述四种符号进行分割。有时候，在直接写shell脚本时，也可以用&lt;code>newline&lt;/code>代替&lt;code>;&lt;/code>从而让内容更加工整。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;amp;&amp;amp;&lt;/strong> 用法&lt;code>command 1 &amp;amp;&amp;amp; command 2&lt;/code>，表示当&lt;code>command 1&lt;/code>执行成功后，再执行&lt;code>command 2&lt;/code>，如果不成功，则不执行&lt;code>command 2&lt;/code>。&lt;/li>
&lt;li>&lt;strong>||&lt;/strong> 用法&lt;code>command 1 || command 2&lt;/code>，表示若&lt;code>command 1&lt;/code>执行失败，则执行&lt;code>command 2&lt;/code>，如果执行成功，则不执行&lt;code>command 2&lt;/code>。&lt;/li>
&lt;li>&lt;strong>;&lt;/strong> 表示一条命令输入结束，命令按顺序执行。&lt;/li>
&lt;li>&lt;strong>＆&lt;/strong> 表示后台执行&amp;amp;之前的命令，此时如果有多个命令，后台执行的命令和其他命令是异步的。&lt;/li>
&lt;/ul>
&lt;p>从运算优先级来看，&lt;code>&amp;amp;&amp;amp;,||&lt;/code>处于同一优先级，&lt;code>&amp;amp;,;&lt;/code>处于次一优先级。命令列表的使用例子如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ &lt;span class="nb">cd&lt;/span> /tmp&lt;span class="p">;&lt;/span> pwd&lt;span class="p">;&lt;/span> &lt;span class="nb">cd&lt;/span> /dev/ &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">pwd&lt;/span>
&lt;span class="ln"> 2&lt;/span>/tmp
&lt;span class="ln"> 3&lt;/span>/dev
&lt;span class="ln"> 4&lt;/span>$ &lt;span class="nb">cd&lt;/span> /root &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">pwd&lt;/span> &lt;span class="c1"># 无法cd到/root目录，因此&amp;amp;&amp;amp;后面的pwd没有执行&lt;/span>
&lt;span class="ln"> 5&lt;/span>-bash: cd: /root: Permission denied
&lt;span class="ln"> 6&lt;/span>$ &lt;span class="nb">cd&lt;/span> /root &lt;span class="o">||&lt;/span> &lt;span class="nb">pwd&lt;/span> &lt;span class="c1"># 无法cd到/root目录，发生错误后||后面的pwd得以执行&lt;/span>
&lt;span class="ln"> 7&lt;/span>-bash: cd: /root: Permission denied
&lt;span class="ln"> 8&lt;/span>/dev
&lt;span class="ln"> 9&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;I am 1&amp;#39;&lt;/span>&lt;span class="p">&amp;amp;&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;I am 2&amp;#39;&lt;/span> &lt;span class="p">&amp;amp;&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;I am 3&amp;#39;&lt;/span> &lt;span class="c1"># 前两个命令后台异步执行，最后一个命令前台执行。&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span> &lt;span class="m">23766&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="o">[&lt;/span>2&lt;span class="o">]&lt;/span> &lt;span class="m">23767&lt;/span>
&lt;span class="ln">12&lt;/span>I am &lt;span class="m">3&lt;/span>
&lt;span class="ln">13&lt;/span>I am &lt;span class="m">2&lt;/span>
&lt;span class="ln">14&lt;/span>I am &lt;span class="m">1&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span>- Done &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;I am 1&amp;#39;&lt;/span>
&lt;span class="ln">16&lt;/span>&lt;span class="o">[&lt;/span>2&lt;span class="o">]&lt;/span>+ Done &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;I am 2&amp;#39;&lt;/span>
&lt;span class="ln">17&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此外，除了&lt;code>&amp;amp;&lt;/code>符号，GNU还提供了&lt;code>parallel&lt;/code>命令来并行执行命令，但这部分超出了shell本身的内容，有兴趣的读者可以阅读&lt;a href="https://www.gnu.org/software/parallel/">&lt;code>parallel&lt;/code>的相关文档&lt;/a>。&lt;/p>
&lt;h3 id="复合命令">复合命令&lt;/h3>
&lt;p>复合命令是通过shell保留字和简单命令组合形成的组合命令，算是shell脚本语言的基本结构。&lt;strong>每一个复合命令结构都由每一个保留字或控制符开始，并以对应的保留字或控制符结束&lt;/strong>，这算是shell编程语言的一个特色，例如以&lt;code>if&lt;/code>开头，&lt;code>fi&lt;/code>结尾；&lt;code>do&lt;/code>开头，&lt;code>done&lt;/code>结尾等等。对shell复合命令结构的输入、输出重定向将被应用到该结构的每一个简单命令中，除非其中有某个简单命令用显式的重定向覆盖该结构的重定向。写shell语言时，为了保证代码可读性，在复合命令结构之间通常用&lt;code>newline&lt;/code>来分割，而不是用&lt;code>;&lt;/code>来分割，虽然从语法上来讲，二者作用是一样的，但是过长的代码会给后续的维护造成困难。The Bourne Again SHell（bash）提供循环、条件、组命令、协同四种流程控制复合命令，以及函数复合命令，并用相应的保留字指示bash是哪一种复合命令。bash的保留字如以下表格所示：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">&lt;/th>
&lt;th style="text-align:center">&lt;/th>
&lt;th style="text-align:center">&lt;/th>
&lt;th style="text-align:center">&lt;/th>
&lt;th style="text-align:center">&lt;/th>
&lt;th style="text-align:center">&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">if&lt;/td>
&lt;td style="text-align:center">then&lt;/td>
&lt;td style="text-align:center">elif&lt;/td>
&lt;td style="text-align:center">else&lt;/td>
&lt;td style="text-align:center">fi&lt;/td>
&lt;td style="text-align:center">time&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">for&lt;/td>
&lt;td style="text-align:center">in&lt;/td>
&lt;td style="text-align:center">until&lt;/td>
&lt;td style="text-align:center">while&lt;/td>
&lt;td style="text-align:center">do&lt;/td>
&lt;td style="text-align:center">done&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">case&lt;/td>
&lt;td style="text-align:center">esac&lt;/td>
&lt;td style="text-align:center">coproc&lt;/td>
&lt;td style="text-align:center">select&lt;/td>
&lt;td style="text-align:center">function&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">{&lt;/td>
&lt;td style="text-align:center">}&lt;/td>
&lt;td style="text-align:center">[[&lt;/td>
&lt;td style="text-align:center">]]&lt;/td>
&lt;td style="text-align:center">!&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>总体处理流程上，shell会先检查第一个标记，如果是可前置保留字(&lt;code>if, for, while, until, case, select, time, function, coproc, {, [[, !&lt;/code>)，则开启复合命令流程；如果是非可前置保留字(&lt;code>then, elif, fi, in, do, done, esac, }, ]]&lt;/code>)，且之前没有与之对应的可前置保留字，则报语法错误；如果不是保留字则当作简单命令，执行下一步骤。&lt;/p>
&lt;p>我们将在《shell-骨干流程2——复合命令与控制流程》中详细的讨论复合命令。&lt;/p>
&lt;h2 id="别名alias展开">别名(alias)展开&lt;/h2>
&lt;p>经过命令解析步骤，可以将任意命令都分解成简单命令，剩下的步骤都是针对简单命令，一条条处理。首先要做的是别名展开，主要做的是检查简单命令的第一个标记(token)是否为别名（alias），如果是则展开别名(alias)。shell维护了一个“alias”列表，我们可以通过shell的内置命令&lt;code>alias&lt;/code>查看现有的别名列表：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nb">alias&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nb">alias&lt;/span> &lt;span class="nv">l&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;ls -CF&amp;#39;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nb">alias&lt;/span> &lt;span class="nv">la&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;ls -A&amp;#39;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">alias&lt;/span> &lt;span class="nv">ll&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;ls -l&amp;#39;&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="nb">alias&lt;/span> &lt;span class="nv">ls&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;ls --color=auto&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以通过&lt;code>alias 别名名称='别名内容'&lt;/code>的方式在当前shell环境中临时添加别名（该shell关闭后，临时添加的别名失效），也可以在任意shell环境文件（如&lt;code>/etc/environment, /etc/profile, ~/.bash_profile, ~/.bash_login, ~/.profile, ~/.bashrc, /etc/bashrc, /etc/bash.bashrc&lt;/code>）中永久添加别名。如果别名名称重复，则会覆盖原有别名。也可以通过&lt;code>unalias 别名名称&lt;/code>取消某个别名。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nb">alias&lt;/span> &lt;span class="nv">hello&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;cd /etc/ &amp;amp;&amp;amp; pwd&amp;#39;&lt;/span>
&lt;span class="ln">2&lt;/span>$ hello
&lt;span class="ln">3&lt;/span>/etc
&lt;span class="ln">4&lt;/span>$ &lt;span class="nb">alias&lt;/span> &lt;span class="nv">hello&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;whoami&amp;#39;&lt;/span>
&lt;span class="ln">5&lt;/span>$ hello
&lt;span class="ln">6&lt;/span>lelouch
&lt;span class="ln">7&lt;/span>$ &lt;span class="nb">unalias&lt;/span> hello
&lt;span class="ln">8&lt;/span>$ hello
&lt;span class="ln">9&lt;/span>-bash: hello: &lt;span class="nb">command&lt;/span> not found
&lt;/code>&lt;/pre>&lt;/div>&lt;p>展开别名本质上是一个&lt;strong>文本替换&lt;/strong>的过程。比如，我们输入&lt;code>ll /etc/&lt;/code>，shell就会拿着第一个单词&amp;quot;ll&amp;quot;，查询alias列表，发现有一项&lt;code>alias ll='ls -l'&lt;/code>，就会将&lt;code>ll&lt;/code>替换成&lt;code>ls -l&lt;/code>，命令变成&lt;code>ls -l /etc/&lt;/code>。然后，回到第1步，经过元字符分割为标记、shell命令解析、shell命令解析，再到展开别名这步，拿着第一个单词&amp;quot;ls&amp;quot;，查询alias列表，又发现有一项&lt;code>alias ls='ls --color=auto'&lt;/code>，替换&lt;code>ls -l /etc/&lt;/code>为&lt;code>ls --color=auto -l /etc/&lt;/code>。再回到第1步，经过2，3两步，到展开别名这步，这次首单词还是“ls”。但是shell的alias有一个规定，&lt;strong>之前展开过的别名不能二次展开&lt;/strong>，这是为了防止出现循环展开的情形，因此shell不会再对&lt;code>ls&lt;/code>进行处理，完成这一步工作。&lt;/p>
&lt;p>有人会有一个疑惑，为什么展开别名后，还有回到第1步，重新执行1-3步？&lt;/p>
&lt;p>这是因为，我们对别名的名称有限制（后面再说），但是对别名的内容基本没有限制。因此别名的内容可以包含多条简单命令、复合命令、元字符、引号等等，所以别名展开后，还需要对这些内容进行再次处理。&lt;/p>
&lt;p>此外，从shell处理流程图中，我们能够发现别名替换是在命令执行之前完成的，如果我们在一个复合命令中使用&lt;code>alias&lt;/code>定义了某个别名，并立即在该复合命令中使用，那么实际上是不生效的，因为复合命令没有执行完，别名未被写入系统环境。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">alias&lt;/span> &lt;span class="nv">dog&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;echo &amp;#34;Here is a dog&amp;#34;&amp;#39;&lt;/span> &lt;span class="p">;&lt;/span> dog &lt;span class="c1"># 复合命令中定义别名，后面的命令无法使用别名&lt;/span>
&lt;span class="ln">2&lt;/span>-bash: dog: &lt;span class="nb">command&lt;/span> not found
&lt;span class="ln">3&lt;/span>$ dog &lt;span class="c1"># 当上一个复合命令执行完，别名才被写入系统&lt;/span>
&lt;span class="ln">4&lt;/span>Here is a dog
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个问题在函数中尤其明显，因为shell在函数定义阶段并不执行，只有当实际使用的时候才会执行函数内容，而shell的函数执行流程在不同版本软件（bash，csh，zsh，sh）中多少有些不同，因此为了安全起见，不要在复合命令中使用&lt;code>alias&lt;/code>。&lt;/p>
&lt;p>关于shell的别名还有两个细节问题。一是之前提到的别名的名称有限制，任何元字符、引号字符（‘'’,‘&amp;quot;’,‘\’）以及‘/’, ‘$’, ‘`’, ‘=’都不可以出现在别名名称中。二是在shell脚本中使用别名。别名默认只在交互式shell中启用，shell官方不赞成在脚本中使用别名，而希望使用Shell函数。&lt;/p>
&lt;h2 id="参考内容">参考内容&lt;/h2>
&lt;p>&lt;a href="https://www.gnu.org/software/bash/manual/bash.html">https://www.gnu.org/software/bash/manual/bash.html&lt;/a>&lt;/p></description></item><item><title>Shell 骨干流程0——流程总述</title><link>https://surprisedcat.github.io/projectnotes/shell-%E9%AA%A8%E5%B9%B2%E6%B5%81%E7%A8%8B0%E5%A4%A7%E4%BD%93%E6%B5%81%E7%A8%8B/</link><pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/shell-%E9%AA%A8%E5%B9%B2%E6%B5%81%E7%A8%8B0%E5%A4%A7%E4%BD%93%E6%B5%81%E7%A8%8B/</guid><description>
&lt;ul>
&lt;li>&lt;a href="#shell%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E4%B8%AD%E8%8B%B1%E6%96%87">shell关键概念中英文&lt;/a>&lt;/li>
&lt;li>&lt;a href="#shell%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%9B%BE">Shell处理流程图&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%A4%A7%E4%BD%93%E6%B5%81%E7%A8%8B">大体流程&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%BD%A2%E6%88%90%E5%88%9D%E6%AD%A5%E5%91%BD%E4%BB%A4">形成初步命令&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%A4%8D%E5%90%88%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">复合命令与流程控制&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%91%BD%E4%BB%A4%E5%B1%95%E5%BC%80">命令展开&lt;/a>&lt;/li>
&lt;li>&lt;a href="#io%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91">I/O与重定向&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B8%8Ejob%E6%8E%A7%E5%88%B6">命令执行与job控制&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%85%B7%E4%BD%93%E4%BE%8B%E5%AD%90">具体例子&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%82%E8%80%83%E5%86%85%E5%AE%B9">参考内容&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="shell-骨干流程---omit-in-toc---">Shell 骨干流程&lt;!-- omit in toc -->&lt;/h2>
&lt;p>我们在进行shell变成或使用CLI shell进行交互时，shell背后进行了复杂的处理流程。借由理清这个处理流程，会给我们对shell有更加深刻的认知。&lt;/p>
&lt;h2 id="shell关键概念中英文">shell关键概念中英文&lt;/h2>
&lt;p>为了更清楚的描述，我们给出如下shell中常用的中英文定义：&lt;/p>
&lt;ul>
&lt;li>blank：包含空格&lt;code>space&lt;/code>和制表符&lt;code>tab&lt;/code>&lt;/li>
&lt;li>control operator, 控制符：包含&lt;code>newline, '||', '&amp;amp;&amp;amp;', '&amp;amp;', ';', ';;', ';&amp;amp;', ';;&amp;amp;', '|', '|&amp;amp;', '(', ')'&lt;/code>&lt;/li>
&lt;li>field, 字段：shell扩展之一带来的文本单位。扩展后，当执行命令时，生成的字段将用作命令名称和参数&lt;/li>
&lt;li>job, 作业：在同一个进程组中的一系列进程，可由管道或衍生的进程组成&lt;/li>
&lt;li>job control, 作业控制：一种机制，用户可以通过该机制选择性地停止（挂起）并重新开始（恢复）进程的执行。&lt;/li>
&lt;li>metacharacter, 元字符：当不在引号中时，用于分割单词的字符，包括&lt;code>space, tab, newline, '|', '&amp;amp;', ';', '(', ')', '&amp;lt;', '&amp;gt;'&lt;/code>&lt;/li>
&lt;li>operator, 操作符：分为控制符或重定向符，操作符由至少一个元字符组成&lt;/li>
&lt;li>process group, 进程组：一系列具有相同组进程ID的进程&lt;/li>
&lt;li>reserved word, 保留字：对shell具有特殊含义的单词。，大多数保留字用于流程控制，如&lt;code>for, while, if&lt;/code>&lt;/li>
&lt;li>signal, 信号：一种机制，内核可以通过该机制将系统中发生的事件通知给进程&lt;/li>
&lt;li>token, 标记：可以被shell认为是一个独立单元的一串字符，分为单词word或操作符operator&lt;/li>
&lt;li>word, 单词：可以被shell认为是一个单元的一串字符，单词不能包括不带引号的元字符。&lt;/li>
&lt;/ul>
&lt;h2 id="shell处理流程图">Shell处理流程图&lt;/h2>
&lt;p>我们首先给出shell的执行流程图，接下针对每一个步骤进行详细说明。&lt;/p>
&lt;p>&lt;img src="../../images/shell%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.drawio.svg" alt="shell执行流程">&lt;/p>
&lt;h2 id="大体流程">大体流程&lt;/h2>
&lt;ol start="0">
&lt;li>从文件、用户终端或其他唤起&lt;code>shell&lt;/code>的方法中读取输入，通常&lt;code>shell&lt;/code>会按行处理，如果有复合命令和多行命令符号则另加处理步骤。&lt;/li>
&lt;li>根据元字符（&lt;code>space, tab, newline, '|', '&amp;amp;', ';', '(', ')', '&amp;lt;', '&amp;gt;'&lt;/code>）将输入的内容分割成各个标记（单词word或操作符operator），其中单词包括普通单词和保留字，操作符包括控制符或重定向符。&lt;/li>
&lt;li>检查第一个标记(token)是否为引号（包括单引号，双引号，反斜杠），如果有引号则跳过部分流程。（引号处理）&lt;/li>
&lt;li>检查第一个标记(token)是否为保留字（关键字），决定是否启用复合命令流程。（流程控制）。&lt;/li>
&lt;li>检查第一个标记(token)是否为别名（alias），如果是则展开别名。&lt;/li>
&lt;li>展开命令中的大括号。&lt;/li>
&lt;li>展开波浪符号，即得到HOME_PATH。&lt;/li>
&lt;li>参数展开，为&lt;code>${...}&lt;/code>的展开，以及&lt;code>$Varname&lt;/code>的替换。&lt;/li>
&lt;li>命令替换&amp;quot;``&amp;quot;或者&lt;code>$(...)&lt;/code>使用子shell执行。&lt;/li>
&lt;li>计算算术表达式。&lt;/li>
&lt;li>将之前展开的命令、替换的命令根据分隔符再一次切割，然后重组成真正可以执行的命令。&lt;/li>
&lt;li>根据通配符（&lt;code>*,?&lt;/code>）等展开路径名和文件名。&lt;/li>
&lt;li>根据重定向符号执行任何必要的重定向，之后参数列表中删除重定向运算符及其操作数。&lt;/li>
&lt;li>根据扩展后命令的首个单词在&lt;code>$PATH&lt;/code>和内建命令中查找可执行命令或文件。&lt;/li>
&lt;li>执行命令，其中首单词为命令用&lt;code>$0&lt;/code>表示，后面为此命令的参数。如果遇到文件结束符号EOF则完成shell流程，否则读取下一条命令从第1步再开始执行。&lt;/li>
&lt;/ol>
&lt;h2 id="形成初步命令">形成初步命令&lt;/h2>
&lt;p>我们将第1-4步分为第一大步，其主要作用是&lt;strong>形成初步命令&lt;/strong>。在流程图中为橙色部分，其主要处理流程为&lt;strong>元字符分割为标记、引号处理、shell命令解析、别名展开&lt;/strong>。具体内容见《&lt;strong>shell-骨干流程1——形成初步命令&lt;/strong>》。&lt;/p>
&lt;h2 id="复合命令与流程控制">复合命令与流程控制&lt;/h2>
&lt;p>这一步发生在第3步，即检查标记是否为保留字这步，如果为合法保留字就需要组成&lt;strong>复合命令&lt;/strong>。如图中红色部分所示。由于复合命令与形成初步命令往往是交互进行的，因此我并没有将其标注成独立的步骤，详见《&lt;strong>shell-骨干流程2——复合命令与流程控制&lt;/strong>》。&lt;/p>
&lt;h2 id="命令展开">命令展开&lt;/h2>
&lt;p>命令展开如图中绿色部分所示，包含5-11步。第5-7步都是各式各样的命令展开。基本的命令展开包括3种，分别为：大括号展开、波浪符号展开、参数与变量展开。这三种命令展开本质上是shell语法糖的展开。第8，9两步实际上是子命令执行，并非语法糖，原始命令将启动子进程（子shell）来执行子命令，执行的结果作为标记，嵌入到原命令中。5-7步和8-9步的区别在于，5-7步本质是查找语法糖对应的内容进行展开，无需使用子进程；8-9步本质是采纳子进程执行的结果，而非简单的查找替换。经过5-9步的处理，原始命令已经能够被shell直接执行，因此我们需要第10步将这些替换过后的内容重组起来，根据系统分隔符（Internal Field Seperator，IFS）再次分割（因为命令展开过程中会带来新的内容）。最后我们还需要第11步，展开路径和文件名，这一步和之前5-7步展开又是不同的，之前是语法糖替换，而这次是使用shell模式匹配方式（通配符）替换。第11步的shell模式匹配是正则表达式简化版，主要是利用通配符，并非完整的正则表达式规则。详见《&lt;strong>shell-骨干流程3——命令展开&lt;/strong>》。&lt;/p>
&lt;h2 id="io与重定向">I/O与重定向&lt;/h2>
&lt;p>第12部分（紫色方框）是执行任何必要的重定向，并从参数列表中删除重定向运算符及其操作数。这部分涉及到进程标准I/O和&lt;code>/dev&lt;/code>下的各种设备文件描述符，在文章《&lt;strong>linux-从设备文件看重定向&lt;/strong>》中有详细介绍。&lt;/p>
&lt;h2 id="命令执行与job控制">命令执行与job控制&lt;/h2>
&lt;p>第13，14步是真正的命令执行阶段。如图中蓝色部分所示。第13步是保证命令的存在及可执行性，在非复合命令中，首个单词（word）通常指的是需要执行的命令，后面的部分都是该命令的参数。最终在第14步执行命令+参数，并返回结果。如果存在未执行命令则读取下一条命令从头在开始处理，若遇到文件结束符（EOF）则完成shell流程。&lt;/p>
&lt;p>作业控制（job control）是针对即将执行和正在执行命令的一套控制机制，也是shell流程中不可缺少的一部分。命令执行与job控制部分详见《&lt;strong>shell-骨干流程4——命令执行与job控制&lt;/strong>》。&lt;/p>
&lt;h2 id="具体例子">具体例子&lt;/h2>
&lt;p>为了更好的理解整体流程，我们使用&lt;a href="https://se.ifmo.ru/~ad/Documentation/Bash_Shell/bash3-CHP-7-SECT-3.html">https://se.ifmo.ru/~ad/Documentation/Bash_Shell/bash3-CHP-7-SECT-3.html&lt;/a>中的例子对应上图中的步骤进一步讲解。&lt;/p>
&lt;ol start="0">
&lt;li>读取命令&lt;code>ll $(type -path cc) ~/.*$(($$%1000))&lt;/code>；&lt;/li>
&lt;li>将&lt;code>ll $(type -path cc) ~/.*$(($$%1000))&lt;/code>分割成不同的标记，此处分割为：&lt;code>ll, $, (, type, -path, cc, ), ~/.*, $, (, (, $$%1000, ), )&lt;/code>；&lt;/li>
&lt;li>命令中不含有引号，无操作；&lt;/li>
&lt;li>&lt;code>ll&lt;/code> 不是保留字，无操作;&lt;/li>
&lt;li>检测到&lt;code>ll&lt;/code>为别名，替换为&lt;code>ls -l&lt;/code>。&lt;code>ls -l $(type -path cc) ~/.*$(($$%1000))&lt;/code>，然后，从流程开始再执行一遍步骤1-3，在步骤1中将&lt;code>ls -l&lt;/code>再分割为&lt;code>ls, -l&lt;/code>两部分；&lt;/li>
&lt;li>不含有大括号，无操作；&lt;/li>
&lt;li>发现波浪符号，将&lt;code>~&lt;/code>展开为&lt;code>/home/username&lt;/code>，&lt;code>ls -l $(type -path cc) /home/username/.*$(($$%1000))&lt;/code>；&lt;/li>
&lt;li>发现&lt;code>$$&lt;/code>符号，将&lt;code>$$&lt;/code>参数展开为当前进程号2537（根据实际情况，进程号都不相同），且&lt;code>ls -l $(type -path cc) /home/username/.*$((2537%1000))&lt;/code>；&lt;/li>
&lt;li>发现&lt;code>$()&lt;/code>符号，执行命令替换，开启子shell执行&lt;code>type -path cc&lt;/code>，结果为&lt;code>/usr/bin/cc&lt;/code>，&lt;code>ls -l /usr/bin/cc /home/username/.*$((2537%1000))&lt;/code>；&lt;/li>
&lt;li>发现&lt;code>$(( ))&lt;/code>算数运算符号，进行算术运算2537%1000=537，代入原命令：&lt;code>ls -l /usr/bin/cc /home/username/.*537&lt;/code>；&lt;/li>
&lt;li>未发现新的分隔符（IFS），无需进行再分割，无操作；&lt;/li>
&lt;li>发现通配符&amp;quot;*&amp;quot;，进行展开得到&lt;code>.hist537&lt;/code>文件，&lt;code>ls -l /usr/bin/cc /home/username/.hist537&lt;/code>；&lt;/li>
&lt;li>未发现重定向操作符，无操作；&lt;/li>
&lt;li>首个单词为“ls”，在&lt;code>$PATH，/usr/bin&lt;/code>中检索到&lt;code>ls&lt;/code>命令；&lt;/li>
&lt;li>执行命令&lt;code>/usr/bin/ls&lt;/code>，后面的&lt;code>-l /usr/bin/cc /home/username/.hist537&lt;/code>为命令的参数，其作用为查看&lt;code>/usr/bin/cc /home/username/.hist537&lt;/code>这两个文件的详细属性。此命令后不再有其他命令，结束此shell流程。&lt;/li>
&lt;/ol>
&lt;h2 id="参考内容">参考内容&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://se.ifmo.ru/~ad/Documentation/Bash_Shell/bash3-CHP-7-SECT-3.html">https://se.ifmo.ru/~ad/Documentation/Bash_Shell/bash3-CHP-7-SECT-3.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Operation.html">https://www.gnu.org/software/bash/manual/html_node/Shell-Operation.html&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>shell-shopt选项</title><link>https://surprisedcat.github.io/projectnotes/shell-shopt%E9%80%89%E9%A1%B9/</link><pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/shell-shopt%E9%80%89%E9%A1%B9/</guid><description>
&lt;ul>
&lt;li>&lt;a href="#shopt%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8">shopt命令使用&lt;/a>&lt;/li>
&lt;li>&lt;a href="#shopt%E6%94%AF%E6%8C%81%E7%9A%84shell%E5%B1%9E%E6%80%A7%E5%8A%9F%E8%83%BD">shopt支持的shell属性功能&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%82%E8%80%83%E5%86%85%E5%AE%B9">参考内容&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="shell的shopt命令---omit-in-toc---">shell的shopt命令&lt;!-- omit in toc -->&lt;/h2>
&lt;p>&lt;code>shopt&lt;/code>命令在shell中用于显示和设置shell中的行为选项，通过这些选项以增强shell易用性。&lt;code>shopt&lt;/code>命令若不带任何参数选项，则可以显示所有可以设置的shell操作选项。&lt;/p>
&lt;h2 id="shopt命令使用">shopt命令使用&lt;/h2>
&lt;p>语法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">shopt&lt;/span> &lt;span class="o">[&lt;/span>-pqsu&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-o&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>shell选项名 ...&lt;span class="o">]&lt;/span>
&lt;span class="ln">2&lt;/span>参数：
&lt;span class="ln">3&lt;/span> -o 限制 OPTNAME 为定义用于&lt;span class="sb">`&lt;/span>&lt;span class="nb">set&lt;/span> -o&lt;span class="err">&amp;#39;&lt;/span> 的选项
&lt;span class="ln">4&lt;/span> -p 打印每个 shell 选项并标注它的状态。（）
&lt;span class="ln">5&lt;/span> -q 抑制输出
&lt;span class="ln">6&lt;/span> -s 启用（设定）某个 OPTNAME 选项
&lt;span class="ln">7&lt;/span> -u 禁用（反设定）某个 OPTNAME 选项
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ &lt;span class="nb">shopt&lt;/span>
&lt;span class="ln"> 2&lt;/span>autocd off
&lt;span class="ln"> 3&lt;/span>assoc_expand_once off
&lt;span class="ln"> 4&lt;/span>cdable_vars off
&lt;span class="ln"> 5&lt;/span>cdspell off
&lt;span class="ln"> 6&lt;/span>checkhash off
&lt;span class="ln"> 7&lt;/span>checkjobs off
&lt;span class="ln"> 8&lt;/span>checkwinsize on
&lt;span class="ln"> 9&lt;/span>cmdhist on
&lt;span class="ln">10&lt;/span>compat31 off
&lt;span class="ln">11&lt;/span>compat32 off
&lt;span class="ln">12&lt;/span>compat40 off
&lt;span class="ln">13&lt;/span>compat41 off
&lt;span class="ln">14&lt;/span>compat42 off
&lt;span class="ln">15&lt;/span>compat43 off
&lt;span class="ln">16&lt;/span>compat44 off
&lt;span class="ln">17&lt;/span>complete_fullquote on
&lt;span class="ln">18&lt;/span>direxpand off
&lt;span class="ln">19&lt;/span>dirspell off
&lt;span class="ln">20&lt;/span>dotglob off
&lt;span class="ln">21&lt;/span>execfail off
&lt;span class="ln">22&lt;/span>expand_aliases on
&lt;span class="ln">23&lt;/span>extdebug off
&lt;span class="ln">24&lt;/span>extglob on
&lt;span class="ln">25&lt;/span>extquote on
&lt;span class="ln">26&lt;/span>failglob off
&lt;span class="ln">27&lt;/span>force_fignore on
&lt;span class="ln">28&lt;/span>globasciiranges on
&lt;span class="ln">29&lt;/span>globstar off
&lt;span class="ln">30&lt;/span>gnu_errfmt off
&lt;span class="ln">31&lt;/span>histappend on
&lt;span class="ln">32&lt;/span>histreedit off
&lt;span class="ln">33&lt;/span>histverify off
&lt;span class="ln">34&lt;/span>hostcomplete off
&lt;span class="ln">35&lt;/span>huponexit off
&lt;span class="ln">36&lt;/span>inherit_errexit off
&lt;span class="ln">37&lt;/span>interactive_comments on
&lt;span class="ln">38&lt;/span>lastpipe off
&lt;span class="ln">39&lt;/span>lithist off
&lt;span class="ln">40&lt;/span>localvar_inherit off
&lt;span class="ln">41&lt;/span>localvar_unset off
&lt;span class="ln">42&lt;/span>login_shell on
&lt;span class="ln">43&lt;/span>mailwarn off
&lt;span class="ln">44&lt;/span>no_empty_cmd_completion off
&lt;span class="ln">45&lt;/span>nocaseglob off
&lt;span class="ln">46&lt;/span>nocasematch off
&lt;span class="ln">47&lt;/span>nullglob off
&lt;span class="ln">48&lt;/span>progcomp on
&lt;span class="ln">49&lt;/span>progcomp_alias off
&lt;span class="ln">50&lt;/span>promptvars on
&lt;span class="ln">51&lt;/span>restricted_shell off
&lt;span class="ln">52&lt;/span>shift_verbose off
&lt;span class="ln">53&lt;/span>sourcepath on
&lt;span class="ln">54&lt;/span>xpg_echo off
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="shopt支持的shell属性功能">shopt支持的shell属性功能&lt;/h2>
&lt;p>cdable_vars:&lt;/p>
&lt;p>如果给cd内置命令的参数不是一个目录,就假设它是一个变量名,变量的值是将要转换到的目录&lt;/p>
&lt;p>cdspell:&lt;/p>
&lt;p>纠正cd命令中目录名的较小拼写错误.检查的错误包括颠倒顺序的字符,遗漏的字符以及重复的字符.如果找到一处需修改之处,正确的路径将打印出,命令将继续.只用于交互式shell&lt;/p>
&lt;p>checkhash:&lt;/p>
&lt;p>bash在试图执行一个命令前,先在哈希表中寻找,以确定命令是否存在.如果命令不存在,就执行正常的路径搜索&lt;/p>
&lt;p>checkwinsize:&lt;/p>
&lt;p>bash在每个命令后检查窗口大小,如果有必要,就更新LINES和COLUMNS的值&lt;/p>
&lt;p>cmdhist:&lt;/p>
&lt;p>bash试图将一个多行命令的所有行保存在同一个历史项中.这是的多行命令的重新编辑更方便&lt;/p>
&lt;p>dotglob:&lt;/p>
&lt;p>Bash在文件名扩展的结果中包括以点(.)开头的文件名&lt;/p>
&lt;p>execfail:&lt;/p>
&lt;p>如果一个非交互式shell不能执行指定给exec内置命令作为参数的文件,它不会退出.如果exec失败,一个交互式shell不会退出&lt;/p>
&lt;p>expand_aliases:&lt;/p>
&lt;p>别名被扩展.缺省为打开&lt;/p>
&lt;p>extglob:&lt;/p>
&lt;p>打开扩展的模式匹配特性(正常的表达式元字符来自Korn shell的文件名扩展)&lt;/p>
&lt;p>histappend:&lt;/p>
&lt;p>如果readline正被使用,用户有机会重新编辑一个失败的历史替换&lt;/p>
&lt;p>histverify:&lt;/p>
&lt;p>如果设置,且readline正被使用,历史替换的结果不会立即传递给shell解释器.而是将结果行装入readline编辑缓冲区中,允许进一步修改&lt;/p>
&lt;p>hostcomplete:&lt;/p>
&lt;p>如果设置,且readline正被使用,当正在完成一个包含@的词时bash将试图执行主机名补全.缺省为打开&lt;/p>
&lt;p>huponexit:&lt;/p>
&lt;p>如果设置,当一个交互式登录shell退出时,bash将发送一个SIGHUP(挂起信号)给所有的作业&lt;/p>
&lt;p>interactive_comments:&lt;/p>
&lt;p>在一个交互式shell中.允许以#开头的词以及同一行中其他的字符被忽略.缺省为打开&lt;/p>
&lt;p>lithist:&lt;/p>
&lt;p>如果打开,且cmdhist选项也打开,多行命令讲用嵌入的换行符保存到历史中,而无需在可能的地方用分号来分隔&lt;/p>
&lt;p>mailwarn:&lt;/p>
&lt;p>如果设置,且bash用来检查邮件的文件自从上次检查后已经被访问,将显示消息”The mail in mailfile has been read”&lt;/p>
&lt;p>nocaseglob:&lt;/p>
&lt;p>如果设置,当执行文件名扩展时,bash在不区分大小写的方式下匹配文件名&lt;/p>
&lt;p>nullglob：&lt;/p>
&lt;p>如果设置,bash允许没有匹配任何文件的文件名模式扩展成一个空串,而不是他们本身&lt;/p>
&lt;p>promptvars:&lt;/p>
&lt;p>如果设置,提示串在被扩展后再进行变量和参量扩展.缺省为打开&lt;/p>
&lt;p>restricted_shell :&lt;/p>
&lt;p>如果shell在受限模式下启动就设置这个选项.该值不能被改变.当执行启动文件时不能复位该选项,允许启动文件发现shell是否受限&lt;/p>
&lt;p>shift_verbose :&lt;/p>
&lt;p>如果该选项设置,当移动计数超出位置参量个数时,shift内置命令将打印一个错误消息&lt;/p>
&lt;p>sourcepath :&lt;/p>
&lt;p>如果设置,source内置命令使用PATH的值来寻找作为参数提供的文件的目录.缺省为打开&lt;/p>
&lt;p>source :&lt;/p>
&lt;p>点(.)的同义词&lt;/p>
&lt;h2 id="参考内容">参考内容&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/dengjin20104042056/article/details/100566309">https://blog.csdn.net/dengjin20104042056/article/details/100566309&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>linux-管道pipe与xargs</title><link>https://surprisedcat.github.io/projectnotes/linux-%E7%AE%A1%E9%81%93pipe%E4%B8%8Exargs/</link><pubDate>Wed, 24 Nov 2021 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/linux-%E7%AE%A1%E9%81%93pipe%E4%B8%8Exargs/</guid><description>
&lt;ul>
&lt;li>&lt;a href="#%E7%AE%A1%E9%81%93pipe">管道——Pipe&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%AE%A1%E9%81%93%E5%91%BD%E4%BB%A4">管道命令&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%82%E6%95%B0%E4%BB%A3%E6%8D%A2xargs">参数代换——&lt;code>xargs&lt;/code>&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%E5%8C%BA%E5%88%86%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E5%92%8C%E5%8F%82%E6%95%B0">区分标准输入和参数&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%E5%85%B3%E4%BA%8E%E5%87%8F%E5%8F%B7-%E7%9A%84%E7%94%A8%E9%80%94">关于减号“-”的用途&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%82%E8%80%83%E5%86%85%E5%AE%B9">参考内容&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="linux-管道pipe与xargs---omit-in-toc---">linux-管道pipe与xargs&lt;!-- omit in toc -->&lt;/h2>
&lt;p>Linux CLI shell（如bash，zsh）通常情况下都是每输入一条指令，输出一个结果，一来一回的交互，但是有的时候一条指令的输出是冗长且繁杂的，我们需要对其输出进行再处理，才能找到我们需要的内容。此时，我们就需要像筛金子一样，逐层过滤掉无用的沙子，Linux提供了这样的筛子——&lt;strong>管道&lt;/strong>，使我们能够接续处理数据。&lt;/p>
&lt;h2 id="管道pipe">管道——Pipe&lt;/h2>
&lt;blockquote>
&lt;p>管道（Pipeline）操作符为“|”，是一系列将&lt;strong>标准输入输出链接起来&lt;/strong>的进程，其中每一个进程的输出被直接作为下一个进程的输入。管道中的组成元素也被称作过滤程序。这个概念是由道格拉斯·麦克罗伊为Unix 命令行发明的，因与物理上的管道相似而得名。&lt;/p>
&lt;/blockquote>
&lt;p>这是来自Wikipedia的定义。定义中指出，默认情况下，管道只会将上一个程序的标准输出(stdout)，传递给下一个命令，作为标准的输入(stdin)，对标准错误(stderr)信息没有直接处理能力。最后的命令将会把标准输出和标准错误都输出到屏幕上。画个简图来描述他们的关系：&lt;/p>
&lt;p>&lt;img src="../../images/%E7%AE%A1%E9%81%93%E5%91%BD%E4%BB%A4%E7%A4%BA%E6%84%8F%E5%9B%BE.drawio.svg" alt="管道命令示意图">&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ol>
&lt;li>管道命令只处理前一个命令正确输出，不处理错误输出。&lt;/li>
&lt;li>管道命令右边命令，必须能够接收标准输入流命令才行。&lt;/li>
&lt;li>管道触发两个子进程分别执行&amp;quot;|&amp;quot;两边的程序；而重定向是在一个进程内执行。&lt;/li>
&lt;li>如果使用&lt;code>|&amp;amp;&lt;/code>，则表示命令1的标准错误和标准输出都作为命令2的标准输入，这是&lt;code>2&amp;gt;&amp;amp;1 |&lt;/code>的简写。&lt;/li>
&lt;/ol>
&lt;h2 id="管道命令">管道命令&lt;/h2>
&lt;p>管道需要搭配&lt;strong>管道命令&lt;/strong>来使用，除了最开始的命令，在管道右边的命令，&lt;strong>必须能够接收标准输入流&lt;/strong>命令才行。以下这些命令就是常用的管道命令：&lt;/p>
&lt;ul>
&lt;li>撷取命令： cut, grep&lt;/li>
&lt;li>排序命令： sort, uniq, wc&lt;/li>
&lt;li>双向重导向： tee&lt;/li>
&lt;li>字符转换命令： tr, col, join, paste, expand&lt;/li>
&lt;li>分割命令： split&lt;/li>
&lt;li>文本查看： cat, tac, more, less, head, tail&lt;/li>
&lt;li>文本比较： diff&lt;/li>
&lt;li>流文本处理： sed, awk&lt;/li>
&lt;li>参数代换： xargs&lt;/li>
&lt;/ul>
&lt;p>我们不鼓励现在就了解这些命令的具体用途，因为这样学习是枯燥且低效的。我们更鼓励只有当实际用到的时候再去查找这些命令的用法。&lt;/p>
&lt;h2 id="参数代换xargs">参数代换——&lt;code>xargs&lt;/code>&lt;/h2>
&lt;p>上面这些命令中，有一个需要单独拎出来强调下，就是参数代换——&lt;code>xargs&lt;/code>。它的运作方式有少许不同，一般的管道命令都是把上一个命令的标准输出作为本命令的标准输入；而&lt;code>xargs&lt;/code>可以将来自管道的输出、标准输入或文件数据转换成&lt;strong>命令行参数&lt;/strong>。&lt;/p>
&lt;p>我们先举个例子，看看&lt;code>xargs&lt;/code>带来的区别：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1"># xargstest目录下有一个test.txt文件&lt;/span>
&lt;span class="ln"> 2&lt;/span>$ tree xargstest/
&lt;span class="ln"> 3&lt;/span>xargstest/
&lt;span class="ln"> 4&lt;/span>└── test.txt
&lt;span class="ln"> 5&lt;/span>&lt;span class="m">0&lt;/span> directories, &lt;span class="m">1&lt;/span> file
&lt;span class="ln"> 6&lt;/span>$ &lt;span class="nb">cd&lt;/span> xargstest/
&lt;span class="ln"> 7&lt;/span>&lt;span class="c1"># 直接使用管道命令&lt;/span>
&lt;span class="ln"> 8&lt;/span>$ ls &lt;span class="p">|&lt;/span> cat
&lt;span class="ln"> 9&lt;/span>test.txt
&lt;span class="ln">10&lt;/span>&lt;span class="c1"># xargs下的管道命令&lt;/span>
&lt;span class="ln">11&lt;/span>$ ls &lt;span class="p">|&lt;/span> xargs cat
&lt;span class="ln">12&lt;/span>测试文件
&lt;span class="ln">13&lt;/span>xargs的区别实例
&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先，我们在&lt;code>xargstest/&lt;/code>目录下使用&lt;code>ls&lt;/code>命令，结果是显示其目录下的文件&lt;code>test.txt&lt;/code>，也就是说标准输出(stdout)是&lt;code>&amp;quot;test.txt&amp;quot;&lt;/code>。当我们直接使用管道命令&lt;code>ls | cat&lt;/code>时，标准输出&lt;code>&amp;quot;test.txt&amp;quot;&lt;/code>作为&lt;code>cat&lt;/code>的标准输入(stdin)，因此&lt;code>cat&lt;/code>的输出结果就是显示标准输入的内容，即&lt;code>&amp;quot;test.txt&amp;quot;&lt;/code>。当我们使用参数代换&lt;code>xargs&lt;/code>时，前一个命令&lt;code>ls&lt;/code>的标准输出作为&lt;strong>参数&lt;/strong>传递给&lt;code>cat&lt;/code>，而非标准输入，后一个命令在执行时，实际执行的命令是&lt;code>cat test.txt&lt;/code>，因此最终结果是显示&lt;code>test.txt&lt;/code>文件中的内容。&lt;/p>
&lt;p>一句话总结：&lt;strong>xargs命令的作用，是将标准输入转为命令行参数&lt;/strong>。&lt;/p>
&lt;h3 id="区分标准输入和参数">区分标准输入和参数&lt;/h3>
&lt;p>大多数时候，&lt;code>xargs&lt;/code>命令都是跟管道一起使用的。为了进一步区分标准输入和参数，我们可以看看在&lt;strong>不使用管道时&lt;code>xargs&lt;/code>的效果&lt;/strong>。通常境况下，&lt;code>xargs&lt;/code>后面跟一个Linux shell命令，来自标准输入的内容都会是该命令的参数。如果我们单独使用&lt;code>xargs&lt;/code>，就会使用默认命令&lt;code>echo&lt;/code>，即&lt;code>xargs == xargs echo&lt;/code>。当我们直接执行&lt;code>xargs&lt;/code>后，会出现空行让我们随意输入内容，我们从键盘输入的内容就是&lt;strong>标准输入&lt;/strong>，直到我们使用&lt;code>ctrl+d&lt;/code>或者在一行仅输入“End of File”标志（使用&lt;code>-E&lt;/code>参数指定）。然后，&lt;code>echo&lt;/code>命令就会把前面的输入打印出来。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ xargs
&lt;span class="ln">2&lt;/span>xargs测试 &lt;span class="c1"># 按Ctrl + d&lt;/span>
&lt;span class="ln">3&lt;/span>xargs测试 &lt;span class="c1"># 输出内容&lt;/span>
&lt;span class="ln">4&lt;/span>$ xargs -E EOF &lt;span class="c1"># 指定结束符为EOF&lt;/span>
&lt;span class="ln">5&lt;/span>xargs测试
&lt;span class="ln">6&lt;/span>EOF
&lt;span class="ln">7&lt;/span>xargs测试 &lt;span class="c1"># 输出内容&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看出&lt;code>xargs + stdin == echo 'stdin'&lt;/code>，注意这里我用单引号，表示&lt;code>stdin&lt;/code>内容作为&lt;code>echo&lt;/code>的参数被执行时是直接输出，不用转义。这就是所说的&lt;code>xargs&lt;/code>将标准输入转为命令行参数。如果不好理解，我们再举个使用其他命令的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ xargs touch &lt;span class="c1"># 打算创建一个文件，文件名由键盘输入&lt;/span>
&lt;span class="ln">2&lt;/span>newfile.txt &lt;span class="c1"># 按Ctrl + d&lt;/span>
&lt;span class="ln">3&lt;/span>$ ls -l newfile.txt
&lt;span class="ln">4&lt;/span>-rw-rw-r-- &lt;span class="m">1&lt;/span> username username &lt;span class="m">0&lt;/span> Nov &lt;span class="m">24&lt;/span> 00:43 newfile.txt &lt;span class="c1"># 确实创建了此文件&lt;/span>
&lt;span class="ln">5&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;newfile.txt&amp;#39;&lt;/span> &lt;span class="p">|&lt;/span> xargs -t rm &lt;span class="c1">#我们可以使用-t参数，显示xargs实际执行的命令。&lt;/span>
&lt;span class="ln">6&lt;/span>rm newfile.txt
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个例子中，来自键盘的标准输入作为&lt;code>touch&lt;/code>命令的参数，决定了被新建文件的名称，等同于&lt;code>touch newfile.txt&lt;/code>。参数都是跟在命令后面的，比如&lt;code>touch&lt;/code>是&lt;code>xargs&lt;/code>的参数，&lt;code>touch newfile.txt&lt;/code>中&lt;code>newfile.txt&lt;/code>是&lt;code>touch&lt;/code>的参数。而标准输入是独立于命令存在的，由用户决定其内容，通常是命令执行后，等待用户提供的，比如执行&lt;code>xargs&lt;/code>命令后，等待来自用户键盘的输入内容。&lt;/p>
&lt;p>其他&lt;code>xargs&lt;/code>命令的参数，可以参考其&lt;a href="https://man7.org/linux/man-pages/man1/xargs.1.html">&lt;code>man&lt;/code>帮助页面&lt;/a>。&lt;/p>
&lt;h2 id="关于减号-的用途">关于减号“-”的用途&lt;/h2>
&lt;p>减号“-”在shell脚本中根据使用上下文的不同，有不同的含义。在管道语境下，减号“-”代表着&lt;strong>标准输入或标准输出&lt;/strong>，用来&lt;strong>代替某个文件名参数&lt;/strong>（在非管道语境下，也可以表示标准输入或标准输出）。需要指出，并不是所有命令都支持减号“-”。&lt;/p>
&lt;p>我们先举个做为&lt;strong>标准输出&lt;/strong>的例子。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="c1"># 默认情况下，此命令会下载一个名为docker的文件，此为安装docker容器的脚本&lt;/span>
&lt;span class="ln"> 2&lt;/span>$ wget https://get.daocloud.io/docker
&lt;span class="ln"> 3&lt;/span>--2021-11-24 09:22:21-- https://get.daocloud.io/docker
&lt;span class="ln"> 4&lt;/span>Resolving get.daocloud.io &lt;span class="o">(&lt;/span>get.daocloud.io&lt;span class="o">)&lt;/span>... 106.75.86.15
&lt;span class="ln"> 5&lt;/span>...... &lt;span class="c1"># 中间省略&lt;/span>
&lt;span class="ln"> 6&lt;/span>HTTP request sent, awaiting response... &lt;span class="m">200&lt;/span> OK
&lt;span class="ln"> 7&lt;/span>Length: &lt;span class="m">18617&lt;/span> &lt;span class="o">(&lt;/span>18K&lt;span class="o">)&lt;/span> &lt;span class="o">[&lt;/span>None&lt;span class="o">]&lt;/span>
&lt;span class="ln"> 8&lt;/span>Saving to: ‘docker’ &lt;span class="c1"># 注意这里就是保存到文件&lt;/span>
&lt;span class="ln"> 9&lt;/span>
&lt;span class="ln">10&lt;/span>docker 100%&lt;span class="o">[=============================================================&lt;/span>&amp;gt;&lt;span class="o">]&lt;/span> 18.18K --.-KB/s in 0.03s
&lt;span class="ln">11&lt;/span>
&lt;span class="ln">12&lt;/span>2021-11-24 09:22:21 &lt;span class="o">(&lt;/span>&lt;span class="m">566&lt;/span> KB/s&lt;span class="o">)&lt;/span> - ‘docker’ saved &lt;span class="o">[&lt;/span>18617/18617&lt;span class="o">]&lt;/span>
&lt;span class="ln">13&lt;/span>$ ls -l docker
&lt;span class="ln">14&lt;/span>-rw-r--r-- &lt;span class="m">1&lt;/span> username username &lt;span class="m">18617&lt;/span> Nov &lt;span class="m">24&lt;/span> 09:22 docker
&lt;span class="ln">15&lt;/span>&lt;span class="c1"># 当我们加上参数&amp;#34;-O&amp;#34;表示目标位置，通常情况下为文件名&lt;/span>
&lt;span class="ln">16&lt;/span>&lt;span class="c1"># 我们可使用&amp;#34;-O -&amp;#34;将下载的内容直接输出到标准输出（屏幕），而非文件&lt;/span>
&lt;span class="ln">17&lt;/span>$ wget https://get.daocloud.io/docker -O -
&lt;span class="ln">18&lt;/span>--2021-11-24 10:03:50-- https://get.daocloud.io/docker
&lt;span class="ln">19&lt;/span>Resolving get.daocloud.io &lt;span class="o">(&lt;/span>get.daocloud.io&lt;span class="o">)&lt;/span>... 106.75.86.15
&lt;span class="ln">20&lt;/span>...... &lt;span class="c1"># 中间省略&lt;/span>
&lt;span class="ln">21&lt;/span>HTTP request sent, awaiting response... &lt;span class="m">200&lt;/span> OK
&lt;span class="ln">22&lt;/span>Length: &lt;span class="m">18617&lt;/span> &lt;span class="o">(&lt;/span>18K&lt;span class="o">)&lt;/span> &lt;span class="o">[&lt;/span>None&lt;span class="o">]&lt;/span>
&lt;span class="ln">23&lt;/span>Saving to: ‘STDOUT’ &lt;span class="c1"># 注意这里就是保存到标准输出，实际效果为输出到屏幕&lt;/span>
&lt;span class="ln">24&lt;/span>
&lt;span class="ln">25&lt;/span>- 0%&lt;span class="o">[&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="m">0&lt;/span> --.-KB/s &lt;span class="c1">#!/bin/sh&lt;/span>
&lt;span class="ln">26&lt;/span>&lt;span class="nb">set&lt;/span> -e
&lt;span class="ln">27&lt;/span>&lt;span class="c1"># Docker CE for Linux installation script&lt;/span>
&lt;span class="ln">28&lt;/span>&lt;span class="c1">#&lt;/span>
&lt;span class="ln">29&lt;/span>&lt;span class="c1"># See https://docs.docker.com/engine/install/ for the installation steps.&lt;/span>
&lt;span class="ln">30&lt;/span>&lt;span class="c1">#&lt;/span>
&lt;span class="ln">31&lt;/span>...... &lt;span class="c1"># 中间省略&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;ERROR: Unsupported distribution &amp;#39;&lt;/span>&lt;span class="nv">$lsb_dist&lt;/span>&lt;span class="s2">&amp;#39;&amp;#34;&lt;/span>
&lt;span class="ln">33&lt;/span> &lt;span class="nb">echo&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="nb">exit&lt;/span> &lt;span class="m">1&lt;/span>
&lt;span class="ln">35&lt;/span> &lt;span class="p">;;&lt;/span>
&lt;span class="ln">36&lt;/span> &lt;span class="k">esac&lt;/span>
&lt;span class="ln">37&lt;/span> &lt;span class="nb">exit&lt;/span> &lt;span class="m">1&lt;/span>
&lt;span class="ln">38&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">39&lt;/span>
&lt;span class="ln">40&lt;/span>&lt;span class="c1"># wrapped up in a function so that we have some protection against only getting&lt;/span>
&lt;span class="ln">41&lt;/span>&lt;span class="c1"># half the file during &amp;#34;curl | sh&amp;#34;&lt;/span>
&lt;span class="ln">42&lt;/span>do_install
&lt;span class="ln">43&lt;/span>- 100%&lt;span class="o">[=============================================================&lt;/span>&amp;gt;&lt;span class="o">]&lt;/span> 18.18K --.-KB/s in 0.03s
&lt;span class="ln">44&lt;/span>
&lt;span class="ln">45&lt;/span>2022-01-05 10:03:51 &lt;span class="o">(&lt;/span>&lt;span class="m">684&lt;/span> KB/s&lt;span class="o">)&lt;/span> - written to stdout &lt;span class="o">[&lt;/span>18617/18617&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里我们使用减号“-”代替“-O”参数指向的文件名，来表示将下载的内容发到标准输出。此时相当于只是在屏幕中输出文件内容，并非下载文件。&lt;/p>
&lt;p>而将减号“-”用于标准输入，不仅需要命令的支持，还需要命令能够从标准输入接收参数。典型的例子是&lt;code>diff&lt;/code>命令。例子如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>$ &lt;span class="nb">echo&lt;/span> -e &lt;span class="s2">&amp;#34;line 1 \nline 2\nline 3&amp;#34;&lt;/span> &amp;gt; minus_1.txt
&lt;span class="ln"> 2&lt;/span>$ cat minus_1.txt
&lt;span class="ln"> 3&lt;/span>line &lt;span class="m">1&lt;/span>
&lt;span class="ln"> 4&lt;/span>line &lt;span class="m">2&lt;/span>
&lt;span class="ln"> 5&lt;/span>line &lt;span class="m">3&lt;/span>
&lt;span class="ln"> 6&lt;/span>$ diff - minus_1.txt &lt;span class="c1"># - 表示会从标准输入（键盘）接收内容&lt;/span>
&lt;span class="ln"> 7&lt;/span>line &lt;span class="m">1&lt;/span>
&lt;span class="ln"> 8&lt;/span>line &lt;span class="m">2&lt;/span> changed
&lt;span class="ln"> 9&lt;/span>line &lt;span class="m">3&lt;/span> &lt;span class="c1"># 这里按ctrl+d&lt;/span>
&lt;span class="ln">10&lt;/span>1,2c1,2
&lt;span class="ln">11&lt;/span>&amp;lt; line &lt;span class="m">1&lt;/span>
&lt;span class="ln">12&lt;/span>&amp;lt; line &lt;span class="m">2&lt;/span> changed
&lt;span class="ln">13&lt;/span>---
&lt;span class="ln">14&lt;/span>&amp;gt; line &lt;span class="m">1&lt;/span>
&lt;span class="ln">15&lt;/span>&amp;gt; line &lt;span class="m">2&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们生成了一个三行的文件&lt;code>minus_1.txt&lt;/code>，然后使用&lt;code>diff - minus_1.txt&lt;/code>让从键盘输入的内容和文件内容比较。&lt;/p>
&lt;p>知道了减号作为标准输入输出的用法，我们就可以把它运用到管道中，在管道左边的命令中，减号可以代表标准输出；在管道右边的命令中，减号代表标准输入。例子如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># 将/var/log中的文件打包并压缩为log.zip&lt;/span>
&lt;span class="ln">2&lt;/span>tar -cvPf - /var/log &lt;span class="p">|&lt;/span> zip -r log.zip -
&lt;/code>&lt;/pre>&lt;/div>&lt;p>管道左边的第一条语句不再输入到具体文件，而输出到stdout中， 而作为第二条件的标准输入(stdin), 而stdin和 stdout都可以用“-”来取代。其实际效果等同于：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># 将/var/log/中的文件打包到中间文件log.tar&lt;/span>
&lt;span class="ln">2&lt;/span>$ tar -cvPf log.tar /var/log/
&lt;span class="ln">3&lt;/span>&lt;span class="c1"># zip压缩log.tar为log.tar.zip&lt;/span>
&lt;span class="ln">4&lt;/span>$ zip -r log.tar.zip log.tar
&lt;span class="ln">5&lt;/span>&lt;span class="c1"># 删除中间文件log.tar&lt;/span>
&lt;span class="ln">6&lt;/span>$ rm -rf log.tar
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用减号不仅使命令更加简洁，也避免生成中间文件&lt;code>log.tar&lt;/code>。&lt;/p>
&lt;h2 id="参考内容">参考内容&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.cnblogs.com/ggjucheng/archive/2012/10/24/2737918.html">https://www.cnblogs.com/ggjucheng/archive/2012/10/24/2737918.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/chengmo/archive/2010/10/21/1856577.html">https://www.cnblogs.com/chengmo/archive/2010/10/21/1856577.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://cn.linux.vbird.org/linux_basic/0320bash_6.php#pipe_7">http://cn.linux.vbird.org/linux_basic/0320bash_6.php#pipe_7&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Shell 概要</title><link>https://surprisedcat.github.io/projectnotes/shell-%E6%A6%82%E8%A6%81/</link><pubDate>Fri, 19 Nov 2021 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/shell-%E6%A6%82%E8%A6%81/</guid><description>
&lt;ul>
&lt;li>&lt;a href="#shell%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E4%B8%AD%E8%8B%B1%E6%96%87">shell关键概念中英文&lt;/a>&lt;/li>
&lt;li>&lt;a href="#shell%E8%84%9A%E6%9C%AC%E7%9A%84%E7%AC%AC%E4%B8%80%E8%A1%8C">shell脚本的第一行&lt;/a>&lt;/li>
&lt;li>&lt;a href="#shell%E8%84%9A%E6%9C%AC%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%A6">shell脚本的重定向符&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7">一些特殊符号&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%98%E9%87%8F">变量&lt;/a>&lt;/li>
&lt;li>&lt;a href="#path%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8">PATH路径中:的作用&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E8%AE%BF%E9%97%AEshell%E7%9A%84%E7%9A%84%E5%8F%82%E6%95%B0">访问Shell的的参数&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%AE%80%E5%8D%95%E7%9A%84%E5%91%BD%E4%BB%A4%E8%B7%9F%E8%B8%AA">简单的命令跟踪&lt;/a>&lt;/li>
&lt;li>&lt;a href="#shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84">shell脚本中的“.”&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="shell-概述---omit-in-toc---">Shell 概述&lt;!-- omit in toc -->&lt;/h2>
&lt;h2 id="shell关键概念中英文">shell关键概念中英文&lt;/h2>
&lt;ul>
&lt;li>blank：包含空格&lt;code>space&lt;/code>和制表符&lt;code>tab&lt;/code>&lt;/li>
&lt;li>control operator, 控制符：包含&lt;code>newline, '||', '&amp;amp;&amp;amp;', '&amp;amp;', ';', ';;', ';&amp;amp;', ';;&amp;amp;', '|', '|&amp;amp;', '(', ')'&lt;/code>&lt;/li>
&lt;li>field, 字段：shell扩展之一带来的文本单位。扩展后，当执行命令时，生成的字段将用作命令名称和参数&lt;/li>
&lt;li>job, 作业：在同一个进程组中的一系列进程，可由管道或衍生的进程组成&lt;/li>
&lt;li>job control, 作业控制：一种机制，用户可以通过该机制选择性地停止（挂起）并重新开始（恢复）进程的执行。&lt;/li>
&lt;li>metacharacter, 元字符：当不在引号中时，用于分割单词的字符，包括&lt;code>space, tab, newline, '|', '&amp;amp;', ';', '(', ')', '&amp;lt;', '&amp;gt;'&lt;/code>&lt;/li>
&lt;li>operator, 操作符：分为控制符或重定向符，操作符由至少一个元字符组成&lt;/li>
&lt;li>process group, 进程组：一系列具有相同组进程ID的进程&lt;/li>
&lt;li>reserved word, 保留字：对shell具有特殊含义的单词。，大多数保留字用于流程控制，如&lt;code>for, while, if&lt;/code>&lt;/li>
&lt;li>signal, 信号：一种机制，内核可以通过该机制将系统中发生的事件通知给进程&lt;/li>
&lt;li>token, 标记：可以被shell认为是一个独立单元的一串字符，分为单词word或操作符operator&lt;/li>
&lt;li>word, 单词：可以被shell认为是一个单元的一串字符，单词不能包括不带引号的元字符。&lt;/li>
&lt;/ul>
&lt;h2 id="shell脚本的第一行">shell脚本的第一行&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&amp;gt; &lt;span class="c1">#! /bin/sh -&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>-符号表示没有其他参数，防止一些欺骗攻击&lt;/li>
&lt;li>shell脚本的第一行长度一般不要超过64个字符&lt;/li>
&lt;/ul>
&lt;h2 id="shell脚本的重定向符">shell脚本的重定向符&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>&amp;gt;&lt;/strong> 表示将命令输出的内容重定向到其他位置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ cat &amp;gt; nusers
&lt;span class="ln">2&lt;/span>who &lt;span class="p">|&lt;/span> wc -l
&lt;/code>&lt;/pre>&lt;/div>&lt;p>即将&lt;code>who | wc -l&lt;/code>复制到&lt;code>nusers&lt;/code>文件中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;gt;&amp;gt;&lt;/strong> 表示已用附加的方式重定向到指定文件。区别在于如果目标文件存在，会将内容附加到文档后面，而不会覆盖文档。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&amp;lt;表示从其他地方而不是键盘接受输入&lt;code>patch --verbose --backup -p1 &amp;lt; /tmp/cx&lt;/code>，表示从/tmp/cx文件输入内容&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="一些特殊符号">一些特殊符号&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>;&lt;/strong> 表示一条命令输入结束，命令按顺序执行&lt;/li>
&lt;li>&lt;strong>＆&lt;/strong> 表示后台执行&amp;amp;之前的命令，直接在前台执行&amp;amp;之后的命令。&lt;/li>
&lt;li>&lt;strong>&amp;amp;&amp;amp;&lt;/strong> 用法&lt;code>command 1 &amp;amp;&amp;amp; command 2&lt;/code>，表示当&lt;code>command 1&lt;/code>执行成功后，再执行&lt;code>command 2&lt;/code>，如果不成功，则不执行&lt;code>command 2&lt;/code>。&lt;/li>
&lt;li>&lt;strong>||&lt;/strong> 用法&lt;code>command 1 || command 2&lt;/code>，表示若&lt;code>command 1&lt;/code>执行失败，则执行&lt;code>command 2&lt;/code>，如果执行成功，则不执行&lt;code>command 2&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h2 id="变量">变量&lt;/h2>
&lt;p>Shell脚本中变量可以是（并且通常是）空值，&lt;code>null&lt;/code>。
变量赋值的时候&lt;code>VarName=VarValue&lt;/code>,如果&lt;code>VarValue&lt;/code>中间&lt;strong>有空格&lt;/strong>，则需要使用&lt;strong>双引号&lt;/strong>，包括&lt;code>VarValue&lt;/code>。变量引用的时候需要使用$符号,&lt;code>$VarName&lt;/code>;如果想在CMD终端显示有空格的&lt;code>VarValue&lt;/code>，需要使用&lt;code>echo&lt;/code>命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>$ &lt;span class="nv">fullname&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;hello world&amp;#34;&lt;/span>
&lt;span class="ln">2&lt;/span>$ &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$fullname&lt;/span>
&lt;span class="ln">3&lt;/span>hello world
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="path路径中的作用">PATH路径中:的作用&lt;/h2>
&lt;blockquote>
&lt;p>表示从哪里开始搜寻命令&lt;/p>
&lt;/blockquote>
&lt;h2 id="访问shell的的参数">访问Shell的的参数&lt;/h2>
&lt;p>访问shell的参数也就是说shell的命令行参数，例如&lt;code>myshell para1 para2&lt;/code>;在Shell函数里面用&lt;code>$1,$2,$3,.....,$9,${10}&lt;/code>表示。当参数&lt;strong>大于10个&lt;/strong>时，由于历史原因，需要用&lt;strong>大括号&lt;/strong>包裹起来。&lt;/p>
&lt;p>删除一个变量可以使用&lt;code>unset&lt;/code>命令，变量名&lt;strong>不用加$&lt;/strong>,即&lt;code>unset x&lt;/code>&lt;/p>
&lt;p>设置环境变量&lt;code>export VarName=VarValue&lt;/code>，使用&lt;code>env&lt;/code>命令可以查看所有的环境变量&lt;/p>
&lt;p>预定义变量和位置变量（位置变量也是预定义变量的一种，只是比较常见单独拿出来说）&lt;/p>
&lt;p>预定义变量有3个，&lt;code>$?,$$.$!&lt;/code>;位置变量有：&lt;code>$n,$*,$@,$#&lt;/code>。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>变量&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$0&lt;/td>
&lt;td>当前脚本的文件名&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$n&lt;/td>
&lt;td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$#&lt;/td>
&lt;td>传递给脚本或函数的参数个数。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$*&lt;/td>
&lt;td>传递给脚本或函数的所有参数。这种方式将所有参数作为一个整体。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$@&lt;/td>
&lt;td>传递给脚本或函数的所有参数。被双引号(&amp;quot; &amp;quot;)包含时，与 $* 稍有不同，会将每一个变量法分开表示。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$?&lt;/td>
&lt;td>上个命令的退出状态，或函数的返回值。&lt;strong>$?&lt;/strong>:表示上一个命令执行的结果，如果正常执行则返回0，非正常执行则为错误代码&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$$&lt;/td>
&lt;td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$!&lt;/td>
&lt;td>后台最后一个进程所表示的PID&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="简单的命令跟踪">简单的命令跟踪&lt;/h2>
&lt;p>在Shell中输入&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>set -x&lt;/code> 表示每一个命令使用+表示执行到哪一个命令&lt;br>
&lt;code>set +x&lt;/code> 表示取消跟踪&lt;br>
&lt;code>shell -x CMD&lt;/code> 表示追踪此CMD命令&lt;/p>
&lt;/blockquote>
&lt;h2 id="shell脚本中的">shell脚本中的“.”&lt;/h2>
&lt;p>shell脚本中，使用“&lt;code>.&lt;/code>”等同于使用&lt;code>source&lt;/code>，相当于在脚本中执行另一个脚本，但是执行的时候&lt;strong>共用一个shell&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>source&lt;/code>命令用法： &lt;code>source FileName&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>作用:在当前bash环境下读取并执行&lt;code>FileName&lt;/code>中的命令。该命令通常用命令“&lt;code>.&lt;/code>”来替代。&lt;code>source filepath&lt;/code>或者&lt;code>. filepath&lt;/code>，&lt;code>sh filepath&lt;/code>或者&lt;code>./filepath&lt;/code>区别：&lt;/p>
&lt;ol>
&lt;li>&lt;code>sh filepath&lt;/code>会重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell是新建的，其改变的变量不会被带回父shell，除非使用export。&lt;/li>
&lt;li>&lt;code>source filename&lt;/code>其实只是简单地读取脚本里面的语句依次在当前shell里面执行，没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面。&lt;/li>
&lt;/ol></description></item><item><title>Shell手册</title><link>https://surprisedcat.github.io/projectnotes/shell-cheatsheet/</link><pubDate>Sun, 05 Jul 2020 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/shell-cheatsheet/</guid><description>
&lt;ul>
&lt;li>&lt;a href="#getting-started">Getting started&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#example">Example&lt;/a>&lt;/li>
&lt;li>&lt;a href="#variables">Variables&lt;/a>&lt;/li>
&lt;li>&lt;a href="#string-quotes">String quotes&lt;/a>&lt;/li>
&lt;li>&lt;a href="#shell-execution">Shell execution&lt;/a>&lt;/li>
&lt;li>&lt;a href="#conditional-execution">Conditional execution&lt;/a>&lt;/li>
&lt;li>&lt;a href="#functions-example">Functions Example&lt;/a>&lt;/li>
&lt;li>&lt;a href="#conditionals-example">Conditionals example&lt;/a>&lt;/li>
&lt;li>&lt;a href="#strict-mode">Strict mode&lt;/a>&lt;/li>
&lt;li>&lt;a href="#brace-expansion">Brace expansion&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#parameter-expansions">Parameter expansions&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#basics">Basics&lt;/a>&lt;/li>
&lt;li>&lt;a href="#substitution">Substitution&lt;/a>&lt;/li>
&lt;li>&lt;a href="#comments">Comments&lt;/a>&lt;/li>
&lt;li>&lt;a href="#substrings">Substrings&lt;/a>&lt;/li>
&lt;li>&lt;a href="#length">Length&lt;/a>&lt;/li>
&lt;li>&lt;a href="#manipulation">Manipulation&lt;/a>&lt;/li>
&lt;li>&lt;a href="#default-values">Default values&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#loops">Loops&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#basic-for-loop">Basic for loop&lt;/a>&lt;/li>
&lt;li>&lt;a href="#c-like-for-loop">C-like for loop&lt;/a>&lt;/li>
&lt;li>&lt;a href="#ranges">Ranges&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#with-step-size">With step size&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#reading-lines">Reading lines&lt;/a>&lt;/li>
&lt;li>&lt;a href="#forever">Forever&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#functions">Functions&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#defining-functions">Defining functions&lt;/a>&lt;/li>
&lt;li>&lt;a href="#returning-values">Returning values&lt;/a>&lt;/li>
&lt;li>&lt;a href="#raising-errors">Raising errors&lt;/a>&lt;/li>
&lt;li>&lt;a href="#arguments">Arguments&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#conditionals">Conditionals&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#conditions">Conditions&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#more-conditions">More conditions&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#file-conditions">File conditions&lt;/a>&lt;/li>
&lt;li>&lt;a href="#test-example">Test Example&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#arrays">Arrays&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#defining-arrays">Defining arrays&lt;/a>&lt;/li>
&lt;li>&lt;a href="#working-with-arrays">Working with arrays&lt;/a>&lt;/li>
&lt;li>&lt;a href="#operations">Operations&lt;/a>&lt;/li>
&lt;li>&lt;a href="#iteration">Iteration&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#dictionaries">Dictionaries&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#defining">Defining&lt;/a>&lt;/li>
&lt;li>&lt;a href="#working-with-dictionaries">Working with dictionaries&lt;/a>&lt;/li>
&lt;li>&lt;a href="#iteration-operation">Iteration Operation&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#iterate-over-values">Iterate over values&lt;/a>&lt;/li>
&lt;li>&lt;a href="#iterate-over-keys">Iterate over keys&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#options">Options&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#set-options">set Options&lt;/a>&lt;/li>
&lt;li>&lt;a href="#glob-options">Glob options&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#history">History&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#commands">Commands&lt;/a>&lt;/li>
&lt;li>&lt;a href="#expansions">Expansions&lt;/a>&lt;/li>
&lt;li>&lt;a href="#operation-info">Operation Info&lt;/a>&lt;/li>
&lt;li>&lt;a href="#slices">Slices&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#miscellaneous">Miscellaneous&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#numeric-calculations">Numeric calculations&lt;/a>&lt;/li>
&lt;li>&lt;a href="#subshells">Subshells&lt;/a>&lt;/li>
&lt;li>&lt;a href="#redirection">Redirection&lt;/a>&lt;/li>
&lt;li>&lt;a href="#inspecting-commands">Inspecting commands&lt;/a>&lt;/li>
&lt;li>&lt;a href="#trap-errors">Trap errors&lt;/a>&lt;/li>
&lt;li>&lt;a href="#caseswitch">Case/switch&lt;/a>&lt;/li>
&lt;li>&lt;a href="#source-relative">Source relative&lt;/a>&lt;/li>
&lt;li>&lt;a href="#printf">printf&lt;/a>&lt;/li>
&lt;li>&lt;a href="#directory-of-script">Directory of script&lt;/a>&lt;/li>
&lt;li>&lt;a href="#getting-options">Getting options&lt;/a>&lt;/li>
&lt;li>&lt;a href="#heredoc">Heredoc&lt;/a>&lt;/li>
&lt;li>&lt;a href="#reading-input">Reading input&lt;/a>&lt;/li>
&lt;li>&lt;a href="#special-variables">Special variables&lt;/a>&lt;/li>
&lt;li>&lt;a href="#go-to-previous-directory">Go to previous directory&lt;/a>&lt;/li>
&lt;li>&lt;a href="#check-for-commands-result">Check for command's result&lt;/a>&lt;/li>
&lt;li>&lt;a href="#grep-check">Grep check&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#also-see">Also see&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="getting-started">Getting started&lt;/h2>
&lt;p>This is a quick reference to getting started with Bash scripting.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://learnxinyminutes.com/docs/bash/">Learn bash in y minutes&lt;/a> &lt;em>(learnxinyminutes.com)&lt;/em>&lt;/li>
&lt;li>&lt;a href="http://mywiki.wooledge.org/BashGuide">Bash Guide&lt;/a> &lt;em>(mywiki.wooledge.org)&lt;/em>&lt;/li>
&lt;/ul>
&lt;h3 id="example">Example&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nv">NAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;John&amp;#34;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Hello &lt;/span>&lt;span class="nv">$NAME&lt;/span>&lt;span class="s2">!&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="variables">Variables&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nv">NAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;John&amp;#34;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="nv">$NAME&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$NAME&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">NAME&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">!&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="string-quotes">String quotes&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nv">NAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;John&amp;#34;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Hi &lt;/span>&lt;span class="nv">$NAME&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="c1">#=&amp;gt; Hi John&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;Hi $NAME&amp;#39;&lt;/span> &lt;span class="c1">#=&amp;gt; Hi $NAME&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="shell-execution">Shell execution&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;I&amp;#39;m in &lt;/span>&lt;span class="k">$(&lt;/span>&lt;span class="nb">pwd&lt;/span>&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;I&amp;#39;m in `pwd`&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="c1"># Same&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>See &lt;a href="http://wiki.bash-hackers.org/syntax/expansion/cmdsubst">Command substitution&lt;/a>&lt;/p>
&lt;h3 id="conditional-execution">Conditional execution&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>git commit &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> git push
&lt;span class="ln">2&lt;/span>git commit &lt;span class="o">||&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Commit failed&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="functions-example">Functions Example&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>get_name&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;John&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">4&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;You are &lt;/span>&lt;span class="k">$(&lt;/span>get_name&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>See: &lt;a href="#functions">Functions&lt;/a>&lt;/p>
&lt;h3 id="conditionals-example">Conditionals example&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="o">[[&lt;/span> -z &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$string&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="o">]]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;String is empty&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">elif&lt;/span> &lt;span class="o">[[&lt;/span> -n &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$string&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="o">]]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;String is not empty&amp;#34;&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="k">fi&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>See: &lt;a href="#conditionals">Conditionals&lt;/a>&lt;/p>
&lt;h3 id="strict-mode">Strict mode&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">set&lt;/span> -euo pipefail
&lt;span class="ln">2&lt;/span>&lt;span class="nv">IFS&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">$&amp;#39;\n\t&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>See: &lt;a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/">Unofficial bash strict mode&lt;/a>&lt;/p>
&lt;h3 id="brace-expansion">Brace expansion&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="o">{&lt;/span>A,B&lt;span class="o">}&lt;/span>.js
&lt;/code>&lt;/pre>&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Expression&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>{A,B}&lt;/code>&lt;/td>
&lt;td>Same as &lt;code>A B&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>{A,B}.js&lt;/code>&lt;/td>
&lt;td>Same as &lt;code>A.js B.js&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>{1..5}&lt;/code>&lt;/td>
&lt;td>Same as &lt;code>1 2 3 4 5&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>See: &lt;a href="http://wiki.bash-hackers.org/syntax/expansion/brace">Brace expansion&lt;/a>&lt;/p>
&lt;h2 id="parameter-expansions">Parameter expansions&lt;/h2>
&lt;h3 id="basics">Basics&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nv">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;John&amp;#34;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">name&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">name&lt;/span>&lt;span class="p">/J/j&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1">#=&amp;gt; &amp;#34;john&amp;#34; (substitution)&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">0&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">2&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1">#=&amp;gt; &amp;#34;Jo&amp;#34; (slicing)&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">name&lt;/span>&lt;span class="p">::&lt;/span>&lt;span class="nv">2&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1">#=&amp;gt; &amp;#34;Jo&amp;#34; (slicing)&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="k">:-&lt;/span>&lt;span class="nv">1&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1">#=&amp;gt; &amp;#34;Joh&amp;#34; (slicing)&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">name&lt;/span>&lt;span class="p">:(-1)&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1">#=&amp;gt; &amp;#34;n&amp;#34; (slicing from right)&lt;/span>
&lt;span class="ln">8&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">name&lt;/span>&lt;span class="p">:(-2):&lt;/span>&lt;span class="nv">1&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1">#=&amp;gt; &amp;#34;h&amp;#34; (slicing from right)&lt;/span>
&lt;span class="ln">9&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">food&lt;/span>&lt;span class="k">:-&lt;/span>&lt;span class="nv">Cake&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1">#=&amp;gt; $food or &amp;#34;Cake&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nv">length&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">2&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">0&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">length&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1">#=&amp;gt; &amp;#34;Jo&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>See: &lt;a href="http://wiki.bash-hackers.org/syntax/pe">Parameter expansion&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/path/to/foo.cpp&amp;#34;&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="p">%.cpp&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># /path/to/foo&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="p">%.cpp&lt;/span>&lt;span class="si">}&lt;/span>.o &lt;span class="c1"># /path/to/foo.o&lt;/span>
&lt;span class="ln"> 4&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="p">%/*&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># /path/to&lt;/span>
&lt;span class="ln"> 5&lt;/span>
&lt;span class="ln"> 6&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="p">##*.&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># cpp (extension)&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="p">##*/&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># foo.cpp (basepath)&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="p">#*/&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># path/to/foo.cpp&lt;/span>
&lt;span class="ln">10&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="p">##*/&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># foo.cpp&lt;/span>
&lt;span class="ln">11&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="p">/foo/bar&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># /path/to/bar.cpp&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Hello world&amp;#34;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">6&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">5&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># &amp;#34;world&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="p">: -5:&lt;/span>&lt;span class="nv">5&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># &amp;#34;world&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nv">SRC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/path/to/foo.cpp&amp;#34;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nv">BASE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">SRC&lt;/span>&lt;span class="p">##*/&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1">#=&amp;gt; &amp;#34;foo.cpp&amp;#34; (basepath)&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nv">DIR&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">SRC&lt;/span>&lt;span class="p">%&lt;/span>&lt;span class="nv">$BASE&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1">#=&amp;gt; &amp;#34;/path/to/&amp;#34; (dirpath)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="substitution">Substitution&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Code&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>${FOO%suffix}&lt;/code>&lt;/td>
&lt;td>Remove suffix&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>${FOO#prefix}&lt;/code>&lt;/td>
&lt;td>Remove prefix&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>---&lt;/td>
&lt;td>---&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>${FOO%%suffix}&lt;/code>&lt;/td>
&lt;td>Remove long suffix&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>${FOO##prefix}&lt;/code>&lt;/td>
&lt;td>Remove long prefix&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>---&lt;/td>
&lt;td>---&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>${FOO/from/to}&lt;/code>&lt;/td>
&lt;td>Replace first match&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>${FOO//from/to}&lt;/code>&lt;/td>
&lt;td>Replace all&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>---&lt;/td>
&lt;td>---&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>${FOO/%from/to}&lt;/code>&lt;/td>
&lt;td>Replace suffix&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>${FOO/#from/to}&lt;/code>&lt;/td>
&lt;td>Replace prefix&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="comments">Comments&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># Single line comment&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>: &lt;span class="s1">&amp;#39;
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="s1">This is a
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="s1">multi line
&lt;/span>&lt;span class="ln">4&lt;/span>&lt;span class="s1">comment
&lt;/span>&lt;span class="ln">5&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="substrings">Substrings&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Expression&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>${FOO:0:3}&lt;/code>&lt;/td>
&lt;td>Substring &lt;em>(position, length)&lt;/em>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>${FOO:(-3):3}&lt;/code>&lt;/td>
&lt;td>Substring from the right&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="length">Length&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Expression&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>${#FOO}&lt;/code>&lt;/td>
&lt;td>Length of &lt;code>$FOO&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="manipulation">Manipulation&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;HELLO WORLD!&amp;#34;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1">#=&amp;gt; &amp;#34;hELLO WORLD!&amp;#34; (lowercase 1st letter)&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="p">,,&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1">#=&amp;gt; &amp;#34;hello world!&amp;#34; (all lowercase)&lt;/span>
&lt;span class="ln">4&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;hello world!&amp;#34;&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="p">^&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1">#=&amp;gt; &amp;#34;Hello world!&amp;#34; (uppercase 1st letter)&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">STR&lt;/span>&lt;span class="p">^^&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1">#=&amp;gt; &amp;#34;HELLO WORLD!&amp;#34; (all uppercase)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="default-values">Default values&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Expression&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>${FOO:-val}&lt;/code>&lt;/td>
&lt;td>&lt;code>$FOO&lt;/code>, or &lt;code>val&lt;/code> if unset (or null)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>${FOO:=val}&lt;/code>&lt;/td>
&lt;td>Set &lt;code>$FOO&lt;/code> to &lt;code>val&lt;/code> if unset (or null)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>${FOO:+val}&lt;/code>&lt;/td>
&lt;td>&lt;code>val&lt;/code> if &lt;code>$FOO&lt;/code> is set (and not null)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>${FOO:?message}&lt;/code>&lt;/td>
&lt;td>Show error message and exit if &lt;code>$FOO&lt;/code> is unset (or null)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Omitting the &lt;code>:&lt;/code> removes the (non)nullity checks, e.g. &lt;code>${FOO-val}&lt;/code> expands to &lt;code>val&lt;/code> if unset otherwise &lt;code>$FOO&lt;/code>.&lt;/p>
&lt;h2 id="loops">Loops&lt;/h2>
&lt;h3 id="basic-for-loop">Basic for loop&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">for&lt;/span> i in /etc/rc.*&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$i&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="c-like-for-loop">C-like for loop&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">for&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="nv">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="p">;&lt;/span> i &amp;lt; &lt;span class="m">100&lt;/span> &lt;span class="p">;&lt;/span> i++&lt;span class="o">))&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$i&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ranges">Ranges&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">for&lt;/span> i in &lt;span class="o">{&lt;/span>1..5&lt;span class="o">}&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Welcome &lt;/span>&lt;span class="nv">$i&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="with-step-size">With step size&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">for&lt;/span> i in &lt;span class="o">{&lt;/span>5..50..5&lt;span class="o">}&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Welcome &lt;/span>&lt;span class="nv">$i&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="reading-lines">Reading lines&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>cat file.txt &lt;span class="p">|&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="nb">read&lt;/span> line&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$line&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="forever">Forever&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">while&lt;/span> true&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln">2&lt;/span> ···
&lt;span class="ln">3&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="functions">Functions&lt;/h2>
&lt;h3 id="defining-functions">Defining functions&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>myfunc&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;hello &lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># Same as above (alternate syntax)&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="k">function&lt;/span> myfunc&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;hello &lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>myfunc &lt;span class="s2">&amp;#34;John&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="returning-values">Returning values&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>myfunc&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">local&lt;/span> &lt;span class="nv">myresult&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;some value&amp;#39;&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$myresult&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nv">result&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>myfunc&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="raising-errors">Raising errors&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>myfunc&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="m">1&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">if&lt;/span> myfunc&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;success&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">else&lt;/span>
&lt;span class="ln">4&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;failure&amp;#34;&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="k">fi&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="arguments">Arguments&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Expression&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>$#&lt;/code>&lt;/td>
&lt;td>Number of arguments&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>$*&lt;/code>&lt;/td>
&lt;td>All positional arguments (as a single word)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>$@&lt;/code>&lt;/td>
&lt;td>All positional arguments (as separate strings)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>$1&lt;/code>&lt;/td>
&lt;td>First argument&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>$_&lt;/code>&lt;/td>
&lt;td>Last argument of the previous command&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Note&lt;/strong>: &lt;code>$@&lt;/code> and &lt;code>$*&lt;/code> must be quoted in order to perform as described.
Otherwise, they do exactly the same thing (arguments as separate strings).&lt;/p>
&lt;p>See &lt;a href="http://wiki.bash-hackers.org/syntax/shellvars#special_parameters_and_shell_variables">Special parameters&lt;/a>.&lt;/p>
&lt;h2 id="conditionals">Conditionals&lt;/h2>
&lt;h3 id="conditions">Conditions&lt;/h3>
&lt;p>Note that &lt;code>[[&lt;/code> is actually a command/program that returns either &lt;code>0&lt;/code> (true) or &lt;code>1&lt;/code> (false). Any program that obeys the same logic (like all base utils, such as &lt;code>grep(1)&lt;/code> or &lt;code>ping(1)&lt;/code>) can be used as condition, see examples.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Condition&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>[[ -z STRING ]]&lt;/code>&lt;/td>
&lt;td>Empty string&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ -n STRING ]]&lt;/code>&lt;/td>
&lt;td>Not empty string&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ STRING == STRING ]]&lt;/code>&lt;/td>
&lt;td>Equal&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ STRING != STRING ]]&lt;/code>&lt;/td>
&lt;td>Not Equal&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>---&lt;/td>
&lt;td>---&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ NUM -eq NUM ]]&lt;/code>&lt;/td>
&lt;td>Equal&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ NUM -ne NUM ]]&lt;/code>&lt;/td>
&lt;td>Not equal&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ NUM -lt NUM ]]&lt;/code>&lt;/td>
&lt;td>Less than&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ NUM -le NUM ]]&lt;/code>&lt;/td>
&lt;td>Less than or equal&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ NUM -gt NUM ]]&lt;/code>&lt;/td>
&lt;td>Greater than&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ NUM -ge NUM ]]&lt;/code>&lt;/td>
&lt;td>Greater than or equal&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>---&lt;/td>
&lt;td>---&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ STRING =~ STRING ]]&lt;/code>&lt;/td>
&lt;td>Regexp&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>---&lt;/td>
&lt;td>---&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>(( NUM &amp;lt; NUM ))&lt;/code>&lt;/td>
&lt;td>Numeric conditions&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="more-conditions">More conditions&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Condition&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>[[ -o noclobber ]]&lt;/code>&lt;/td>
&lt;td>If OPTIONNAME is enabled&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>---&lt;/td>
&lt;td>---&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ ! EXPR ]]&lt;/code>&lt;/td>
&lt;td>Not&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ X &amp;amp;&amp;amp; Y ]]&lt;/code>&lt;/td>
&lt;td>And&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>`[[ X&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="file-conditions">File conditions&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Condition&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>[[ -e FILE ]]&lt;/code>&lt;/td>
&lt;td>Exists&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ -r FILE ]]&lt;/code>&lt;/td>
&lt;td>Readable&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ -h FILE ]]&lt;/code>&lt;/td>
&lt;td>Symlink&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ -d FILE ]]&lt;/code>&lt;/td>
&lt;td>Directory&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ -w FILE ]]&lt;/code>&lt;/td>
&lt;td>Writable&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ -s FILE ]]&lt;/code>&lt;/td>
&lt;td>Size is &amp;gt; 0 bytes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ -f FILE ]]&lt;/code>&lt;/td>
&lt;td>File&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ -x FILE ]]&lt;/code>&lt;/td>
&lt;td>Executable&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>---&lt;/td>
&lt;td>---&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ FILE1 -nt FILE2 ]]&lt;/code>&lt;/td>
&lt;td>1 is more recent than 2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ FILE1 -ot FILE2 ]]&lt;/code>&lt;/td>
&lt;td>2 is more recent than 1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[ FILE1 -ef FILE2 ]]&lt;/code>&lt;/td>
&lt;td>Same files&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="test-example">Test Example&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># String&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="o">[[&lt;/span> -z &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$string&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="o">]]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
&lt;span class="ln">3&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;String is empty&amp;#34;&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="k">elif&lt;/span> &lt;span class="o">[[&lt;/span> -n &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$string&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="o">]]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
&lt;span class="ln">5&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;String is not empty&amp;#34;&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="k">else&lt;/span>
&lt;span class="ln">7&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;This never happens&amp;#34;&lt;/span>
&lt;span class="ln">8&lt;/span>&lt;span class="k">fi&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># Combinations&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="o">[[&lt;/span> X &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> Y &lt;span class="o">]]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
&lt;span class="ln">3&lt;/span> ...
&lt;span class="ln">4&lt;/span>&lt;span class="k">fi&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># Equal&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="o">[[&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$A&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$B&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="o">]]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="c1"># Regex&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="o">[[&lt;/span> &lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span> &lt;span class="o">=&lt;/span>~ . &lt;span class="o">]]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="o">((&lt;/span> &lt;span class="nv">$a&lt;/span> &amp;lt; &lt;span class="nv">$b&lt;/span> &lt;span class="o">))&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$a&lt;/span>&lt;span class="s2"> is smaller than &lt;/span>&lt;span class="nv">$b&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">fi&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="o">[[&lt;/span> -e &lt;span class="s2">&amp;#34;file.txt&amp;#34;&lt;/span> &lt;span class="o">]]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;file exists&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">fi&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="arrays">Arrays&lt;/h2>
&lt;h3 id="defining-arrays">Defining arrays&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="o">=(&lt;/span>&lt;span class="s1">&amp;#39;Apple&amp;#39;&lt;/span> &lt;span class="s1">&amp;#39;Banana&amp;#39;&lt;/span> &lt;span class="s1">&amp;#39;Orange&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>Fruits&lt;span class="o">[&lt;/span>0&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;Apple&amp;#34;&lt;/span>
&lt;span class="ln">2&lt;/span>Fruits&lt;span class="o">[&lt;/span>1&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;Banana&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>Fruits&lt;span class="o">[&lt;/span>2&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;Orange&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="working-with-arrays">Working with arrays&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="p">[0]&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># Element #0&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="p">[-1]&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># Last element&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="p">[@]&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># All elements, space-separated&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${#&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="p">[@]&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># Number of elements&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${#&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># String length of the 1st element&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${#&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="p">[3]&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># String length of the Nth element&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="p">[@]:&lt;/span>&lt;span class="nv">3&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">2&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># Range (from position 3, length 2)&lt;/span>
&lt;span class="ln">8&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="p">!Fruits[@]&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># Keys of all elements, space-separated&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="operations">Operations&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="o">=(&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="p">[@]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;Watermelon&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="c1"># Push&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="o">+=(&lt;/span>&lt;span class="s1">&amp;#39;Watermelon&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="c1"># Also Push&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="o">=(&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="p">[@]/Ap*/&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="o">)&lt;/span> &lt;span class="c1"># Remove by regex match&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">unset&lt;/span> Fruits&lt;span class="o">[&lt;/span>2&lt;span class="o">]&lt;/span> &lt;span class="c1"># Remove one item&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="o">=(&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="p">[@]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="c1"># Duplicate&lt;/span>
&lt;span class="ln">6&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="o">=(&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">Fruits&lt;/span>&lt;span class="p">[@]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">Veggies&lt;/span>&lt;span class="p">[@]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="c1"># Concatenate&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="nv">lines&lt;/span>&lt;span class="o">=(&lt;/span>&lt;span class="sb">`&lt;/span>cat &lt;span class="s2">&amp;#34;logfile&amp;#34;&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="c1"># Read from file&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="iteration">Iteration&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">for&lt;/span> i in &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">arrayName&lt;/span>&lt;span class="p">[@]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$i&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="dictionaries">Dictionaries&lt;/h2>
&lt;h3 id="defining">Defining&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">declare&lt;/span> -A sounds
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>sounds&lt;span class="o">[&lt;/span>dog&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;bark&amp;#34;&lt;/span>
&lt;span class="ln">2&lt;/span>sounds&lt;span class="o">[&lt;/span>cow&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;moo&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>sounds&lt;span class="o">[&lt;/span>bird&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;tweet&amp;#34;&lt;/span>
&lt;span class="ln">4&lt;/span>sounds&lt;span class="o">[&lt;/span>wolf&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;howl&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Declares &lt;code>sound&lt;/code> as a Dictionary object (aka associative array).&lt;/p>
&lt;h3 id="working-with-dictionaries">Working with dictionaries&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">sounds&lt;/span>&lt;span class="p">[dog]&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># Dog&amp;#39;s sound&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">sounds&lt;/span>&lt;span class="p">[@]&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># All values&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="p">!sounds[@]&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># All keys&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="si">${#&lt;/span>&lt;span class="nv">sounds&lt;/span>&lt;span class="p">[@]&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="c1"># Number of elements&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="nb">unset&lt;/span> sounds&lt;span class="o">[&lt;/span>dog&lt;span class="o">]&lt;/span> &lt;span class="c1"># Delete dog&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="iteration-operation">Iteration Operation&lt;/h3>
&lt;h4 id="iterate-over-values">Iterate over values&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">for&lt;/span> val in &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">sounds&lt;/span>&lt;span class="p">[@]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$val&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="iterate-over-keys">Iterate over keys&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">for&lt;/span> key in &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="p">!sounds[@]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$key&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="options">Options&lt;/h2>
&lt;h3 id="set-options">set Options&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">set&lt;/span> -o noclobber &lt;span class="c1"># Avoid overlay files (echo &amp;#34;hi&amp;#34; &amp;gt; foo)&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nb">set&lt;/span> -o errexit &lt;span class="c1"># Used to exit upon error, avoiding cascading errors&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nb">set&lt;/span> -o pipefail &lt;span class="c1"># Unveils hidden failures&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">set&lt;/span> -o nounset &lt;span class="c1"># Exposes unset variables&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="glob-options">Glob options&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">shopt&lt;/span> -s nullglob &lt;span class="c1"># Non-matching globs are removed (&amp;#39;*.foo&amp;#39; =&amp;gt; &amp;#39;&amp;#39;)&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nb">shopt&lt;/span> -s failglob &lt;span class="c1"># Non-matching globs throw errors&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="nb">shopt&lt;/span> -s nocaseglob &lt;span class="c1"># Case insensitive globs&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">shopt&lt;/span> -s dotglob &lt;span class="c1"># Wildcards match dotfiles (&amp;#34;*.sh&amp;#34; =&amp;gt; &amp;#34;.foo.sh&amp;#34;)&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="nb">shopt&lt;/span> -s globstar &lt;span class="c1"># Allow ** for recursive matches (&amp;#39;lib/**/*.rb&amp;#39; =&amp;gt; &amp;#39;lib/a/b/c.rb&amp;#39;)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Set &lt;code>GLOBIGNORE&lt;/code> as a colon-separated list of patterns to be removed from glob
matches.&lt;/p>
&lt;h2 id="history">History&lt;/h2>
&lt;h3 id="commands">Commands&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Command&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>history&lt;/code>&lt;/td>
&lt;td>Show history&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>shopt -s histverify&lt;/code>&lt;/td>
&lt;td>Don't execute expanded result immediately&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="expansions">Expansions&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Expression&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>!$&lt;/code>&lt;/td>
&lt;td>Expand last parameter of most recent command&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!*&lt;/code>&lt;/td>
&lt;td>Expand all parameters of most recent command&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!-n&lt;/code>&lt;/td>
&lt;td>Expand &lt;code>n&lt;/code>th most recent command&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!n&lt;/code>&lt;/td>
&lt;td>Expand &lt;code>n&lt;/code>th command in history&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!&amp;lt;command&amp;gt;&lt;/code>&lt;/td>
&lt;td>Expand most recent invocation of command &lt;code>&amp;lt;command&amp;gt;&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="operation-info">Operation Info&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Code&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>!!&lt;/code>&lt;/td>
&lt;td>Execute last command again&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!!:s/&amp;lt;FROM&amp;gt;/&amp;lt;TO&amp;gt;/&lt;/code>&lt;/td>
&lt;td>Replace first occurrence of &lt;code>&amp;lt;FROM&amp;gt;&lt;/code> to &lt;code>&amp;lt;TO&amp;gt;&lt;/code> in most recent command&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!!:gs/&amp;lt;FROM&amp;gt;/&amp;lt;TO&amp;gt;/&lt;/code>&lt;/td>
&lt;td>Replace all occurrences of &lt;code>&amp;lt;FROM&amp;gt;&lt;/code> to &lt;code>&amp;lt;TO&amp;gt;&lt;/code> in most recent command&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!$:t&lt;/code>&lt;/td>
&lt;td>Expand only basename from last parameter of most recent command&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!$:h&lt;/code>&lt;/td>
&lt;td>Expand only directory from last parameter of most recent command&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>!!&lt;/code> and &lt;code>!$&lt;/code> can be replaced with any valid expansion.&lt;/p>
&lt;h3 id="slices">Slices&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Code&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>!!:n&lt;/code>&lt;/td>
&lt;td>Expand only &lt;code>n&lt;/code>th token from most recent command (command is &lt;code>0&lt;/code>; first argument is &lt;code>1&lt;/code>)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!^&lt;/code>&lt;/td>
&lt;td>Expand first argument from most recent command&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!$&lt;/code>&lt;/td>
&lt;td>Expand last token from most recent command&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!!:n-m&lt;/code>&lt;/td>
&lt;td>Expand range of tokens from most recent command&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!!:n-$&lt;/code>&lt;/td>
&lt;td>Expand &lt;code>n&lt;/code>th token to last from most recent command&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>!!&lt;/code> can be replaced with any valid expansion i.e. &lt;code>!cat&lt;/code>, &lt;code>!-2&lt;/code>, &lt;code>!42&lt;/code>, etc.&lt;/p>
&lt;h2 id="miscellaneous">Miscellaneous&lt;/h2>
&lt;h3 id="numeric-calculations">Numeric calculations&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">$((&lt;/span>a &lt;span class="o">+&lt;/span> &lt;span class="m">200&lt;/span>&lt;span class="k">))&lt;/span> &lt;span class="c1"># Add 200 to $a&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">$((&lt;/span>&lt;span class="nv">$RANDOM&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="m">200&lt;/span>&lt;span class="k">))&lt;/span> &lt;span class="c1"># Random number 0..199&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="subshells">Subshells&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nb">cd&lt;/span> somedir&lt;span class="p">;&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;I&amp;#39;m now in &lt;/span>&lt;span class="nv">$PWD&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nb">pwd&lt;/span> &lt;span class="c1"># still in first directory&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="redirection">Redirection&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>python hello.py &amp;gt; output.txt &lt;span class="c1"># stdout to (file)&lt;/span>
&lt;span class="ln">2&lt;/span>python hello.py &amp;gt;&amp;gt; output.txt &lt;span class="c1"># stdout to (file), append&lt;/span>
&lt;span class="ln">3&lt;/span>python hello.py 2&amp;gt; error.log &lt;span class="c1"># stderr to (file)&lt;/span>
&lt;span class="ln">4&lt;/span>python hello.py 2&amp;gt;&lt;span class="p">&amp;amp;&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="c1"># stderr to stdout&lt;/span>
&lt;span class="ln">5&lt;/span>python hello.py 2&amp;gt;/dev/null &lt;span class="c1"># stderr to (null)&lt;/span>
&lt;span class="ln">6&lt;/span>python hello.py &lt;span class="p">&amp;amp;&lt;/span>&amp;gt;/dev/null &lt;span class="c1"># stdout and stderr to (null)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>python hello.py &amp;lt; foo.txt &lt;span class="c1"># feed foo.txt to stdin for python&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="inspecting-commands">Inspecting commands&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">command&lt;/span> -V &lt;span class="nb">cd&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="c1">#=&amp;gt; &amp;#34;cd is a function/alias/whatever&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="trap-errors">Trap errors&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">trap&lt;/span> &lt;span class="s1">&amp;#39;echo Error at about $LINENO&amp;#39;&lt;/span> ERR
&lt;/code>&lt;/pre>&lt;/div>&lt;p>or&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>traperr&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;ERROR: &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">BASH_SOURCE&lt;/span>&lt;span class="p">[1]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2"> at about &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">BASH_LINENO&lt;/span>&lt;span class="p">[0]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="ln">4&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="nb">set&lt;/span> -o errtrace
&lt;span class="ln">6&lt;/span>&lt;span class="nb">trap&lt;/span> traperr ERR
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="caseswitch">Case/switch&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">case&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> in
&lt;span class="ln">2&lt;/span> start &lt;span class="p">|&lt;/span> up&lt;span class="o">)&lt;/span>
&lt;span class="ln">3&lt;/span> vagrant up
&lt;span class="ln">4&lt;/span> &lt;span class="p">;;&lt;/span>
&lt;span class="ln">5&lt;/span>
&lt;span class="ln">6&lt;/span> *&lt;span class="o">)&lt;/span>
&lt;span class="ln">7&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Usage: &lt;/span>&lt;span class="nv">$0&lt;/span>&lt;span class="s2"> {start|stop|ssh}&amp;#34;&lt;/span>
&lt;span class="ln">8&lt;/span> &lt;span class="p">;;&lt;/span>
&lt;span class="ln">9&lt;/span>&lt;span class="k">esac&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="source-relative">Source relative&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">source&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">0&lt;/span>&lt;span class="p">%/*&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">/../share/foo.sh&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="printf">printf&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">printf&lt;/span> &lt;span class="s2">&amp;#34;Hello %s, I&amp;#39;m %s&amp;#34;&lt;/span> Sven Olga
&lt;span class="ln">2&lt;/span>&lt;span class="c1">#=&amp;gt; &amp;#34;Hello Sven, I&amp;#39;m Olga&lt;/span>
&lt;span class="ln">3&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">printf&lt;/span> &lt;span class="s2">&amp;#34;1 + 1 = %d&amp;#34;&lt;/span> &lt;span class="m">2&lt;/span>
&lt;span class="ln">5&lt;/span>&lt;span class="c1">#=&amp;gt; &amp;#34;1 + 1 = 2&amp;#34;&lt;/span>
&lt;span class="ln">6&lt;/span>
&lt;span class="ln">7&lt;/span>&lt;span class="nb">printf&lt;/span> &lt;span class="s2">&amp;#34;This is how you print a float: %f&amp;#34;&lt;/span> &lt;span class="m">2&lt;/span>
&lt;span class="ln">8&lt;/span>&lt;span class="c1">#=&amp;gt; &amp;#34;This is how you print a float: 2.000000&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="directory-of-script">Directory of script&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nv">DIR&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">0&lt;/span>&lt;span class="p">%/*&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="getting-options">Getting options&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln"> 1&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="o">[[&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="o">=&lt;/span>~ ^- &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> ! &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s2">&amp;#34;--&amp;#34;&lt;/span> &lt;span class="o">]]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="k">case&lt;/span> &lt;span class="nv">$1&lt;/span> in
&lt;span class="ln"> 2&lt;/span> -V &lt;span class="p">|&lt;/span> --version &lt;span class="o">)&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$version&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="nb">exit&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="p">;;&lt;/span>
&lt;span class="ln"> 6&lt;/span> -s &lt;span class="p">|&lt;/span> --string &lt;span class="o">)&lt;/span>
&lt;span class="ln"> 7&lt;/span> shift&lt;span class="p">;&lt;/span> &lt;span class="nv">string&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nv">$1&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="p">;;&lt;/span>
&lt;span class="ln"> 9&lt;/span> -f &lt;span class="p">|&lt;/span> --flag &lt;span class="o">)&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="nv">flag&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="p">;;&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="k">esac&lt;/span>&lt;span class="p">;&lt;/span> shift&lt;span class="p">;&lt;/span> &lt;span class="k">done&lt;/span>
&lt;span class="ln">13&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="o">[[&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;--&amp;#39;&lt;/span> &lt;span class="o">]]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span> shift&lt;span class="p">;&lt;/span> &lt;span class="k">fi&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="heredoc">Heredoc&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="ln">1&lt;/span>cat &lt;span class="s">&amp;lt;&amp;lt;END
&lt;/span>&lt;span class="ln">2&lt;/span>&lt;span class="s">hello world
&lt;/span>&lt;span class="ln">3&lt;/span>&lt;span class="s">END&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="reading-input">Reading input&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">echo&lt;/span> -n &lt;span class="s2">&amp;#34;Proceed? [y/n]: &amp;#34;&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nb">read&lt;/span> ans
&lt;span class="ln">3&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="nv">$ans&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">read&lt;/span> -n &lt;span class="m">1&lt;/span> ans &lt;span class="c1"># Just one character&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="special-variables">Special variables&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Expression&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>$?&lt;/code>&lt;/td>
&lt;td>Exit status of last task&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>$!&lt;/code>&lt;/td>
&lt;td>PID of last background task&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>$$&lt;/code>&lt;/td>
&lt;td>PID of shell&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>$0&lt;/code>&lt;/td>
&lt;td>Filename of the shell script&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>$_&lt;/code>&lt;/td>
&lt;td>Last argrument of the previous command&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>See &lt;a href="http://wiki.bash-hackers.org/syntax/shellvars#special_parameters_and_shell_variables">Special parameters&lt;/a>.&lt;/p>
&lt;h3 id="go-to-previous-directory">Go to previous directory&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="nb">pwd&lt;/span> &lt;span class="c1"># /home/user/foo&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="nb">cd&lt;/span> bar/
&lt;span class="ln">3&lt;/span>&lt;span class="nb">pwd&lt;/span> &lt;span class="c1"># /home/user/foo/bar&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="nb">cd&lt;/span> -
&lt;span class="ln">5&lt;/span>&lt;span class="nb">pwd&lt;/span> &lt;span class="c1"># /home/user/foo&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="check-for-commands-result">Check for command's result&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">if&lt;/span> ping -c &lt;span class="m">1&lt;/span> google.com&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;It appears you have a working internet connection&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">fi&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="grep-check">Grep check&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>&lt;span class="k">if&lt;/span> grep -q &lt;span class="s1">&amp;#39;foo&amp;#39;&lt;/span> ~/.bash_history&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
&lt;span class="ln">2&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;You appear to have typed &amp;#39;foo&amp;#39; in the past&amp;#34;&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">fi&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="also-see">Also see&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://wiki.bash-hackers.org/">Bash-hackers wiki&lt;/a> &lt;em>(bash-hackers.org)&lt;/em>&lt;/li>
&lt;li>&lt;a href="http://wiki.bash-hackers.org/syntax/shellvars">Shell vars&lt;/a> &lt;em>(bash-hackers.org)&lt;/em>&lt;/li>
&lt;li>&lt;a href="https://learnxinyminutes.com/docs/bash/">Learn bash in y minutes&lt;/a> &lt;em>(learnxinyminutes.com)&lt;/em>&lt;/li>
&lt;li>&lt;a href="http://mywiki.wooledge.org/BashGuide">Bash Guide&lt;/a> &lt;em>(mywiki.wooledge.org)&lt;/em>&lt;/li>
&lt;li>&lt;a href="https://www.shellcheck.net/">ShellCheck&lt;/a> &lt;em>(shellcheck.net)&lt;/em>&lt;/li>
&lt;/ul></description></item></channel></rss>