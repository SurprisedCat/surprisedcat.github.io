<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>算法 on SurprisedCat</title><link>https://surprisedcat.github.io/categories/%E7%AE%97%E6%B3%95/</link><description>Recent content in 算法 on SurprisedCat</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2020–2021, SurprisedCat; all rights reserved.</copyright><lastBuildDate>Fri, 26 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://surprisedcat.github.io/categories/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>算法-字符串匹配</title><link>https://surprisedcat.github.io/projectnotes/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</link><pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</guid><description>
&lt;h2 id="字符串匹配算法---omit-in-toc---">字符串匹配算法&lt;!-- omit in toc -->&lt;/h2>
&lt;h2 id="暴力查找">暴力查找&lt;/h2>
&lt;h2 id="kmp算法">KMP算法&lt;/h2>
&lt;h2 id="boyer-moore算法">Boyer-Moore算法&lt;/h2>
&lt;h2 id="rabin-karp指纹字符串查找">Rabin-Karp指纹字符串查找&lt;/h2></description></item><item><title>算法-图中找环</title><link>https://surprisedcat.github.io/projectnotes/%E7%AE%97%E6%B3%95-%E5%9B%BE%E4%B8%AD%E6%89%BE%E7%8E%AF/</link><pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/%E7%AE%97%E6%B3%95-%E5%9B%BE%E4%B8%AD%E6%89%BE%E7%8E%AF/</guid><description>
&lt;h2 id="图中找环---omit-in-toc---">图中找环&lt;!-- omit in toc -->&lt;/h2>
&lt;p>无向图与有向图&lt;/p>
&lt;h2 id="拓扑排序">拓扑排序&lt;/h2>
&lt;h2 id="深度遍历">深度遍历&lt;/h2>
&lt;h2 id="并查集">并查集&lt;/h2></description></item><item><title>算法-排序算法精炼</title><link>https://surprisedcat.github.io/projectnotes/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B2%BE%E7%82%BC/</link><pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/projectnotes/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B2%BE%E7%82%BC/</guid><description>
&lt;h2 id="排序算法精炼---omit-in-toc---">排序算法精炼&lt;!-- omit in toc -->&lt;/h2>
&lt;h2 id="tips">TIPS&lt;/h2>
&lt;p>本文讨论的都是升序排序（从小到大）。冒泡，选择，插入是基础算法。&lt;/p>
&lt;p>稳定排序：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。&lt;/p>
&lt;p>不稳定排序：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。&lt;/p>
&lt;h2 id="冒泡算法">冒泡算法&lt;/h2>
&lt;p>&lt;strong>分类&lt;/strong>：比较排序大类，交换排序&lt;/p>
&lt;p>&lt;strong>核心思想&lt;/strong>：两层循环（显然复杂度$n^2$），内循环的作用是让最大值“浮”到末尾，每次内循环浮动一个值。“浮”这个过程就是通过比较相邻元素然后交换。&lt;/p>
&lt;p>&lt;strong>细节&lt;/strong>：内循环可以用一个是否存在交换的swapFlag来优化，查看是否提前完成。还有就是内循环的中止项需要考虑。&lt;/p>
&lt;p>&lt;strong>性能&lt;/strong>：时间复杂度$O(n^2)$，空间复杂度$O(1)$；稳定排序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="ln"> 1&lt;/span>&lt;span class="k">def&lt;/span> &lt;span class="nf">bubble&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="n">index_1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="n">index_1&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">index_2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="n">swapFlag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="n">index_2&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">index_1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1"># 将index_2作为最大值转移到最后,由于后面有index_2+1，所以这里只需要到len(l)-index_1-1&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index_2&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index_2&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">swapFlag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index_2&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index_2&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index_2&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index_2&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">index_2&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">swapFlag&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">index_1&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="选择排序">选择排序&lt;/h2>
&lt;p>&lt;strong>分类&lt;/strong>：比较排序大类，选择排序&lt;/p>
&lt;p>&lt;strong>核心思想&lt;/strong>：最简单直观，两层循环$O(n^2)$。内循环遍历未排序数组找到最大小，与未排序的第一位元素交换。每次内循环搞定一个值。&lt;/p>
&lt;p>&lt;strong>性能&lt;/strong>：时间复杂度$O(n^2)$，空间复杂度$O(1)$；不稳定排序。表现最稳定的排序算法之一，因为无论什么数据进去都是$O(n^2)$的时间复杂度&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="ln"> 1&lt;/span>&lt;span class="k">def&lt;/span> &lt;span class="nf">sel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="n">index1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="n">index1&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="c1"># 最后一个必然排好，不需要&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">minEle&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="n">minIndex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">index1&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">index2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">index1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="n">index2&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index2&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">minEle&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">minEle&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index2&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">minIndex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">index2&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">index2&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index1&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">minIndex&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">minIndex&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">index1&lt;/span>&lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="插入排序">插入排序&lt;/h2>
&lt;p>&lt;strong>分类&lt;/strong>：比较排序大类，插入排序&lt;/p>
&lt;p>&lt;strong>核心思想&lt;/strong>：两层循环$O(n^2)$。内循环从未排序的数组中随便哪一个，然后根据大小插入到已排序数组中。插入排序都采用in-place在数组上实现，不用额外内存，保证空间复杂度为$O(1)$&lt;/p>
&lt;p>&lt;strong>细节&lt;/strong>：注意在while内循环终止时&lt;code>temp&lt;/code>大于&lt;code>l[index2]&lt;/code>，因此应该是&lt;code>l[index2+1] = temp&lt;/code>&lt;/p>
&lt;p>&lt;strong>性能&lt;/strong>：时间复杂度$O(n^2)$，空间复杂度$O(1)$；稳定排序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="ln"> 1&lt;/span>&lt;span class="k">def&lt;/span> &lt;span class="nf">insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="n">index1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="n">index1&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="n">index2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">index1&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="n">index2&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index2&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index2&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index2&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">index2&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index2&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="c1"># 注意在while内循环中temp大于l[index2]&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">index1&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="以上是三种基本算法">以上是三种基本算法&lt;/h2>
&lt;h2 id="希尔排序shell-sort">希尔排序（Shell Sort）&lt;/h2>
&lt;p>1959年Shell发明，第一个突破O(n2)的排序算法。&lt;/p>
&lt;p>&lt;strong>分类&lt;/strong>：比较排序大类，插入排序。&lt;/p>
&lt;p>&lt;strong>核心思想&lt;/strong>：简单插入排序的改进版。它与插入排序的不同之处在于，先按照间隔对子序列排序，逐渐缩小间隔直至1，完成最终排序。&lt;/p>
&lt;p>&lt;strong>性能&lt;/strong>：最坏情况为$O(n^2)$，平均情况好于最坏情况，空间复杂度为$O(1)$，不稳定排序。&lt;/p>
&lt;p>用的少，略。&lt;/p>
&lt;h2 id="归并排序">归并排序&lt;/h2>
&lt;p>&lt;strong>分类&lt;/strong>：归并排序大类&lt;/p>
&lt;p>&lt;strong>核心思想&lt;/strong>：分治(Divide and Conquer)，递归。分成子序列至单个元素再合并。和选择排序一样，归并排序的性能不受输入数据的影响，但时间表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度，代价是额外的空间。&lt;/p>
&lt;p>&lt;strong>细节&lt;/strong>：关键是理解递归。&lt;/p>
&lt;p>&lt;strong>性能&lt;/strong>：时间复杂度$O(n\log n)$，空间复杂度$O(n)$，稳定排序&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="ln"> 1&lt;/span>&lt;span class="k">def&lt;/span> &lt;span class="nf">sortRecursion&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="n">l1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sortRecursion&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="n">l2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sortRecursion&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:])&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">l2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 8&lt;/span>
&lt;span class="ln"> 9&lt;/span>&lt;span class="k">def&lt;/span> &lt;span class="nf">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l1&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">l2&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">index1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">index2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="n">l3&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="n">index1&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">index2&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l2&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">l1&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">l2&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index2&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="n">l3&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l1&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index1&lt;/span>&lt;span class="p">])&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">index1&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="n">l3&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l2&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index2&lt;/span>&lt;span class="p">])&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="n">index2&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">index1&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="n">l3&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">extend&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l1&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index1&lt;/span>&lt;span class="p">:])&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">index2&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l2&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="n">l3&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">extend&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l2&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index2&lt;/span>&lt;span class="p">:])&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l3&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="快速排序">快速排序&lt;/h2>
&lt;p>&lt;strong>分类&lt;/strong>：比较排序大类，交换排序。&lt;/p>
&lt;p>&lt;strong>核心思想&lt;/strong>：快速排序首先选择一个中枢变量（一般选第一个元素），将比中枢变量小的放到左边，大的放到右边，形成&lt;strong>分区&lt;/strong>。再将左右分区依照选中枢变量--&amp;gt;分区的方式递归分区，直到只有一个元素，那么整个数组就排序完成了。我觉得是分治和冒泡排序的结合。&lt;/p>
&lt;p>&lt;strong>细节&lt;/strong>：算法实现时，都用的是in-place操作，其实另开空间更能体现算法思想。in-place将第一个元素后的空间作为存放左边分区的空间，最后再将第一位的pivot元素与左边分区的最后一个元素交换，实现最终分区。&lt;/p>
&lt;p>&lt;strong>性能&lt;/strong>：平均来说，快速排序的平均复杂度为$O(c_q n\log n)$，最坏情况为$c_q O(n^2)$。但是需要指出这个&lt;strong>常用系数$c_q$在几种排序算法中较小&lt;/strong>，因此在不太大的数组排序中，快排优势与归并和堆排序。空间复杂度取决于&lt;strong>递归的次数&lt;/strong>最好为$O(\log n)$，最坏为$O(n)$，此外快排也是不稳定排序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="ln"> 1&lt;/span>&lt;span class="k">def&lt;/span> &lt;span class="nf">quickSort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">end&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="n">pivot&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">p_current&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="c1"># 选择第一个元素为pivot变量&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># 分区&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">pivot&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1"># pivot元素在第一个，把小于pivot的元素从第二位开始逐个往后放&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">p_current&lt;/span>&lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">p_current&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">p_current&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">p_current&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">p_current&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="c1"># 把pivot与小于pivot的最后一个元素交换，让pivot元素成为分界线&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">quickSort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p_current&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">quickSort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p_current&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="堆排序">堆排序&lt;/h2>
&lt;p>&lt;strong>分类&lt;/strong>：比较排序大类，选择排序小类，没想到把堆排序和选择排序是亲戚。&lt;/p>
&lt;p>TIPS：堆是一种完全二叉树。大顶堆就是每个父节点都比其子节点大，小顶堆就是每个父节点都比子节点小。&lt;/p>
&lt;p>&lt;strong>核心思想&lt;/strong>：用给定数组建立大顶堆，&lt;strong>我们每次都选择大顶堆的树根节点（顶部节点），相当于选择排序中选取最大点&lt;/strong>。然后将其于未排序的最后节点交换，排在最后的就是有序区域。由于交换后可能破坏了堆的结构，因此堆无序区域进行调整。因此得到最大元素，直至完成排序。&lt;/p>
&lt;p>&lt;strong>细节&lt;/strong>：每次调整堆的过程叫做“Heapify”，是一个递归调整的过程。在第一次建立堆时，从最后一个非叶子节点从后往前以此调整。&lt;/p>
&lt;p>&lt;strong>性能&lt;/strong>：每次调整堆的最好、平均、最坏复杂度都是$O(\log n)$，一共需要调整$n$次，所以总体复杂度为$O(n\log n)$，其性能稳定性继承了选择排序的风格，空间复杂度为$O(1)$，这个排序和选择排序一样也是不稳定的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="ln"> 1&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="s2">堆中父子节点关系
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="s2">parentIndex = int((childIndex-1)/2)
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="s2">leftChildIndex = 2 * parentIndex + 1
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="s2">rightChildIndex = 2 * parentIndex + 2
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span class="ln"> 7&lt;/span>&lt;span class="k">def&lt;/span> &lt;span class="nf">heapify&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># 修改顶部元素后重新堆化&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">maxIndex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">leftChildIndex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">leftChildIndex&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">None&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">leftChildIndex&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">maxIndex&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">maxIndex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">leftChildIndex&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">rightChildIndex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">rightChildIndex&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">None&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">rightChildIndex&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">maxIndex&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">maxIndex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">rightChildIndex&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">maxIndex&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">maxIndex&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">maxIndex&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="n">heapify&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">maxIndex&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;span class="ln">21&lt;/span>
&lt;span class="ln">22&lt;/span>&lt;span class="k">def&lt;/span> &lt;span class="nf">build_heap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1"># 将任一数列变成大顶堆&lt;/span>
&lt;span class="ln">23&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">24&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;span class="ln">25&lt;/span> &lt;span class="n">lastNodeIndex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="ln">26&lt;/span> &lt;span class="n">lastNodeParentIndex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">lastNodeIndex&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 从最后一个非叶子节点，往前依次heapify&lt;/span>
&lt;span class="ln">27&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lastNodeParentIndex&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="ln">28&lt;/span> &lt;span class="n">heapify&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">29&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;span class="ln">30&lt;/span>
&lt;span class="ln">31&lt;/span>&lt;span class="k">def&lt;/span> &lt;span class="nf">heapSort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">32&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">build_heap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">33&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)):&lt;/span>
&lt;span class="ln">34&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1"># 顶元素与最后一个未排序元素交换&lt;/span>
&lt;span class="ln">35&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">heapify&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">36&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="以上都是通过比较来排序还有一些非比较的排序方法有以下三类">以上都是通过比较来排序，还有一些非比较的排序方法，有以下三类&lt;/h2>
&lt;h2 id="计数排序">计数排序&lt;/h2>
&lt;p>&lt;strong>分类&lt;/strong>：非比较排序。&lt;/p>
&lt;p>&lt;strong>核心思想&lt;/strong>：其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。&lt;/p>
&lt;p>&lt;strong>细节&lt;/strong>：计数排序要求输入的数据必须是&lt;strong>有确定范围的整数&lt;/strong>。从新数组取元素应从后往前取，保证稳定性。&lt;/p>
&lt;p>&lt;strong>优化思路&lt;/strong>：由于元素最小值可能远大于0，所以可以通过 &lt;code>所有元素-MIN&lt;/code>的方式来做偏置，降低所要开辟的空间。&lt;/p>
&lt;p>&lt;strong>性能&lt;/strong>：时间复杂度$O(n+k)$（未优化），其中$k$是元素最大值。空间复杂度也是$O(n+k)$，稳定排序&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="ln"> 1&lt;/span>&lt;span class="k">def&lt;/span> &lt;span class="nf">countingSort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1"># 避免max函数出错&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">maxNum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="n">newArr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maxNum&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="n">newArr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="c1"># 将l中的元素作为newArr中的序号&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">sortedIndex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">newArr&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># 从后往前取，保证稳定性&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="n">newArr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">sortedIndex&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">j&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="n">sortedIndex&lt;/span> &lt;span class="o">-=&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">newArr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-=&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="桶排序">桶排序&lt;/h2>
&lt;p>&lt;strong>分类&lt;/strong>：非比较排序。&lt;/p>
&lt;p>&lt;strong>核心思想&lt;/strong>：假设输入数据服从均匀分布，将数据&lt;strong>分到有限数量的桶里&lt;/strong>，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。&lt;strong>进桶粗排，桶内细排&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>细节&lt;/strong>：在额外空间充足的情况下，尽量增大桶的数量，可以令桶的个数等于元素的个数。&lt;/p>
&lt;p>&lt;strong>性能&lt;/strong>：平均时间复杂度$O(n+k)$，最坏时间复杂度$O(n^{2})$(所有元素放到一个桶里)。空间复杂度$O(n+k)$，其中k是桶的个数。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="ln"> 1&lt;/span>&lt;span class="k">def&lt;/span> &lt;span class="nf">bucketSort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">minNum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">min&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="n">maxNum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">minNum&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">maxNum&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1"># 数据都一样&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="c1"># 假设我们令桶的个数等于元素的个数&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="n">bucketNum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="c1"># 桶的大小&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">bucketRange&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">maxNum&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">minNum&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">bucketNum&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="c1"># 桶数组&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">bucketList&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[[]&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bucketNum&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="c1"># 将元素分配到桶中&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">bucketList&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">minNum&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">bucketRange&lt;/span>&lt;span class="p">)]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 先通过桶粗排序&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">clear&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">bucketList&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">19&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1"># 排除空桶&lt;/span>
&lt;span class="ln">20&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sort&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">21&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">extend&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 在桶内部使用了系统默认的排序方法&lt;/span>
&lt;span class="ln">22&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="基数排序">基数排序&lt;/h2>
&lt;p>&lt;strong>分类&lt;/strong>：非比较排序。&lt;/p>
&lt;p>&lt;strong>核心思想&lt;/strong>：从低位开始，先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小......（但是我没明白为什么这样排完之后就可以了）。本质是多关键字排序，也可以算是桶排序的一种。&lt;/p>
&lt;p>&lt;strong>细节&lt;/strong>：&lt;code>while&lt;/code>内循环实际上是以0-9为10个桶的桶排序。但是我没明白这种排序的实际机制。&lt;/p>
&lt;p>&lt;strong>性能&lt;/strong>：时间复杂度为$O(n*k)$，其中$k$是最大数字的位数。空间复杂度为$O(n+k)$，稳定排序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="ln"> 1&lt;/span>&lt;span class="k">def&lt;/span> &lt;span class="nf">baseSort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="n">maxNum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="n">base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="n">maxNum&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">base&lt;/span> &lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="c1"># 以0-9为10个桶,while内循实际上是桶排序&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">bucketList&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[[]&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="n">bucketList&lt;/span>&lt;span class="p">[(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">base&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">list&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">bucketList&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">extend&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="n">base&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">l&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>排序算法分类&lt;/p>
&lt;ul>
&lt;li>比较类排序：通过比较来决定元素间的相对次序，由于其&lt;strong>时间复杂度不能突破O(nlogn)&lt;/strong>，因此也称为非线性时间比较类排序。&lt;/li>
&lt;li>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以&lt;strong>线性时间运行&lt;/strong>，因此也称为线性时间非比较类排序。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="../../images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png" alt="排序算法分类">&lt;/p>
&lt;p>排序算法复杂度
&lt;img src="../../images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="排序算法复杂度">&lt;/p></description></item></channel></rss>