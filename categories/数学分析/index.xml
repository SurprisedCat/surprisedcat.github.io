<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数学分析 on SurprisedCat</title><link>https://surprisedcat.github.io/categories/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/</link><description>Recent content in 数学分析 on SurprisedCat</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2020–2021, SurprisedCat; all rights reserved.</copyright><lastBuildDate>Wed, 01 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://surprisedcat.github.io/categories/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml"/><item><title>复变函数之复变函数微积分（微分篇）</title><link>https://surprisedcat.github.io/studynotes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B9%8B%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E5%BE%AE%E7%A7%AF%E5%88%86%E5%BE%AE%E5%88%86%E7%AF%87/</link><pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/studynotes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B9%8B%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E5%BE%AE%E7%A7%AF%E5%88%86%E5%BE%AE%E5%88%86%E7%AF%87/</guid><description>
&lt;h2 id="复变函数微积分微分篇">复变函数微积分（微分篇） &lt;!-- omit in toc -->&lt;/h2>
&lt;p>复变函数的形式很特殊，定义的形式、性质都接近于一元实函数，但是函数的实部、虚部又可以分成两个二元实函数，因此一些二元函数的处理方式也可以应用到复函数中，一元复函数的许多性质证明也是利用二元实函数。同时，在复函数组成实部、虚部的两个二元实函数又不是独立的，尤其在复函数可微、可积时，它们又有着密切联系，如C-R方程、拉普拉斯方程等，我们利用这些关系可以得出一般二元实函数所没有的结论。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#复变函数定义">复变函数定义&lt;/a>&lt;/li>
&lt;li>&lt;a href="#复函数的基本性质">复函数的基本性质&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#复函数极限">复函数极限&lt;/a>&lt;/li>
&lt;li>&lt;a href="#复函数连续性">复函数连续性&lt;/a>&lt;/li>
&lt;/ul>&lt;/li>
&lt;li>&lt;a href="#复变函数的导数与微分">复变函数的导数与微分&lt;/a>&lt;/li>
&lt;li>&lt;a href="#再看全纯函数解析函数">再看全纯函数（解析函数）&lt;/a>&lt;/li>
&lt;li>&lt;a href="#柯西-黎曼方程c-r方程">柯西-黎曼方程（C-R方程）&lt;/a>&lt;/li>
&lt;li>&lt;a href="#全纯函数解析函数与调和函数">全纯函数（解析函数）与调和函数&lt;/a>&lt;/li>
&lt;li>&lt;a href="#初等复函数">初等复函数&lt;/a>&lt;/li>
&lt;li>&lt;a href="#基础指数函数">基础：指数函数&lt;/a>&lt;/li>
&lt;li>&lt;a href="#对数函数">对数函数&lt;/a>&lt;/li>
&lt;li>&lt;a href="#幂函数">幂函数&lt;/a>&lt;/li>
&lt;li>&lt;a href="#三角函数">三角函数&lt;/a>&lt;/li>
&lt;li>&lt;a href="#双曲函数">双曲函数&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="复变函数定义">复变函数定义&lt;/h2>
&lt;blockquote>
&lt;p>复变函数： 设在复平面&lt;span class="math">\(\mathbb{C}\)&lt;/span>上有一点集&lt;span class="math">\(E\)&lt;/span>，如果对于&lt;span class="math">\(E\)&lt;/span>内每一点&lt;span class="math">\(z\)&lt;/span>值，都有一个或&lt;strong>多个&lt;/strong>复数值&lt;span class="math">\(w\)&lt;/span>与之对应，则称&lt;span class="math">\(w\)&lt;/span>为&lt;span class="math">\(z\)&lt;/span>的&lt;strong>复函数&lt;/strong>，记为&lt;span class="math">\(w=f(z)\)&lt;/span>，&lt;span class="math">\(E\)&lt;/span>为定义域，可表示为： &lt;span class="math">\[\forall z\in E, \exist w = f(z)\tag{1}\]&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>和过去实函数的定义的有个区别，实函数中要求函数值只有一个，即单值函数，而复函数可以让一个自变量对应多个因变量，即&lt;strong>多值函数&lt;/strong>。多值函数除了应用在在复变函数以外，还广泛应用于隐函数，特别地，不定积分也是常见的多值函数（后面会跟一个任意常数&lt;span class="math">\(C\)&lt;/span>）。&lt;/p>
&lt;p>根据复函数可分为实部和虚部的特点，我们可以将其拆分为两个实二元函数，即 &lt;span class="math">\[
\begin{aligned}
z&amp;amp; = x + i y\\
w &amp;amp;= u + i v\\
w &amp;amp;= f(z) = f(x,y)\\
&amp;amp;=u(x,y)+iv(x,y)
\end{aligned}\tag{2}
\]&lt;/span> 这样一元复函数就变成了两个二元实函数的&lt;strong>有序&lt;/strong>组合。因此，我们可以同时用一元函数和二元函数的方式去研究复函数。由于复函数的这种复杂性，也很难用一幅函数图像完整地描述复函数。&lt;/p>
&lt;p>目前大多数基础数学都是研究单复变函数，因为多复变函数的复杂性远远大于单复变函数，并且是20世纪重要的数学成就之一。&lt;strong>本文默认所讨论的复变函数当时单复变函数&lt;/strong>。&lt;/p>
&lt;h3 id="复函数的基本性质">复函数的基本性质&lt;/h3>
&lt;p>如果只看一元复函数，其性质和一元实函数很多是一样的，也有地方会有稍许区别。同时，由于一个复函数对应两个二元实函数的有序组合，因此他们之间也是有联系的。&lt;/p>
&lt;h4 id="复函数极限">复函数极限&lt;/h4>
&lt;blockquote>
&lt;p>极限： 设函数&lt;span class="math">\(w=f(z)\)&lt;/span>在&lt;span class="math">\(z_0\)&lt;/span>的去心邻域&lt;span class="math">\(|z-z_0|&amp;lt;\rho\)&lt;/span>内有定义，如存在复数&lt;span class="math">\(A\neq \infty, \forall \varepsilon &amp;gt;0, \exist \delta&amp;gt;0\)&lt;/span>使得当&lt;span class="math">\(0&amp;lt;|z-z_0|&amp;lt;\delta\)&lt;/span>，有&lt;span class="math">\(|f(z)-A|&amp;lt;\varepsilon\)&lt;/span>，则称&lt;span class="math">\(A\)&lt;/span>为函数&lt;span class="math">\(w=f(z)\)&lt;/span>当&lt;span class="math">\(z\)&lt;/span>趋向于&lt;span class="math">\(z_0\)&lt;/span>时的极限，记作&lt;span class="math">\(\lim\limits_{z\rightarrow z_0} f(z)=A\)&lt;/span>（极限存在不一定需要函数值在&lt;span class="math">\(z_0\)&lt;/span>有定义）。&lt;/p>
&lt;/blockquote>
&lt;p>从定义来看和一元实函数基本一样，不过需要强调，在一元实函数中，&lt;span class="math">\(x\)&lt;/span>只会从&lt;span class="math">\(x_0\)&lt;/span>正负两个方向趋近，&lt;strong>在复函数中&lt;span class="math">\(z\)&lt;/span>趋向于&lt;span class="math">\(z_0\)&lt;/span>的方向是任意的&lt;/strong>。复函数极限的几何意义是当自变量&lt;span class="math">\(z\)&lt;/span>一旦进入&lt;span class="math">\(z_0\)&lt;/span>充分小的&lt;span class="math">\(\delta\)&lt;/span>邻域时，它的像点&lt;span class="math">\(w=f(z)\)&lt;/span>就落在&lt;span class="math">\(A\)&lt;/span>预先给带的&lt;span class="math">\(\varepsilon\)&lt;/span>邻域内。&lt;/p>
&lt;p>&lt;img src="../../images/复函数极限.png" alt="复函数极限" />)&lt;/p>
&lt;p>复函数极限的运算性质和一元实函数是一样的：当&lt;span class="math">\(\lim\limits_{z\rightarrow z_0} f(z)=A, \lim\limits_{z\rightarrow z_0} g(z)=B\)&lt;/span>时&lt;/p>
&lt;ul>
&lt;li>&lt;span class="math">\(\lim\limits_{z\rightarrow z_0}[f(z)\plusmn g(z)]=A\plusmn B\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\(\lim\limits_{z\rightarrow z_0}[f(z)\cdot g(z)]=A\cdot B\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\(\lim\limits_{z\rightarrow z_0}[f(z)/g(z)]=A/B, (B\neq 0)\)&lt;/span>&lt;/li>
&lt;/ul>
&lt;p>由于一元复函数和两个二元实函数的对应关系，我们可以得到如下结论：&lt;/p>
&lt;blockquote>
&lt;p>由于&lt;span class="math">\(f(z)=u(x,y)+iv(x,y)\)&lt;/span>，设&lt;span class="math">\(A=u_0+iv_0,\ z_0=x_0+iy_0\)&lt;/span>，则 &lt;span class="math">\[\lim\limits_{z\rightarrow z_0} f(z)=A \Leftrightarrow \lim\limits_{x\rightarrow x_0\atop y\rightarrow y_0} u(x,y)=u_0,\ \lim\limits_{x\rightarrow x_0\atop y\rightarrow y_0} v(x,y)=v_0\tag{3}\]&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>从多元函数角度，也说明我们需要考虑所有趋近方向来证明极限的存在性。&lt;/p>
&lt;h4 id="复函数连续性">复函数连续性&lt;/h4>
&lt;blockquote>
&lt;p>若&lt;span class="math">\(\lim\limits_{z\rightarrow z_0} f(z)=f(z_0)\)&lt;/span>，则称&lt;span class="math">\(f(z)\)&lt;/span>在&lt;span class="math">\(z_0\)&lt;/span>点连续。若&lt;span class="math">\(f(z)\)&lt;/span>在区域&lt;span class="math">\(D\)&lt;/span>内处处连续，则称函数&lt;span class="math">\(f(z)\)&lt;/span>在&lt;span class="math">\(D\)&lt;/span>内连续。&lt;/p>
&lt;/blockquote>
&lt;p>连续三要素：&lt;span class="math">\(f(z_0)\)&lt;/span>存在、&lt;span class="math">\(\lim\limits_{z\rightarrow z_0} f(z)\)&lt;/span>存在、二者相等。就是通常所说的当自变量充分靠近时，函数值充分靠近。从定义来看，复函数的连续也和一元实函数定义是一样的。&lt;/p>
&lt;p>复函数连续的运算性质也和一元实函数一致：&lt;/p>
&lt;ul>
&lt;li>在&lt;span class="math">\(z_0\)&lt;/span>连续的两个函数&lt;span class="math">\(f(z),\ g(z)\)&lt;/span>的和、差、积、商在&lt;span class="math">\(z_0\)&lt;/span>处连续。&lt;/li>
&lt;li>如果函数&lt;span class="math">\(\xi=g(z)\)&lt;/span>在点&lt;span class="math">\(z_0\)&lt;/span>处连续，函数&lt;span class="math">\(f(\xi)\)&lt;/span>在&lt;span class="math">\(\xi_0=g(z_0)\)&lt;/span>处连续，则复合函数&lt;span class="math">\(w=f(g(z))\)&lt;/span>在&lt;span class="math">\(z_0\)&lt;/span>处连续。&lt;/li>
&lt;li>如果函数&lt;span class="math">\(f(z)\)&lt;/span>在有界闭区域&lt;span class="math">\(\bar{D}\)&lt;/span>上连续，则：&lt;/li>
&lt;li>&lt;span class="math">\(|f(z)|\)&lt;/span>在&lt;span class="math">\(\bar{D}\)&lt;/span>上必有界。&lt;/li>
&lt;li>&lt;span class="math">\(|f(z)|\)&lt;/span>在&lt;span class="math">\(\bar{D}\)&lt;/span>上必能取到最大、最小值。&lt;/li>
&lt;li>&lt;span class="math">\(|f(z)|\)&lt;/span>在&lt;span class="math">\(\bar{D}\)&lt;/span>上必一致连续。&lt;/li>
&lt;/ul>
&lt;p>当考虑到复函数与两个二元函数的关系，我们还有以下性质：&lt;/p>
&lt;blockquote>
&lt;p>复函数&lt;span class="math">\(f(z)=u(x,y)+iv(x,y)\)&lt;/span>在&lt;span class="math">\(z_0=x_0+iy_0\)&lt;/span>点连续&lt;span class="math">\(\Leftrightarrow u(x,y),\ v(x,y)\)&lt;/span>在点&lt;span class="math">\((x_0,y_0)\)&lt;/span>点连续。&lt;/p>
&lt;/blockquote>
&lt;h2 id="复变函数的导数与微分">复变函数的导数与微分&lt;/h2>
&lt;p>如果要问复分析研究的核心问题，&lt;strong>纯函数和亚纯函数&lt;/strong>应该算是其中之一。维基百科上说：“复分析（英语：Complex analysis）是研究复变的函数，特别是亚纯函数和复变解析函数（全纯函数）的数学理论。”而这两种函数都需要一个概念就是&lt;strong>复函数的微分&lt;/strong>。接下来我们也会说明，当复函数可微时，其实部函数&lt;span class="math">\(u(x,y)\)&lt;/span>和虚部函数&lt;span class="math">\(v(x,y)\)&lt;/span>也会有很强的关联性。&lt;/p>
&lt;p>我们先来看看什么是全纯函数、半纯函数。&lt;/p>
&lt;blockquote>
&lt;p>全纯函数（holomorphic function）:定义在复平面&lt;span class="math">\(\mathbb{C}\)&lt;/span>的开子集上的，在复平面&lt;span class="math">\(\mathbb{C}\)&lt;/span>中取值的，在&lt;strong>每点上皆可微的函数&lt;/strong>。复变函数中全纯函数也叫&lt;strong>解析函数&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;p>下文中默认解析和全纯是同义词，不过对于函数的某点&lt;span class="math">\(z_0\)&lt;/span>，我们习惯用“解析性”一词来讨论点的微分性质。&lt;/p>
&lt;blockquote>
&lt;p>亚纯函数（meromorphic function）:一个复平面的开子集&lt;span class="math">\(D\)&lt;/span>上的亚纯函数是一个在&lt;span class="math">\(D\)&lt;/span>上&lt;strong>除一个或若干个孤点集合之外的区域全纯的函数&lt;/strong>，那些孤立点称为该函数的&lt;strong>极点或奇点&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;p>从定义中可以看出，这个&lt;strong>函数“纯不纯”得看它可不可微&lt;/strong>。而复函数的可微就很微妙。&lt;/p>
&lt;p>首先，一元复函数和一元实函数一样，可微&lt;span class="math">\(\Leftrightarrow\)&lt;/span>可导。不过，复函数可微，可导不像一元实函数可微那么容易，需要从二元函数的角度考虑极限趋近的方向，此外实部和虚部两个二元函数间还必须满足特定关系，复函数才能可微、可导。因此，&lt;strong>一元复函数可微、可导是比一元实函数可微，甚至多元实函数可微强得多的条件&lt;/strong>。&lt;/p>
&lt;p>一元复函数导数的定义和一元实函数是类似的：&lt;/p>
&lt;blockquote>
&lt;p>设复函数&lt;span class="math">\(w=f(z)\)&lt;/span>定义于区域&lt;span class="math">\(D\)&lt;/span>，在&lt;span class="math">\(z_0\in D\)&lt;/span>的某邻域内&lt;span class="math">\(z_0+\Delta z\)&lt;/span>有定义，如果 &lt;span class="math">\[\lim_{\Delta z\rightarrow 0}\frac{\Delta w}{\Delta z}=\lim_{\Delta z\rightarrow 0}\frac{f(z_0+\Delta z)-f(z_0)}{\Delta z}\tag{4}\]&lt;/span> 存在，则称&lt;span class="math">\(f(z)\)&lt;/span>在&lt;span class="math">\(z_0\)&lt;/span>处可导，该极限值为点&lt;span class="math">\(z_0\)&lt;/span>处的导数，记为&lt;span class="math">\(f&amp;#39;(z_0)\)&lt;/span>或&lt;span class="math">\(\frac{\mathrm{d}w}{\mathrm{d}z}|_{z=z_0}\)&lt;/span>。如果函数&lt;span class="math">\(f(z)\)&lt;/span>在&lt;span class="math">\(D\)&lt;/span>内的每一点都可导，则称&lt;span class="math">\(f(z)\)&lt;/span>在&lt;span class="math">\(D\)&lt;/span>内可导，此时即得&lt;span class="math">\(f(z)\)&lt;/span>的导函数&lt;span class="math">\(f&amp;#39;(z)\)&lt;/span>。&lt;/p>
&lt;/blockquote>
&lt;p>可见一元复函数导数的定义和一元实函数是类似，只不过求极限时方向不止正负方向，而是任意方向。类似地，我们可以通过和一元实函数相同的方法得到复函数微分。&lt;/p>
&lt;p>根据极限定义，当导数存在时，式（4）可以改写成： &lt;span class="math">\[
\lim_{\Delta{z}\rightarrow 0} \Delta w = f&amp;#39;(z_0)\Delta z + o(\Delta z)\tag{5}
\]&lt;/span> 这样函数的增量&lt;span class="math">\(\Delta w\)&lt;/span>就表示成了&lt;strong>自变量线性增量和自变量的高阶无穷小两部分，而这也恰恰是微分的定义&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>设函数&lt;span class="math">\(w=f(z)\)&lt;/span>定义于区域&lt;span class="math">\(D\)&lt;/span>，在&lt;span class="math">\(z_0\in D\)&lt;/span>的某邻域内&lt;span class="math">\(z_0+\Delta z\)&lt;/span>有定义，对于邻域内任一点，如果存在&lt;span class="math">\(A\)&lt;/span>，使得 &lt;span class="math">\[\Delta w = f(z+\Delta z)-f(z)=A\Delta(z)+o(\Delta z)\tag{6}\]&lt;/span> 则称&lt;span class="math">\(f(z)\)&lt;/span>在&lt;span class="math">\(z_0\)&lt;/span>处可微，&lt;span class="math">\(A\Delta z\)&lt;/span>为微分，记作&lt;span class="math">\(\mathrm{d}w = A\mathrm{d}z\)&lt;/span>。如果函数&lt;span class="math">\(f(z)\)&lt;/span>在&lt;span class="math">\(D\)&lt;/span>内的每一点都可微，则称&lt;span class="math">\(f(z)\)&lt;/span>在&lt;span class="math">\(D\)&lt;/span>内可微。&lt;/p>
&lt;/blockquote>
&lt;p>复函数导数侧重反映函数的“变化率”；而微分更能体现“以直代曲”的逼近思想。当&lt;span class="math">\(\Delta z\)&lt;/span>充分小时，两种思想是共同的。从上面也不难发现，对于一元复函数，可导可微互为充要条件。&lt;/p>
&lt;blockquote>
&lt;p>可导&lt;span class="math">\(\Leftrightarrow\)&lt;/span> 可微，即&lt;span class="math">\(\mathrm{d}w=f&amp;#39;(z)\mathrm{d}z,\ f&amp;#39;(z)=\frac{\mathrm{d}w}{\mathrm{d}z}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>简要证明如下：&lt;/p>
&lt;p>可导&lt;span class="math">\(\Rightarrow\)&lt;/span> 可微。可导&lt;span class="math">\(\Rightarrow \lim\limits_{\Delta z\rightarrow 0}\frac{\Delta w}{\Delta z}=f&amp;#39;(z) \Rightarrow \Delta w = f&amp;#39;(z_0)\Delta z + o(\Delta z)\Rightarrow\)&lt;/span>可微&lt;/p>
&lt;p>可导&lt;span class="math">\(\Leftarrow\)&lt;/span> 可微。可微&lt;span class="math">\(\Rightarrow \Delta w = A\Delta z + o(\Delta z) \Rightarrow \frac{\Delta w}{\Delta z}=A+\frac{o(\Delta z)}{\Delta z} \Rightarrow \lim\limits_{\Delta z\rightarrow 0}\frac{\Delta w}{\Delta z}=A=f&amp;#39;(z)\Rightarrow\)&lt;/span>可导。&lt;/p>
&lt;p>综合前面函数连续的内容，我们可以得出一个和一元实函数一样的关系：&lt;/p>
&lt;blockquote>
&lt;p>可微&lt;span class="math">\(\Leftrightarrow\)&lt;/span>可导&lt;span class="math">\(\Rightarrow\)&lt;/span>连续&lt;span class="math">\(\Rightarrow\)&lt;/span>有极限&lt;/p>
&lt;/blockquote>
&lt;p>此外，通过定义可证明复函数求导、微分的法则也和一元实函数一样：&lt;/p>
&lt;ul>
&lt;li>四则运算法则。&lt;/li>
&lt;li>&lt;span class="math">\([f(z)\plusmn g(z)]&amp;#39;=f&amp;#39;(z)\plusmn g&amp;#39;(z)\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\([f(z)g(z)]&amp;#39;=f&amp;#39;(z)g(z)+f(z)g&amp;#39;(z)\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\([\frac{f(z)}{g(z)}]&amp;#39;=\frac{f&amp;#39;(z)g(z)-f(z)g&amp;#39;(z)}{g^2(z)},g(z)\neq 0\)&lt;/span>&lt;/li>
&lt;li>复合函数求导法则：&lt;span class="math">\([f(g(z))]&amp;#39;=f&amp;#39;(g(z))g&amp;#39;(z)\)&lt;/span>&lt;/li>
&lt;li>反函数求导法则（注意只针对单值函数）：&lt;span class="math">\(\varphi&amp;#39;(w)=\frac{1}{f&amp;#39;(z)},\ z=\varphi(w),\ w=f(z)\)&lt;/span>&lt;/li>
&lt;/ul>
&lt;h3 id="再看全纯函数解析函数">再看全纯函数（解析函数）&lt;/h3>
&lt;p>我们再回看全纯函数和可导的关系，对于某一点&lt;span class="math">\(z_0\)&lt;/span>而言，全纯要求函数&lt;span class="math">\(f(z)\)&lt;/span>在&lt;span class="math">\(z_0\)&lt;/span>及其邻域内都可微，不仅仅是那一个点，因此对于某个点而言，点解析的要求比点可导要更强： &lt;span class="math">\[
点解析\Rightarrow 点可导/可微
\]&lt;/span> 举个例子：&lt;span class="math">\(f(z)=|z|^2\)&lt;/span>，该函数仅在&lt;span class="math">\(z=0\)&lt;/span>处可导（其他位置都不可导），但是不解析。&lt;/p>
&lt;p>当我们考虑一个区域&lt;span class="math">\(D\)&lt;/span>时，点和周围的邻域一直都是被一起考虑的，因此对区域&lt;span class="math">\(D\)&lt;/span>来说，解析和可导/可微是等价的。 &lt;span class="math">\[
区域解析\Leftrightarrow 区域可导/可微
\]&lt;/span>&lt;/p>
&lt;p>解析函数的性质和导数性质也是类似的：&lt;/p>
&lt;ul>
&lt;li>在区域&lt;span class="math">\(D\)&lt;/span>内解析的两个函数&lt;span class="math">\(f(z),\ g(z)\)&lt;/span>的和、差、积、商（除去分母为0的点）在&lt;span class="math">\(D\)&lt;/span>内解析。&lt;/li>
&lt;li>推论：多项式复函数都是解析的（全纯函数）；有理式复函数在分母不为0的点也是解析的（半纯函数）；&lt;/li>
&lt;li>复合函数在对应的解析区域内也解析。&lt;/li>
&lt;/ul>
&lt;p>现在这么一看，一元复函数和一元实函数的微分性质似乎是完全一样，那么就没有必要特地研究复函数了。实际上，复函数可微的要求是比一元函数严格的多的，这个严格的体现就是：&lt;strong>全纯函数从各个方向求极限得到的导数都一致&lt;/strong>。只有在这个大前提下，复函数才能有类似于一元实函数的简单性质。&lt;/p>
&lt;h3 id="柯西-黎曼方程c-r方程">柯西-黎曼方程（C-R方程）&lt;/h3>
&lt;p>前文说过，复函数解析要求点及邻域从各个方向求极限得到的导数都一致，这很容易让我们想到多元函数导数中的方向导数。不过，相较于一个二元实函数，我们已经指出复函数对应的是两个二元实函数的有序对。因此，复函数可导不仅要求实部、虚部两个二元函数各自从各个方向的方向导数一致，还要求两个函数之间满足特殊的关系，这就是&lt;strong>柯西-黎曼方程&lt;/strong>。&lt;/p>
&lt;p>柯西-黎曼方程体现的是复函数&lt;span class="math">\(f(z)\)&lt;/span>的实部二元函数&lt;span class="math">\(u(x,y)\)&lt;/span>与虚部二元函数&lt;span class="math">\(v(x,y)\)&lt;/span>之间的关系。从复函数可导推出柯西-黎曼方程是很容易的。由于复函数可导，可知： &lt;span class="math">\[
f&amp;#39;(z)=\lim_{\Delta x\rightarrow 0\atop \Delta y\rightarrow 0}\frac{\Delta u +i\Delta v}{\Delta x +i\Delta y}\tag{7}
\]&lt;/span> 函数在&lt;span class="math">\(z\)&lt;/span>点可导，就意味着&lt;span class="math">\(∆z = ∆x + i∆y\)&lt;/span>以任意方式趋向于零，上式右边的极限都趋于同样的有限值，即该点导数值&lt;span class="math">\(f&amp;#39;(z)\)&lt;/span>。在&lt;span class="math">\(z\)&lt;/span>平面上有无限条线路使&lt;span class="math">\(∆z\rightarrow 0\)&lt;/span>, 我们选取如下两条路线：&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/柯西-黎曼方程推导.png" alt="柯西-黎曼方程推导" />&lt;p class="caption">柯西-黎曼方程推导&lt;/p>
&lt;/div>
&lt;ol style="list-style-type: decimal">
&lt;li>&lt;span class="math">\(∆x\rightarrow 0\)&lt;/span>但&lt;span class="math">\(∆y = 0\)&lt;/span>，&lt;span class="math">\(f&amp;#39;(z)=\lim\limits_{∆x\rightarrow 0\atop ∆y = 0}\frac{∆u+i∆v}{∆x} = \frac{\partial u}{\partial x}+i\frac{\partial v}{\partial x}\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\(∆y\rightarrow 0\)&lt;/span>但&lt;span class="math">\(∆x = 0\)&lt;/span>，&lt;span class="math">\(f&amp;#39;(z)=\lim\limits_{∆y\rightarrow 0\atop ∆x = 0}\frac{∆u+i∆v}{i∆y} = \frac{\partial v}{\partial y}-i\frac{\partial u}{\partial y}\)&lt;/span>&lt;/li>
&lt;/ol>
&lt;p>联立上方两个石子，且要求实部与虚部相等，有：&lt;/p>
&lt;p>&lt;span class="math">\[
\frac{\partial u}{\partial x}=\frac{\partial v}{\partial y},\\
\frac{\partial u}{\partial y}=-\frac{\partial v}{\partial x} \tag{8}
\]&lt;/span> 即为柯西-黎曼方程，简称C-R方程。可见，并不是任意两个二元实函数组成一对的复函数都是可导的，他们之间至少得满足C-R方程（必要条件）。根据C-R方程，我们也能得出，&lt;strong>一旦复函数是个解析函数，其实部（虚部）一旦给定，则虚部（实部）也基本确定&lt;/strong>。为什么说是基本确定呢？后面我们谈到调和函数的时候在细说。 &lt;span class="math">\[
u(x,y) = \int \frac{\partial v}{\partial y} \mathrm{d}x = \int -\frac{\partial v}{\partial x} \mathrm{d}y\\
v(x,y) = \int \frac{\partial u}{\partial x} \mathrm{d}y = \int -\frac{\partial u}{\partial y} \mathrm{d}x\tag{9}
\]&lt;/span>&lt;/p>
&lt;p>如果想要让C-R方程变成可导的充分条件，还需要加上什么要求呢？很简单，再要求&lt;span class="math">\(u(x,y),\ v(x,y)\)&lt;/span>可微即可。&lt;/p>
&lt;blockquote>
&lt;p>点可导充要条件：函数&lt;span class="math">\(w=f(z)=u(x,y)+iv(x,y)\)&lt;/span>在点&lt;span class="math">\(z=x+iy\)&lt;/span>处可导的充要条件是：&lt;span class="math">\(u(x,y)\)&lt;/span>和&lt;span class="math">\(v(x,y)\)&lt;/span>在点&lt;span class="math">\((x,y)\)&lt;/span>处&lt;strong>可微且满足柯西-黎曼方程&lt;/strong>。&lt;/p>
&lt;p>区域解析（可导）的充要条件：函数&lt;span class="math">\(w=f(z)=u(x,y)+iv(x,y)\)&lt;/span>在区域&lt;span class="math">\(D\)&lt;/span>内解析的充要条件是：&lt;span class="math">\(u(x,y)\)&lt;/span>和&lt;span class="math">\(v(x,y)\)&lt;/span>在&lt;strong>区域&lt;span class="math">\(D\)&lt;/span>内可微且满足柯西-黎曼方程&lt;/strong>。区域可导和区域解析互为充要条件。&lt;/p>
&lt;/blockquote>
&lt;p>上面定理的必要性是显然的。简要证明如下。&lt;/p>
&lt;p>证明：首先C-R方程就是从可微复函数两个方向求方向导数得出来的，其次，复函数可微说明它可以写成&lt;span class="math">\(\Delta w = A \Delta z + o(\Delta z)\)&lt;/span>的形式，其中自变量和因变量的增量分别可以表示成实部与虚部的组合&lt;span class="math">\(\Delta w = \Delta u + i \Delta v, \Delta z = \Delta x + i\Delta y\)&lt;/span>。重要的是系数&lt;span class="math">\(A=f&amp;#39;(z)\)&lt;/span>是个固定的复数，即&lt;span class="math">\(A=a+ib\)&lt;/span>。将它们分别带入就可得： &lt;span class="math">\[
\Delta u + i \Delta v = (a+ib)(\Delta x + i\Delta y) + o(\Delta z)\\
\begin{cases}
\Delta u = a\Delta x - b \Delta y + o(\Delta z)\\
\Delta v = a\Delta y + b \Delta x + o(\Delta z)
\end{cases}\tag{10}
\]&lt;/span> 式(10)正是二元函数&lt;span class="math">\(u(x,y),v(x,y)\)&lt;/span>的微分形式。必要性得证。&lt;/p>
&lt;p>我们下面只要证明充分性，即C-R方程+两个部分的二元函数可微&lt;span class="math">\(\Rightarrow\)&lt;/span> 复函数可导。我们以点可导为例，区域可导的思路是一样的。&lt;/p>
&lt;p>证明：&lt;span class="math">\(u(x,y),\ v(x,y)\)&lt;/span>在&lt;span class="math">\((x,y)\)&lt;/span>可微则有： &lt;span class="math">\[
\begin{cases}
\Delta u = \frac{\partial u}{\partial x} \Delta x + \frac{\partial u}{\partial y} \Delta y + o(\Delta z)\\
\Delta v = \frac{\partial v}{\partial x} \Delta x + \frac{\partial v}{\partial y} \Delta y + o(\Delta z)
\end{cases}
\]&lt;/span> 根据C-R方程，我们可以将上面的&lt;span class="math">\(\frac{\partial u}{\partial y}\)&lt;/span>替换成&lt;span class="math">\(-\frac{\partial v}{\partial x}\)&lt;/span>，&lt;span class="math">\(\frac{\partial v}{\partial y}\)&lt;/span>替换成&lt;span class="math">\(\frac{\partial v}{\partial u}\)&lt;/span>，则有 &lt;span class="math">\[
\begin{cases}
\Delta u = \frac{\partial u}{\partial x} \Delta x {\color{Red}{- \frac{\partial v}{\partial x}}} \Delta y + o(\Delta z)\\
\Delta v = \frac{\partial v}{\partial x} \Delta x + {\color{Red}{\frac{\partial u}{\partial x}}} \Delta y + o(\Delta z)
\end{cases}\\
\Rightarrow \Delta u + i\Delta v = \frac{\partial u}{\partial x} \Delta x - \frac{\partial v}{\partial x} \Delta y + i\frac{\partial v}{\partial x} \Delta x+ i\frac{\partial u}{\partial x} \Delta y + o(\Delta z)\\
=\underbrace{(\frac{\partial u}{\partial x}+ i\frac{\partial v}{\partial x})}_{A}\underbrace{(\Delta x + i\Delta y)}_{\Delta z} + o(\Delta z)\\
=A\Delta z + o(\Delta z)
\]&lt;/span> 上式即为原复函数的微分形式。因此复函数在点&lt;span class="math">\(z\)&lt;/span>处可导。&lt;/p>
&lt;p>在多元函数微分中，还有这样一个关系：&lt;strong>一阶偏导数存在且连续则函数可微&lt;/strong>，我们同样可以将其应用到复函数可微中，替换实部、虚部的可微要求。（注意一阶偏导数连续是个更强的条件，不是充要条件）。从而有如下推论：&lt;/p>
&lt;blockquote>
&lt;p>推论：若函数&lt;span class="math">\(f(z) = u(x, y) + iv(x, y)\)&lt;/span>在&lt;span class="math">\(z\)&lt;/span>点满足C-R方程，且函数的四个一阶偏导数&lt;span class="math">\(\frac{\partial u}{\partial x},\frac{\partial u}{\partial y},\frac{\partial v}{\partial x},\frac{\partial v}{\partial y}\)&lt;/span>在&lt;span class="math">\(z\)&lt;/span>点连续，则函数在&lt;span class="math">\(z\)&lt;/span>点可导。&lt;/p>
&lt;/blockquote>
&lt;p>反之并不成立，原因在于可微不能推出偏导数连续。&lt;/p>
&lt;h3 id="全纯函数解析函数与调和函数">全纯函数（解析函数）与调和函数&lt;/h3>
&lt;p>解析函数实部和虚部的还不仅是C-R方程的关系，其自身也得满足&lt;strong>拉普拉斯方程&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>拉普拉斯方程：若二元实函数&lt;span class="math">\(\varphi(x,y)\)&lt;/span>在区域&lt;span class="math">\(D\)&lt;/span>内可微且有二阶偏导数，且有 &lt;span class="math">\[ \frac{\partial^2 \varphi}{\partial x^2} + \frac{\partial^2 \varphi}{\partial y^2} =0\tag{11}\]&lt;/span> 则称&lt;span class="math">\(\varphi(x,y)\)&lt;/span>满足拉普拉斯方程。&lt;/p>
&lt;/blockquote>
&lt;p>满足拉普拉斯方程的二元函数&lt;span class="math">\(\varphi(x,y)\)&lt;/span>为区域&lt;span class="math">\(D\)&lt;/span>内的&lt;strong>调和函数&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>若二阶偏导数不为0，而是&lt;span class="math">\(f(x,y)\)&lt;/span>，即 &lt;span class="math">\[ \frac{\partial^2 \varphi}{\partial x^2} + \frac{\partial^2 \varphi}{\partial y^2} = f(x,y)\tag{12} \]&lt;/span> 则被称为泊松方程。&lt;/p>
&lt;/blockquote>
&lt;p>那么解析函数和调和函数有什么关系呢？调和函数研究的二元实函数，我们可以尝试对复函数的实部、虚部求二阶偏导数。&lt;/p>
&lt;p>由C-R方程可知，其一阶偏导数有式（8）的关系，那么我们对其再求偏导有： &lt;span class="math">\[
\left .
\begin{aligned}\frac{\partial u}{\partial x}=\frac{\partial v}{\partial y}\overset{\frac{\partial}{\partial x}}{\Rightarrow}\frac{\partial^2 u}{\partial x^2} = \frac{\partial^2 v}{\partial y\partial x} \\
\frac{\partial u}{\partial y}=-\frac{\partial v}{\partial x}\overset{\frac{\partial}{\partial y}}{\Rightarrow} \frac{\partial^2 u}{\partial y^2} = -\frac{\partial^2 v}{\partial x\partial y}\end{aligned} \right\}\overset{+}{\Rightarrow} \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} = 0
\]&lt;/span> 同理，有&lt;span class="math">\(\frac{\partial^2 v}{\partial x^2} + \frac{\partial^2 v}{\partial y^2} = 0\)&lt;/span>。由上我们可以得出以下定理：&lt;/p>
&lt;blockquote>
&lt;p>若函数&lt;span class="math">\(f(z)=u(x,y)+iv(x,y)\)&lt;/span>在区域&lt;span class="math">\(D\)&lt;/span>内解析，则&lt;span class="math">\(u(x,y),v(x,y)\)&lt;/span>在区域&lt;span class="math">\(D\)&lt;/span>内都是调和函数。&lt;/p>
&lt;/blockquote>
&lt;p>对于同属于一个解析复函数的实部和虚部都是调和函数，我们将虚部的调和函数&lt;span class="math">\(v\)&lt;/span>称为实部&lt;span class="math">\(u\)&lt;/span>的&lt;strong>共轭调和函数&lt;/strong>。对应的，一对共轭调和函数可以确定一解析复函数&lt;span class="math">\(f(z)\)&lt;/span>，我们可以将其写成如下定理：&lt;/p>
&lt;blockquote>
&lt;p>复变函数&lt;span class="math">\(f(z)=u(x,y)+iv(x,y)\)&lt;/span>在区域&lt;span class="math">\(D\)&lt;/span>内解析的充要条件是：在区域&lt;span class="math">\(D\)&lt;/span>内，&lt;span class="math">\(f(z)\)&lt;/span>的虚部&lt;span class="math">\(v(x,y)\)&lt;/span>是实部&lt;span class="math">\(u(x,y)\)&lt;/span>的共轭调和函数，&lt;/p>
&lt;/blockquote>
&lt;p>需要注意的是，&lt;span class="math">\(v\)&lt;/span>是&lt;span class="math">\(u\)&lt;/span>的共轭调和函数，并不意味着&lt;span class="math">\(u\)&lt;/span>也是&lt;span class="math">\(v\)&lt;/span>的共轭调和函数！不具有对称性。&lt;/p>
&lt;p>还记得我们在&lt;a href="#柯西-黎曼方程c-r方程">柯西-黎曼方程（C-R方程）&lt;/a>那一节说过：“一旦复函数是个解析函数，其实部（虚部）一旦给定，则虚部（实部）也基本确定”。这种确定性，就是C-R方程和调和函数所共同确定的。此时，对于一个解析复函数，我们已知实部&lt;span class="math">\(u\)&lt;/span>，能求虚部&lt;span class="math">\(v\)&lt;/span>( 或者已知虚部&lt;span class="math">\(v\)&lt;/span>，求实部&lt;span class="math">\(u\)&lt;/span>)。起主要作用的是C-R方程，调和函数要求起辅助作用，具体方法主流的有两种：偏积分法和全微分法。不过本文在这里不对这些方法做具体说明了。&lt;/p>
&lt;h2 id="初等复函数">初等复函数&lt;/h2>
&lt;p>复变函数中的初等函数是实数域中初等函数的推广（复平面的解析延拓），它们的定义方式尽可能保持一致，特别是当自变量取实值时，两者是一样的。同时实函数过去一些无法进行的操作，比如对负数求对数，在复数域也是可以的。&lt;/p>
&lt;h3 id="基础指数函数">基础：指数函数&lt;/h3>
&lt;blockquote>
&lt;p>对于复数&lt;span class="math">\(z=x+iy\)&lt;/span>，其以&lt;span class="math">\(e\)&lt;/span>为底的指数函数为&lt;span class="math">\(w=e^z=\exp z = e^x(\cos y + i\sin y)\)&lt;/span>。&lt;/p>
&lt;/blockquote>
&lt;p>从现在的角度来看，将复指数函数&lt;span class="math">\(f(z)=e^z,\ z\in\mathbb{C}\)&lt;/span>是实函数&lt;span class="math">\(f(x)=e^x,\ x\in\R\)&lt;/span>的简单延拓是很正常的，不过在复数函数发展过程中并非如此，开始时，复指数函数是通过&lt;span class="math">\(w=e^x(\cos y + i\sin y)\)&lt;/span>来定义的。因为虚数诞生的时候，数学家还是倾向是将实部和虚部分开考虑，后来欧拉在棣莫佛的研究上通过对比函数的无穷级数，发现了欧拉公式&lt;span class="math">\(e^{iy}=\cos y + i\sin y\)&lt;/span>才将&lt;span class="math">\(e^x(\cos y + i\sin y)\)&lt;/span>统合成了&lt;span class="math">\(e^{x+iy}=e^z\)&lt;/span>。&lt;strong>指数函数是初等函数中最重要的函数，其余的初等函数都通过指数函数来定义&lt;/strong>。&lt;/p>
&lt;p>由定义我们可以获得以下结论（下面的结论不是平凡的，需要证明，虽然不难）：&lt;/p>
&lt;ul>
&lt;li>&lt;span class="math">\(|e^z|=e^x|e^{iy}|=e^x|\cos y + i\sin y|=e^x\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\(Arg e^z = y+2k\pi\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\(e^z\)&lt;/span>为&lt;strong>单值函数&lt;/strong>，区别于后面的复对数函数&lt;/li>
&lt;li>&lt;span class="math">\(e^z \neq 0\)&lt;/span>，因为&lt;span class="math">\(e^x&amp;gt;0,\ \cos y +i\sin y \neq 0\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\(e^z\)&lt;/span>在复平面上处处解析，且导数&lt;span class="math">\((e^z)&amp;#39;=e^z\)&lt;/span>。&lt;/li>
&lt;li>&lt;span class="math">\(e^{z_1}e^{z_2}=e^{z_1+z_2}\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\(e^z\)&lt;/span>是以&lt;span class="math">\(2k\pi i\)&lt;/span>为周期的周期函数。&lt;/li>
&lt;/ul>
&lt;h3 id="对数函数">对数函数&lt;/h3>
&lt;blockquote>
&lt;p>&lt;span class="math">\(e^w = z\)&lt;/span>则称&lt;span class="math">\(w\)&lt;/span>为&lt;span class="math">\(z\)&lt;/span>的对数函数，记为&lt;span class="math">\(w=Ln(z)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>复对数函数是用复指数函数来定义的（注意&lt;span class="math">\(Ln\)&lt;/span>首字母是大写的用来区别于实函数&lt;span class="math">\(\ln\)&lt;/span>，此外&lt;span class="math">\(Ln\)&lt;/span>并不是以&lt;span class="math">\(e\)&lt;/span>为底的意思，只是一个记号），与实函数一样，复对数函数也是复指数函数的反函数。&lt;/p>
&lt;p>那我们如何根据这个定义实际计算复对数函数呢？同样也是利用指数函数。设&lt;span class="math">\(z=re^{i\theta},\ w=u_iv\)&lt;/span>，那么根据复对数函数定义有&lt;span class="math">\(e^w=e^u e^{iv}=re^{i\theta+2k\pi}\)&lt;/span>。由此，我们可以算出： &lt;span class="math">\[
u=\ln r\\
v = \theta+2k\pi
\]&lt;/span> 因为指数函数具有周期性，导致辐角的值不止一个，所以复对数函数是一个&lt;strong>多值函数&lt;/strong>，即 &lt;span class="math">\[
w=Ln(z)=\ln r+i(\theta+2k\pi)\\
w=Ln(z)=\ln(z)+i(Arg(z)+2k\pi)\tag{13}
\]&lt;/span> 复对数函数的多值性显然是由虚部（辐角的周期性）引起的，对于每一个给定的&lt;span class="math">\(k\)&lt;/span>，&lt;span class="math">\(w_k\)&lt;/span>就成了单值函数，称为&lt;span class="math">\(Ln(z)\)&lt;/span>的一个分支，其中&lt;strong>辐角取主值(k=0)的那一支称为主枝&lt;/strong>，也记为&lt;span class="math">\(\ln z\)&lt;/span>。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;ul>
&lt;li>&lt;span class="math">\(Ln(1+i)=\ln|(1+i)|+iArg(1+i)+2k\pi i=\ln \sqrt{2}+i(\arctan 1 + 2k\pi)=\ln \sqrt{2}+i(\pi/4 + 2k\pi)\)&lt;/span>，主值为&lt;span class="math">\(\ln \sqrt{2}+i\pi/4\)&lt;/span>。&lt;/li>
&lt;li>&lt;span class="math">\(Ln(-1)=\ln |-1| +iArg(-1)+2k{\pi}i= 0 + i(\arctan -1+ 2k\pi)=i(\pi+2k\pi)\)&lt;/span>，主值为&lt;span class="math">\(i\pi\)&lt;/span>。可见，在复数域内，负实数是可以求对数的。&lt;/li>
&lt;/ul>
&lt;p>复对数函数的性质有以下几个主要点：&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>由于&lt;span class="math">\(Arg(z)\)&lt;/span>在原点无定义（且&lt;span class="math">\(e^w\neq 0\)&lt;/span>），因此&lt;span class="math">\(Ln\ z\)&lt;/span>也在原点无定义。&lt;/li>
&lt;li>由于复数定义问题，我们要求辐角&lt;span class="math">\(-\pi&amp;lt;0&amp;lt;\pi\)&lt;/span>，因此&lt;span class="math">\(Arg(z)\)&lt;/span>在负实数轴是不连续的，即从顺时针方向趋近于负实轴为&lt;span class="math">\(-\pi\)&lt;/span>，从逆时针方向趋近于负实轴为&lt;span class="math">\(+\pi\)&lt;/span>，中间有&lt;span class="math">\(2\pi\)&lt;/span>的跳跃，这导致&lt;span class="math">\(Ln\ z\)&lt;/span>的各分支在负实轴(以及原点)也是不连续的，其他位置连续。&lt;img src="../../images/The-branch-cut-for-the-determination-of-the-complex-square-root.png" alt="The-branch-cut-for-the-determination-of-the-complex-square-root.png" />&lt;/li>
&lt;li>算是性质2的推论：&lt;span class="math">\(Ln\ z\)&lt;/span>的各分支在除去原点及负实轴的复平面内解析。其导数为&lt;span class="math">\((Ln\ z)&amp;#39;=1/z\)&lt;/span>，和实函数一样。&lt;/li>
&lt;li>在集合意义上：&lt;span class="math">\(Ln(z_1z_2)=Ln(z_1)+Ln(z_2),\ Ln(z_1/z_2)=Ln(z_1)-Ln(z_2)\)&lt;/span>。但是&lt;span class="math">\(Ln(z^n)\neq nLn\ z\)&lt;/span>，&lt;span class="math">\(Ln(z^n)\)&lt;/span>的周期已经和&lt;span class="math">\(Ln(z)\)&lt;/span>不同了！&lt;/li>
&lt;/ol>
&lt;p>最后我们了解下指数函数与对数函数的关系，在实函数中，它们互为反函数，但是在； 复数域，一个是单值函数，一个是多值函数。对数函数会将自变量映射到各个分支，每个分支周期性地相等。如果我们将对数函数的值域限定在一个分支以内，二者还是反函数关系的。&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/复指数函数与复对数函数关系.png" alt="复指数函数与复对数函数关系.png" />&lt;p class="caption">复指数函数与复对数函数关系.png&lt;/p>
&lt;/div>
&lt;h3 id="幂函数">幂函数&lt;/h3>
&lt;p>幂函数可以通过指数函数与对数函数的复合来定义。&lt;/p>
&lt;blockquote>
&lt;p>函数&lt;span class="math">\(w=z^\alpha\)&lt;/span>，规定&lt;span class="math">\(z^\alpha = e^{\alpha Ln(z)},\ \alpha\in\mathbb{C},\ z\neq 0\)&lt;/span>，称为复变量&lt;span class="math">\(z\)&lt;/span>的幂函数。此外，我们规定&lt;span class="math">\(z^0=1\)&lt;/span>。&lt;/p>
&lt;/blockquote>
&lt;p>由于&lt;span class="math">\(Ln\)&lt;/span>的存在，幂函数也是多值函数。幂函数特性与&lt;span class="math">\(\alpha\)&lt;/span>的取值相关。&lt;/p>
&lt;p>当&lt;span class="math">\(\alpha\)&lt;/span>为正整数&lt;span class="math">\(n\)&lt;/span>时，&lt;span class="math">\(w= z^n = e^{n Ln z}=e^{n(\ln |z|+iArg(z)+i2k\pi)}\)&lt;/span>由于复指数函数以&lt;span class="math">\(2k\pi\)&lt;/span>为周期，当&lt;span class="math">\(n\)&lt;/span>为正整数时有&lt;span class="math">\(e^{n(\ln |z|+iArg(z)+i2k\pi)}=e^{n(\ln |z|+iArg(z))}=e^{n\ln z}\)&lt;/span>。此时多值性消除，幂函数为单值函数，且处处解析，导数为&lt;span class="math">\((z^n)&amp;#39;=nz^{n-1}\)&lt;/span>。&lt;/p>
&lt;p>当&lt;span class="math">\(\alpha\)&lt;/span>为负整数&lt;span class="math">\(-n\)&lt;/span>时，同理可得其也是单值函数，且在原点外处处解析，且导数为&lt;span class="math">\((z^-n)&amp;#39;=-nz^{-n-1}\)&lt;/span>&lt;/p>
&lt;p>当&lt;span class="math">\(\alpha\)&lt;/span>为有理数时，即&lt;span class="math">\(\alpha = p/q, \ p,q\)&lt;/span>互质。由于&lt;span class="math">\(Ln\)&lt;/span>的存在，幂函数是多值函数，有&lt;span class="math">\(q\)&lt;/span>个值（&lt;span class="math">\(q\)&lt;/span>个分支）。解析域受到&lt;span class="math">\(Ln\)&lt;/span>函数限制，在除原点和负实轴外处处解析，导数为&lt;span class="math">\((z^\alpha)&amp;#39;=\alpha z^{\alpha-1}\)&lt;/span>&lt;/p>
&lt;p>当&lt;span class="math">\(为无理数或复数时，一般为无穷多值，解析域受到\)&lt;/span>Ln$函数限制，在除原点和负实轴外处处解析。&lt;/p>
&lt;p>举几个例子：&lt;/p>
&lt;p>&lt;span class="math">\[2^i=e^{i Ln(2)}=e^{i(\ln 2 + 2k\pi i)}=e^{-2k\pi}e^{i\ln 2}\\
=e^{-2k\pi}(\cos\ln 2+i\sin\ln 2),\ k\in Z\]&lt;/span> 显然上式有无数个值。 &lt;span class="math">\[
i^i = e^{i Ln i}=e^{i\times i(\pi/2+2k\pi)}=e^{-\pi/2-2k\pi},\ k\in Z
\]&lt;/span> 可见&lt;span class="math">\(i^i\)&lt;/span>是正实数，主值为&lt;span class="math">\(e^{-\pi/2}\)&lt;/span>。 &lt;span class="math">\[
1^{\sqrt{2}}=e^{\sqrt{2}Ln(1)}=e^{\sqrt{2}\times 2k\pi i}=e^{2\sqrt{2}k\pi i}
\]&lt;/span> 可见，&lt;strong>不要想当然地认为1的任意次幂都是1&lt;/strong>，仅限于有理数次幂才成立。&lt;/p>
&lt;h3 id="三角函数">三角函数&lt;/h3>
&lt;p>三角函数和欧拉公式密不可分，我们可以通过欧拉公式使用指数函数的形式来定义三角函数。&lt;/p>
&lt;blockquote>
&lt;p>根据欧拉公式有&lt;span class="math">\(e^{i\theta}=\cos\theta+i\sin\theta,\ e^{-i\theta}=\cos\theta-i\sin\theta\)&lt;/span>可推得： &lt;span class="math">\[ \cos z = \frac{e^{iz}+e^{-iz}}{2}\\ \sin z = \frac{e^{iz}-e^{-iz}}{2i}\]&lt;/span> 由此&lt;span class="math">\(\cos z\)&lt;/span>和&lt;span class="math">\(\sin z\)&lt;/span>我们可以定义出其他三角函数 &lt;span class="math">\[ \tan z =\frac{\sin z}{\cos z},\ \cot z = \frac{\cos z}{\sin z} \\ \sec z = {1\over\cos z},\ \csc z={1\over \sin z}\]&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>三角函数的性质和实函数许多是一样的，但是有一点区别很大。&lt;/p>
&lt;ul>
&lt;li>根据欧拉公式中的指数函数可知，复三角函数不再是有界函数，即&lt;span class="math">\(|\sin x|≤1,\ |\cos x|≤1,x\in\R\)&lt;/span>，三角函数值可以随之实部变得无穷大。&lt;/li>
&lt;li>&lt;span class="math">\(\sin z,\ \cos z\)&lt;/span>在复平面处处解析。&lt;span class="math">\((\sin z)&amp;#39;=\cos z;\ (\cos z)&amp;#39;=-\sin z\)&lt;/span>。&lt;/li>
&lt;li>三角函数周期性、可导性、奇偶性、零点与实函数一样。&lt;/li>
&lt;li>各种三角公式可以照搬。&lt;/li>
&lt;li>反三角函数可以通过欧拉公式推导出，也是多值函数。&lt;/li>
&lt;/ul>
&lt;h3 id="双曲函数">双曲函数&lt;/h3>
&lt;p>和三角函数一样，也可通过欧拉公式推的。&lt;/p>
&lt;blockquote>
&lt;p>双曲正弦函数&lt;span class="math">\(\sh z =\frac{1}{2}(e^z-e^{-z})\)&lt;/span>；反双曲正弦函数&lt;span class="math">\(\mathrm{Arsh} z=\mathrm{Ln}(z+\sqrt{z^2+1})\)&lt;/span>&lt;/p>
&lt;p>双曲余弦函数&lt;span class="math">\(\ch z =\frac{1}{2}(e^z+e^{-z})\)&lt;/span>；反双曲余弦函数&lt;span class="math">\(\mathrm{Arch} z=\mathrm{Ln}(z+\sqrt{z^2-1})\)&lt;/span>&lt;/p>
&lt;p>双曲正切函数&lt;span class="math">\(\th z = \frac{\sh z}{\ch z}\)&lt;/span>；反双曲正切函数&lt;span class="math">\(\mathrm{Arth} z=\frac{1}{2}\mathrm{Ln}\frac{1+z}{1-z}\)&lt;/span>&lt;/p>
&lt;p>双曲余切函数&lt;span class="math">\(\coth z = \frac{\ch z}{\sh z}\)&lt;/span>。&lt;/p>
&lt;/blockquote>
&lt;p>双曲正弦、双曲余弦在复平面显然处处解析，曲正切函数在除去&lt;span class="math">\(z=i(k\pi+\frac{\pi}{2})\)&lt;/span>外处处解析。&lt;/p>
&lt;p>在复分析中，双曲函数对复数映射是非常常用的，需要的时候可以在查询。&lt;/p></description></item><item><title>数学分析-导数、偏导与微分</title><link>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E5%AF%BC%E6%95%B0%E5%81%8F%E5%AF%BC%E4%B8%8E%E5%BE%AE%E5%88%86/</link><pubDate>Sat, 25 Feb 2023 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E5%AF%BC%E6%95%B0%E5%81%8F%E5%AF%BC%E4%B8%8E%E5%BE%AE%E5%88%86/</guid><description>
&lt;h2 id="导数偏导与微分">导数、偏导与微分&lt;!-- omit in toc -->&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="#多元函数与一元函数差别的根源">多元函数与一元函数差别的根源&lt;/a>&lt;/li>
&lt;li>&lt;a href="#导数的延拓">导数的延拓&lt;/a>&lt;/li>
&lt;li>&lt;a href="#从增量到微分">从增量到微分&lt;/a>&lt;/li>
&lt;li>&lt;a href="#从多元函数导数到微分">从多元函数导数到微分&lt;/a>&lt;/li>
&lt;li>&lt;a href="#偏导与可微">偏导与可微&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>一元函数与多元函数的导数（偏导数）、微分以及函数的连续性之间关系密切，总体而言它们的关系如下图：&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/极限连续可导可微关系.png" alt="极限连续可导可微关系.png" />&lt;p class="caption">极限连续可导可微关系.png&lt;/p>
&lt;/div>
&lt;p>一元函数的内容在数学分析中较为容易理解，本文将着重介绍多元函数的偏导数、微分以及其他衍生概念和它们之间的关系。&lt;/p>
&lt;h2 id="多元函数与一元函数差别的根源">多元函数与一元函数差别的根源&lt;/h2>
&lt;p>在一元函数中，可微和可导是等价的，但是在多元函数中并不如此，并且导数在多元函数中推广并不是自然的拓展，而是衍生出偏导数、方向导数、全导数等额外概念。此外，多元函数连续性的概念也不仅仅是从负方向和正方向两边连续这么简单了。造成这一切的根源是&lt;strong>自变量维度的变化&lt;/strong>。&lt;/p>
&lt;p>我们先看一元函数场景下：&lt;/p>
&lt;ul>
&lt;li>函数&lt;span class="math">\(f(x)\)&lt;/span>在&lt;span class="math">\(x_0\)&lt;/span>处极限：&lt;span class="math">\(\lim\limits_{x\rightarrow x_0} f(x) =A\)&lt;/span>；&lt;/li>
&lt;li>函数&lt;span class="math">\(f(x)\)&lt;/span>在&lt;span class="math">\(x_0\)&lt;/span>处连续：&lt;span class="math">\(\lim\limits_{x\rightarrow x_0}f(x) = f(x_0)\)&lt;/span>(函数在&lt;span class="math">\(x_0\)&lt;/span>出有定义);&lt;/li>
&lt;li>函数&lt;span class="math">\(f(x)\)&lt;/span>在&lt;span class="math">\(x_0\)&lt;/span>处导数：&lt;span class="math">\(\lim\limits_{x\rightarrow x_0} \frac{f(x)-f(x_0)}{x-x_0}=f&amp;#39;(x_0)\)&lt;/span>(函数在&lt;span class="math">\(x_0\)&lt;/span>&lt;strong>邻域&lt;/strong>有定义);&lt;/li>
&lt;/ul>
&lt;p>以上三者都谈到了&lt;span class="math">\(x\rightarrow x_0\)&lt;/span>的极限场景，而这三类极限存在的&lt;strong>充要&lt;/strong>条件都是存在左极限&lt;span class="math">\(x\rightarrow x_0^-\)&lt;/span>和右极限&lt;span class="math">\(x\rightarrow x_0^+\)&lt;/span>且相等。也就是说，&lt;strong>一元函数这些定义中，自变量是一维的，只要研究极限从点&lt;span class="math">\(x_0\)&lt;/span>正负两个方向趋近即可&lt;/strong>。如下图：&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/左右极限.png" alt="左右极限.png" />&lt;p class="caption">左右极限.png&lt;/p>
&lt;/div>
&lt;p>从上图中可知，在以为场景下，趋近于某一点只需要从两个方向分别趋近即可，但是当维度大于一维时，“趋近”的概念有了本质的变化。以二元空间的自变量&lt;span class="math">\((x,y)\)&lt;/span>组成的二维空间为例。如果我们按照惯有思路推导，会认为二维空间的极限是需要从四个方向趋近点&lt;span class="math">\((x_0^-,0),(x_0^+,0),(0,y_0^-),(0,y_0^+)\)&lt;/span>，如下图：&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/二维空间极限轴方向.png" alt="二维空间极限轴方向" />&lt;p class="caption">二维空间极限轴方向&lt;/p>
&lt;/div>
&lt;p>这显然考虑的不够周全，比如考虑二维连续函数，在&lt;span class="math">\(x，y\)&lt;/span>两个轴是1，其他位置都是0，它在原点&lt;span class="math">\((0,0)\)&lt;/span>处，&lt;span class="math">\((x_0^-,0),(x_0^+,0),(0,y_0^-),(0,y_0^+)\)&lt;/span>四个方向都是连续的，但是从沿着向量&lt;span class="math">\((1,1)\)&lt;/span>的方向就不连续了，函数值从0跳跃到了1。所以，当自变量大于一维时，我们考虑&lt;strong>点所在空间的所有方向&lt;/strong>，而不限于几个分量的方向：&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/二维空间极限全方向.png" alt="二维空间极限全方向.png" />&lt;p class="caption">二维空间极限全方向.png&lt;/p>
&lt;/div>
&lt;p>当我们研究的问题从两个方向一下子扩展到无穷个方向后，传统的一些做法和结论就不适用了。&lt;/p>
&lt;p>换个严谨点的说法：多维极限的存在，是指点&lt;span class="math">\(\vec{p}\)&lt;/span>以任何方式趋于点&lt;span class="math">\(\vec{p}_0\)&lt;/span>时，函数值&lt;span class="math">\(f(\vec{p})\)&lt;/span>都无限接近于&lt;span class="math">\(f(\vec{p}_0)\)&lt;/span>。因此，如果点&lt;span class="math">\(\vec{p}\)&lt;/span>只是以特殊方式，例如沿着一条定直线或定曲线趋于$ &lt;em>0&lt;span class="math">\(，即使函数值同样趋近于\)&lt;/span>f(&lt;/em>0)&lt;span class="math">\(，我们还不能由此断定函数的极限存在。但是反过来，如果当\)&lt;/span>&lt;span class="math">\(以不同方式趋近于\)&lt;/span>_0&lt;span class="math">\(时，函数\)&lt;/span>f()$趋于不同的值，那么就可以断定这函数的极限不存在。&lt;/p>
&lt;p>一句话总结：极限趋近方向从两个变成了无穷个。&lt;/p>
&lt;h2 id="导数的延拓">导数的延拓&lt;/h2>
&lt;p>一元函数的导数是直观的，因为自变量只有一个，导数的定义就是函数值（因变量）随着自变量变化的变化率。但是在多元函数中，自变量不止一个，如何定义导数就出现了不同方式。&lt;/p>
&lt;p>首先，如果只考虑其中一个自变量的变化，比如&lt;span class="math">\(x\)&lt;/span>，而其他自变量（&lt;span class="math">\(y, z, \dotsb\)&lt;/span>）不变，那么此时多元函数就可以当成&lt;span class="math">\(x\)&lt;/span>的一元函数。这时仅对&lt;span class="math">\(x\)&lt;/span>求的导数就成为多元函数&lt;span class="math">\(f\)&lt;/span>对于&lt;span class="math">\(x\)&lt;/span>的偏导数，记为：&lt;span class="math">\(\frac{\partial f}{\partial x}\)&lt;/span>。同理，我们可以求出关于其他变量的偏导数&lt;span class="math">\(\frac{\partial f}{\partial y}, \frac{\partial f}{\partial z}, \dotsb\)&lt;/span>&lt;/p>
&lt;p>偏导数只能反映出轴方向的变化性，因此偏导数存在可能说明函数延轴方向是连续的，对于其他方向爱莫能助，因此偏导数存在不能说明函数整体的连续性。&lt;/p>
&lt;p>下图展示了二元函数的偏导数。固定&lt;span class="math">\(y=y_0, x\)&lt;/span>方向的偏导数（红色为x轴）；固定&lt;span class="math">\(x=x_0, y\)&lt;/span>方向的偏导数（绿色为y轴）&lt;/p>
&lt;div class="figure">
&lt;embed src="../../images/x轴偏导数.jfif" />&lt;p class="caption">x轴偏导数.jfif&lt;/p>
&lt;/div>
&lt;div class="figure">
&lt;embed src="../../images/y轴偏导数.jfif" />&lt;p class="caption">y轴偏导数.jfif&lt;/p>
&lt;/div>
&lt;p>其次，偏导数只反应了函数沿各平行于坐标轴的方向的变化率，对于其他的方向还需要定义新的导数。设函数&lt;span class="math">\(f(\vec{x})\)&lt;/span>是一个&lt;span class="math">\(n\)&lt;/span>维自变量的函数，&lt;span class="math">\(\vec{x}=\{x_1,x_2,\dotsb,x_n\}\)&lt;/span>，若函数&lt;span class="math">\(f\)&lt;/span>在某点&lt;span class="math">\(\vec{x}\)&lt;/span>邻域内有定义，那么给定一个非零向量&lt;span class="math">\(\vec{v}\)&lt;/span>，函数沿向量&lt;span class="math">\(\vec{v}\)&lt;/span>的方向导数为： &lt;span class="math">\[
\nabla_{\vec{v}} f(\vec{x}) = \lim_{t\rightarrow 0}\frac{f(\vec{x}+t\vec
{v})-f(\vec{x})}{t}
\]&lt;/span> 也可记为&lt;span class="math">\(\frac{\mathrm{d}f_{\vec{v}}}{\mathrm{d}t}|_{t\rightarrow 0}\)&lt;/span>。有些书籍中会较为严格地定义方向导数为函数在某一点沿&lt;strong>单位长度向量&lt;/strong>的方向导数，在这样的上下文中，“函数在某点沿向量&lt;span class="math">\(\vec{v}\)&lt;/span>方向上的导数”指的是函数在这一点沿着&lt;span class="math">\(\vec{v}\)&lt;/span>对应的单位向量&lt;span class="math">\(\vec{v_{unit}}=\frac{\vec{v}}{||\vec{v}||}\)&lt;/span>的方向导数。不过，只要&lt;span class="math">\(t\rightarrow 0\)&lt;/span>，是否指定向量&lt;span class="math">\(\vec{v}\)&lt;/span>为单位向量并不重要。下图展示了一个二维的方向导数。&lt;/p>
&lt;div class="figure">
&lt;embed src="../../images/方向导数.jfif" />&lt;p class="caption">方向导数.jfif&lt;/p>
&lt;/div>
&lt;p>方向导数可以看成是偏导数的推广，当方向导数的方向正好沿着坐标轴时，方向导数就退化成了偏导数。例如，方向导数为&lt;span class="math">\(\vec{v}=\{1,0,0,\dotsb\}\)&lt;/span>平行于&lt;span class="math">\(x_1\)&lt;/span>轴，那么 &lt;span class="math">\[
\begin{aligned}
\nabla_{\vec{v}} f(\vec{x}) &amp;amp;= \lim_{t\rightarrow 0}\frac{f(\vec{x}+t\vec
{v})-f(\vec{x})}{t}\\
&amp;amp;=\lim_{t\rightarrow 0}\frac{f(x_1+t,x_2,\dotsb,x_n)-f(x_1,x_2,\dotsb,x_n)}{t}
\end{aligned}
\]&lt;/span> 我们将&lt;span class="math">\(t\)&lt;/span>改写成&lt;span class="math">\(\Delta x_1\)&lt;/span>，则上式为： &lt;span class="math">\[
\lim_{\Delta x_1\rightarrow 0}\frac{f(x_1+\Delta x_1,x_2,\dotsb,x_n)-f(x_1,x_2,\dotsb,x_n)}{\Delta x_1}=\frac{\partial f(\vec
{x})}{\partial x_1}
\]&lt;/span> 此时，方向导数就是&lt;span class="math">\(x_1\)&lt;/span>分量的偏导数。&lt;/p>
&lt;p>我们假设点&lt;span class="math">\(\vec{x}\)&lt;/span>邻域内各方向的方向导数都存在，那么是否有一个方向导数的最大值呢？该最大值又是什么方向呢？这就引出了梯度的概念。&lt;strong>即梯度是多元函数在点&lt;span class="math">\(\vec{x}\)&lt;/span>处上升最快的方向&lt;/strong>。&lt;/p>
&lt;p>我们在这里直接给出梯度的表达式为： &lt;span class="math">\[
\nabla f = \frac{\partial f}{\partial x_1}\vec{a}_1+\frac{\partial f}{\partial x_2}\vec{a}_2+\dotsb+\frac{\partial f}{\partial x_n}\vec{a}_n
\]&lt;/span> 其中，&lt;span class="math">\(\frac{\partial f}{\partial x_i}\)&lt;/span>是&lt;span class="math">\(\vec{x}_i\)&lt;/span>分量的偏导数，&lt;span class="math">\(\vec{a}_i\)&lt;/span>是&lt;span class="math">\(\vec{x}_i\)&lt;/span>方向的单位向量。 至于证明读者可以从各种教材上寻找到。&lt;/p>
&lt;p>另外，还有一个叫做全导数的概念，不过它和偏导数、方向导数、梯度讨论的场景并不一样。全导数是在&lt;strong>多元复合函数&lt;/strong>场景下，所有自变量都受到&lt;strong>唯一&lt;/strong>参数&lt;span class="math">\(t\)&lt;/span>控制的，关于&lt;span class="math">\(t\)&lt;/span>的导数。即对于多元函数&lt;span class="math">\(f(\vec{x})\)&lt;/span>，向量&lt;span class="math">\(\vec{x}\)&lt;/span>的每一个分量&lt;span class="math">\(x_i\)&lt;/span>都是&lt;span class="math">\(t\)&lt;/span>的函数&lt;span class="math">\(x_i(t)\)&lt;/span>，那么全导数&lt;span class="math">\(\frac{\mathrm{d}f}{\mathrm{d}t}\)&lt;/span>为： &lt;span class="math">\[
\frac{\mathrm{d}f}{\mathrm{d}t}=\frac{\partial f}{\partial x_1}\frac{\partial x_1}{\partial t}+\frac{\partial f}{\partial x_2}\frac{\partial x_2}{\partial t}+\dotsb+\frac{\partial f}{\partial x_n}\frac{\partial x_n}{\partial t}
\]&lt;/span> 全导数&lt;strong>本质上是一个一元函数导数&lt;/strong>，只不过这个自变量&lt;span class="math">\(t\)&lt;/span>隐含在相关变量&lt;span class="math">\(x_i(t)\)&lt;/span>中，实际上等同于&lt;span class="math">\(f(t)\)&lt;/span>对于变量&lt;span class="math">\(t\)&lt;/span>的导数，反映了整体函数值关于&lt;span class="math">\(t\)&lt;/span>的变化率。&lt;/p>
&lt;h2 id="从增量到微分">从增量到微分&lt;/h2>
&lt;p>在说明微分之前，我们需要介绍一个更直观的概念：增量&lt;span class="math">\(\Delta\)&lt;/span>。我们在上文中已经使用过这个概念了，例如&lt;span class="math">\(\Delta x\)&lt;/span>，不过我们都只是在多元函数自变量的某个分量中使用增量，表示某一分量的变化值。&lt;/p>
&lt;p>增量即自变量或因变量的变化值（不一定非要是正值），在一元函数中，自变量&lt;span class="math">\(x\)&lt;/span>的增量就是沿着&lt;span class="math">\(x\)&lt;/span>轴左右增减的量，因此，&lt;span class="math">\(\Delta x\)&lt;/span>是线性变化的量。因变量&lt;span class="math">\(\Delta y\)&lt;/span>是两个函数值的差&lt;span class="math">\(\Delta y = f(x+\Delta x)-f(x)\)&lt;/span>，若函数&lt;span class="math">\(f\)&lt;/span>不是线性函数，增量通常也不是线性的。&lt;/p>
&lt;p>在实际使用中，&lt;span class="math">\(\Delta y\)&lt;/span>计算会涉及函数&lt;span class="math">\(f\)&lt;/span>，因此十分不可控，比如当&lt;span class="math">\(f\)&lt;/span>非常复杂时，&lt;span class="math">\(\Delta y\)&lt;/span>将难以计算，同时&lt;span class="math">\(\Delta y\)&lt;/span>没有特定的数学性质，会随着映射&lt;span class="math">\(f\)&lt;/span>的改变而改变。因此，在微积分中，借助其核心思想之一：“&lt;strong>以直代曲&lt;/strong>”，对增量&lt;span class="math">\(\Delta y\)&lt;/span>进行简化，诞生了微分&lt;span class="math">\(\mathrm{d}y\)&lt;/span>。&lt;/p>
&lt;p>对于曲线&lt;span class="math">\(y\)&lt;/span>的研究通常不是平凡的，微积分的一大创举就是证明了以直代曲的广泛可行性。如果一条曲线不好研究，那么我们就将其分割成一个个小段，每一小段上用一条直线段取代，当分割的间隔非常非常小时，就可以用这一系列小折线段组取代原来的曲线。如下图所示：&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/以直代曲.png" alt="以直代曲.png" />&lt;p class="caption">以直代曲.png&lt;/p>
&lt;/div>
&lt;p>那么如果确定每个小区间里的直线方程呢？一个广泛的做法是统一小区间内某一点，然后做过该点的切线作为代替曲线的直线，比如统一取区间左端点做切线（或中点、右端点都行，当区间足够小时，别没有差别。如果严格地来说，采用闭区间套定理不断缩小区间，最终每个区间只会剩下一个点^_^，所以在无穷小的情况下也不会考虑用割线，只有切线。）而选中点的切线的斜率就是我们之前所说的该点的导数，因此，已知直线斜率和过直线一点&lt;span class="math">\((x_0,f(x_0))\)&lt;/span>，可以写出直线的方程&lt;span class="math">\(g(x)\)&lt;/span>： &lt;span class="math">\[
g(x)=f&amp;#39;(x_0)(x-x_0)+f(x_0)
\]&lt;/span> 我们令&lt;span class="math">\(\mathrm{d}y = g(x)-f(x_0)\)&lt;/span>，由于函数&lt;span class="math">\(g(x)\)&lt;/span>是一个线性函数，因此&lt;span class="math">\(\mathrm{d}y\)&lt;/span>随着变化量&lt;span class="math">\(\Delta x\)&lt;/span>线性变化，至于&lt;span class="math">\(\Delta x = x-x_0\)&lt;/span>，前面已经说过本来就是沿着&lt;span class="math">\(x\)&lt;/span>轴的线性变化，所以有&lt;span class="math">\(\Delta x =\mathrm{d}x\)&lt;/span>。因此，上式关系可改写为： &lt;span class="math">\[
\mathrm{d}y = f&amp;#39;(x_0)\mathrm{d}x
\]&lt;/span> 即为函数&lt;span class="math">\(f\)&lt;/span>在&lt;span class="math">\(x_0\)&lt;/span>处相应于自变量&lt;span class="math">\(\Delta x\)&lt;/span>的微分。注意，&lt;span class="math">\(\mathrm{d}x=\Delta x\)&lt;/span>。显然，&lt;span class="math">\(\mathrm{d}y\)&lt;/span>是在&lt;span class="math">\(x_0\)&lt;/span>邻域内，随自变量&lt;span class="math">\(\mathrm{d}x\)&lt;/span>，以&lt;span class="math">\(f&amp;#39;(x_0)\)&lt;/span>为斜率的线性变化量。&lt;/p>
&lt;p>那么，&lt;span class="math">\(\mathrm{d}y\)&lt;/span>和&lt;span class="math">\(\Delta y\)&lt;/span>有什么关系呢？我们还是需要导数这个中间桥梁。&lt;/p>
&lt;ul>
&lt;li>导数：&lt;span class="math">\(f&amp;#39;(x_0)=\lim\limits_{x\rightarrow x_0} \frac{f(x)-f(x_0)}{x-x_0}= \lim\limits_{\Delta x\rightarrow 0}\frac{\Delta y}{\Delta x}\)&lt;/span>&lt;/li>
&lt;li>微分：&lt;span class="math">\(f&amp;#39;(x_0)=\frac{\mathrm{d}y}{\mathrm{d}x}\)&lt;/span>&lt;/li>
&lt;/ul>
&lt;p>上面二者结果都是&lt;span class="math">\(x_0\)&lt;/span>处的导数值！即&lt;span class="math">\(\frac{\mathrm{d}y}{\mathrm{d}x}=\lim\limits_{\Delta x\rightarrow 0}\frac{\Delta y}{\Delta x}\)&lt;/span>。后面的极限在&lt;span class="math">\(\Delta x\rightarrow 0\)&lt;/span>时只剩下了一项，说明&lt;span class="math">\(\Delta y\)&lt;/span>包含的其他项至少是&lt;span class="math">\(\Delta x\)&lt;/span>的高阶无穷小（如果&lt;span class="math">\(f(x)\)&lt;/span>是线性函数，剩余项就是0），所在才会在&lt;span class="math">\(\Delta x\)&lt;/span>趋于0的过程中消去，即&lt;span class="math">\(\Delta y =f&amp;#39;(x_0)\Delta x+o(\Delta x), o(\Delta x)\)&lt;/span>表示&lt;span class="math">\(\Delta x\)&lt;/span>的高阶无穷小。我们已知&lt;span class="math">\(\Delta x=\mathrm{d}x\)&lt;/span>，那么&lt;span class="math">\(\Delta y =f&amp;#39;(x_0)\mathrm{d}x+o(\Delta x)\Rightarrow \Delta y = \mathrm{d}y + o(\Delta x)\)&lt;/span>。其含义是&lt;span class="math">\(\Delta y\)&lt;/span>增量是由线性增长部分&lt;span class="math">\(\mathrm{d}y\)&lt;/span>和高阶增长量&lt;span class="math">\(o(\Delta x)\)&lt;/span>组成，当&lt;span class="math">\(\Delta x\)&lt;/span>很小很小，以0为极限时有：&lt;span class="math">\(\lim\limits_{\Delta x\rightarrow 0} \Delta y/\Delta x = \mathrm{d}y/\mathrm{d}x\)&lt;/span>。（上面的过程也暗含了一元函数可微与可导的等价性）&lt;/p>
&lt;p>他们之间的关系如下图所示：&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/增量与微分.png" alt="增量与微分.png" />&lt;p class="caption">增量与微分.png&lt;/p>
&lt;/div>
&lt;h2 id="从多元函数导数到微分">从多元函数导数到微分&lt;/h2>
&lt;p>在一元函数中，可导和可微是互为充要条件。但是由于在多元函数中自变量维度的提升，可导变成了偏导，被限定了方向，甚至连多元函数的连续性都无法确定，而&lt;strong>微分在向多元函数延时拓没有受到方向限制&lt;/strong>，这种充要关系也被破坏了。&lt;/p>
&lt;p>&lt;strong>具体谈到多元函数微分的话，通常指的是全微分&lt;/strong>。不过微分中是存在偏微分的，而偏微分确实也和偏导数是充要关系。例如： &lt;span class="math">\[
f(x+\Delta x, y)-f(x,y)\approx \frac{\partial f}{\partial x}\Delta x\\
f(x, y+\Delta y)-f(x,y)\approx \frac{\partial f}{\partial y}\Delta y
\]&lt;/span> 当我们只考虑偏微分时，和一元函数是类似的，然而偏微分单独使用场景较少，因此谈到微分大家&lt;strong>默认都是说全微分&lt;/strong>。&lt;/p>
&lt;p>多元函数全微分的引入和一元函数类似相同，都是通过增量概念，多元函数的总体增量称为&lt;strong>全增量&lt;/strong>，记作&lt;span class="math">\(\Delta f\)&lt;/span>: &lt;span class="math">\[
\Delta f(\vec{x})=f(\vec{x}+\Delta \vec{x})-f(\vec{x})
\]&lt;/span> 如果增量&lt;span class="math">\(\Delta f\)&lt;/span>可以表示成&lt;strong>每个分量的增量的线性组合&lt;/strong>加上一个增量距离的高阶无穷小，那么则称函数&lt;span class="math">\(f\)&lt;/span>在点&lt;span class="math">\(\vec{x}\)&lt;/span>处可微： &lt;span class="math">\[
\Delta f(\vec{x}) = \vec{A}^T\Delta\vec{x}+o(\rho)
\]&lt;/span> 其中，&lt;span class="math">\(\vec{A}, \Delta\vec{x}\)&lt;/span>是n维列向量，&lt;span class="math">\(\rho=||\Delta\vec{x}||_2\)&lt;/span>。同样的，在每个分量的增量都是沿坐标轴线性增长的，所以&lt;span class="math">\(\Delta\vec{x}=\mathrm{d}\vec{x}\)&lt;/span>。当&lt;span class="math">\(\Delta\vec{x}\)&lt;/span>很小很小时，&lt;span class="math">\(o(\rho)\)&lt;/span>忽略，剩余增量&lt;span class="math">\(\Delta f\)&lt;/span>记为&lt;span class="math">\(\mathrm{d}f\)&lt;/span>，称为&lt;span class="math">\(f\)&lt;/span>在点&lt;span class="math">\(\vec{x}\)&lt;/span>处的全微分： &lt;span class="math">\[
\mathrm{d}f=\vec{A}^T\mathrm{d}\vec{x}=a_1x_1+\dotsb+a_nx_n
\]&lt;/span> 由上可知，多元函数微分也是“以直代曲”思想的实践，只不过从用直线代替曲线变成了（高维）平面代替（高维）曲面。那每一个系数&lt;span class="math">\(a_i\)&lt;/span>到底等于多少呢？这就是从一般到特殊。&lt;/p>
&lt;p>我们知道全微分是对点邻域任意方向都成立的，因此我们取平行于&lt;span class="math">\(x_i\)&lt;/span>的方向趋近，此时&lt;span class="math">\(\Delta\vec{x}=\{0,\dotsb,\Delta x_i,\dotsb,0\}\)&lt;/span>，全增量在该方向的表达式为： &lt;span class="math">\[
f(\vec{x}+\Delta \vec{x})-f(\vec{x})=a_i\Delta x_i\\
\Rightarrow \lim_{\Delta x_i\rightarrow 0} a_i=\frac{f(\vec{x}+\Delta \vec{x})-f(\vec{x})}{\Delta x_i}
\]&lt;/span> 熟悉的读者立刻就能发现，上式正式多元函数在&lt;span class="math">\(x_i\)&lt;/span>分量上的偏导数！即&lt;span class="math">\(a_i=\frac{\partial f}{\partial x_i}\)&lt;/span>。因此，全微分&lt;span class="math">\(\mathrm{d}f\)&lt;/span>等于： &lt;span class="math">\[
\mathrm{d}f=\sum_{i=1}^n\frac{\partial f}{\partial x_i}\mathrm{d}x_i
\]&lt;/span> 从上面的过程我们也可以得出：&lt;strong>当全微分存在时，其平行于各分量的偏导数也存在&lt;/strong>（可微&lt;span class="math">\(\Rightarrow\)&lt;/span>有偏导）。&lt;/p>
&lt;p>反过来，如果有偏导，那么只能保证在轴方向的偏微分存在，全微分不一定存在。典型例子如下： &lt;span class="math">\[
f(x,y)=\begin{cases}
\frac{xy}{\sqrt{x^2+y^2}},(x,y)\neq (0,0)\\
0,(x,y)=(0,0).
\end{cases}
\]&lt;/span> 这个函数在&lt;span class="math">\((0,0)\)&lt;/span>处连续且偏导存在，但是不可微。 其在点&lt;span class="math">\((0,0)\)&lt;/span>全增量为: &lt;span class="math">\[
\Delta f=f(0+\Delta x,0+\Delta y)-f(0,0)=\frac{\Delta x\Delta y}{\sqrt{\Delta x^2+\Delta y^2}}
\]&lt;/span> 当我们选用从x轴或y轴方向趋近于&lt;span class="math">\((0,0)\)&lt;/span>，显然有： &lt;span class="math">\[
\text{方向}_{\Delta x\rightarrow 0,\Delta y=0}: \Delta f = \mathrm{d}f = 0 \mathrm{d}x+0 \mathrm{d}y + 0= 0\\
\text{方向}_{\Delta y\rightarrow 0,\Delta x=0}: \Delta f = \mathrm{d}f = 0 \mathrm{d}x+0 \mathrm{d}y +0 = 0
\]&lt;/span> 注意，上式表示时我们只谈从&lt;span class="math">\({\Delta x\rightarrow 0,\Delta y=0}\)&lt;/span>或&lt;span class="math">\({\Delta y\rightarrow 0,\Delta x=0}\)&lt;/span>的方向，而非取极限&lt;/p>
&lt;p>但是我们选用从方向&lt;span class="math">\((1,1)\)&lt;/span>，即&lt;span class="math">\(\Delta x = \Delta y\)&lt;/span>趋近于&lt;span class="math">\((0,0)\)&lt;/span>时： &lt;span class="math">\[
\text{方向}_{\Delta x\rightarrow 0,\Delta y=\Delta x}: \Delta f = \mathrm{d}f = \frac{\Delta x^2}{\sqrt{\Delta x^2+\Delta x^2}}=\frac{\sqrt{2}}{2}\mathrm{d} x+ 0\mathrm{d} y + 0
\]&lt;/span> 显然点&lt;span class="math">\((0,0)\)&lt;/span>处从&lt;span class="math">\((1,1)\)&lt;/span>方向的微分和&lt;span class="math">\(x,y\)&lt;/span>轴方向的微分不相等，因此全微分并不存在。需要指出的是上面三个式子中&lt;span class="math">\(o(\rho)=0\)&lt;/span>，因此我们可以直接写&lt;span class="math">\(\Delta f = \mathrm{d}f\)&lt;/span>。&lt;/p>
&lt;p>从上面可以看出可微的要求还是挺高的，需要从各个方向考虑。那么有没有一个简单的方法判断可微呢？有的，那就是一阶偏导数连续。&lt;/p>
&lt;h3 id="偏导与可微">偏导与可微&lt;/h3>
&lt;p>其实偏导数连续是一个非常强的条件，一般函数都不会有这么好的性质。甚至偏导数连续是可微的充分条件，而非充要条件。可微并不能推导出偏导数连续！&lt;/p></description></item><item><title>数学分析之无穷级数</title><link>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/</link><pubDate>Fri, 06 Jan 2023 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/</guid><description>
&lt;h2 id="无穷级数">无穷级数&lt;!-- omit in toc -->&lt;/h2>
&lt;p>级数理论是数学分析的一个分支，它与另一个分支微积分学一起作为基础知识和工具出现在其余数学分支中。实际上，不同于现在数学学习中对微积分的过度侧重，级数的地位和微积分相当，二者共同以极限为基本工具，分别从离散与连续两个方面，结合起来研究分析学的对象，即变量之间的依赖关系──函数。&lt;/p>
&lt;p>无穷级数思想——逼近——微积分 数学分析词源 分析学&lt;/p>
&lt;p>欧拉、高斯都是使用级数的高手 计算使用级数&lt;/p>
&lt;p>无穷级数与差分&lt;/p>
&lt;p>&lt;span class="math">\[
\bvec
\]&lt;/span>&lt;/p></description></item><item><title>数学分析之两类欧拉积分(Gamma、Beta函数与积分)</title><link>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%A4%E7%B1%BB%E6%AC%A7%E6%8B%89%E7%A7%AF%E5%88%86gammabeta%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86/</link><pubDate>Tue, 01 Nov 2022 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%A4%E7%B1%BB%E6%AC%A7%E6%8B%89%E7%A7%AF%E5%88%86gammabeta%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86/</guid><description>
&lt;ul>
&lt;li>&lt;a href="#哥德巴赫的疑问插值与阶乘研究">哥德巴赫的疑问——插值与阶乘研究&lt;/a>&lt;/li>
&lt;li>&lt;a href="#三封信中诞生的gamma函数">三封信中诞生的Gamma函数&lt;/a>&lt;/li>
&lt;li>&lt;a href="#第一封丹尼尔-伯努利的解答">第一封：丹尼尔-伯努利的解答&lt;/a>&lt;/li>
&lt;li>&lt;a href="#第二封欧拉的无穷级数型解答">第二封：欧拉的无穷级数型解答&lt;/a>&lt;/li>
&lt;li>&lt;a href="#无穷乘积中欧拉的发现">无穷乘积中欧拉的发现&lt;/a>&lt;/li>
&lt;li>&lt;a href="#第三封欧拉的积分函数型解答">第三封：欧拉的积分函数型解答&lt;/a>&lt;/li>
&lt;li>&lt;a href="#欧拉积分的进一步探究">欧拉积分的进一步探究&lt;/a>&lt;/li>
&lt;li>&lt;a href="#beta和gamma函数的命名">Beta和Gamma函数的命名&lt;/a>&lt;/li>
&lt;li>&lt;a href="#积分函数的偏移">积分函数的偏移&lt;/a>&lt;/li>
&lt;li>&lt;a href="#第二类欧拉积分的负数复数延拓以及统一表达式">第二类欧拉积分的负数、复数延拓以及统一表达式&lt;/a>&lt;/li>
&lt;li>&lt;a href="#第二类欧拉积分与阶乘延拓的唯一性">第二类欧拉积分与阶乘延拓的唯一性&lt;/a>&lt;/li>
&lt;li>&lt;a href="#不完全gamma函数与不完全beta函数">不完全Gamma函数与不完全Beta函数&lt;/a>&lt;/li>
&lt;li>&lt;a href="#两类欧拉积分在概率论中的应用">两类欧拉积分在概率论中的应用&lt;/a>&lt;/li>
&lt;li>&lt;a href="#gamma分布">Gamma分布&lt;/a>&lt;/li>
&lt;li>&lt;a href="#beta分布">Beta分布&lt;/a>&lt;/li>
&lt;li>&lt;a href="#gamma分布与一些常见分布的联系">Gamma分布与一些常见分布的联系&lt;/a>&lt;/li>
&lt;li>&lt;a href="#附gamma函数beta函数关系以及其他函数">附：Gamma函数、Beta函数关系以及其他函数&lt;/a>&lt;/li>
&lt;li>&lt;a href="#gamma函数与beta函数关系推导">Gamma函数与Beta函数关系推导&lt;/a>&lt;/li>
&lt;li>&lt;a href="#gamma函数与psi函数">Gamma函数与Psi函数&lt;/a>&lt;/li>
&lt;li>&lt;a href="#gamma函数与zeta函数">Gamma函数与zeta函数&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="数学分析之两类欧拉积分">数学分析之两类欧拉积分&lt;!-- omit in toc -->&lt;/h2>
&lt;p>在概率论、微积分等数学领域中，我们经常能见到Beta函数（分布）、Gamma函数这种十分奇特的函数形式，他们很难从直觉上理解形式、作用，但是在很多时候有发挥着基础性作用。这不禁让人们好奇人们是怎么发现这两个奇葩的存在。这就要提到一位传奇数学巨匠——欧拉，他一生数学贡献无数，在数学及许多分支中都可以见到很多以欧拉命名的常数、公式和定理，他的工作使得数学更接近于现代数学的形态。他不但为数学界作出贡献，更把数学推至几乎整个物理的领域。此外欧拉还涉及建筑学、弹道学、航海学等领域。法国大数学家拉普拉斯曾说过一句话——“读读欧拉，他是所有人的老师。”两类欧拉积分，无疑也为其光辉的数学生涯又增加了浓墨重彩的一笔。两类欧拉积分的具体形式如下：&lt;/p>
&lt;p>第一类欧拉积分(Beta函数)： &lt;span class="math">\[
\Beta(x,y)=\int_0^1 t^{x-1}(1-t)^{y-1}\mathrm{d}t=\frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}\tag{1}
\]&lt;/span>&lt;/p>
&lt;p>第二类欧拉积分(Gamma函数)： &lt;span class="math">\[
\Gamma(x)=\int_0^\infty t^{x-1}e^{-t}\mathrm{d}t\tag{2}
\]&lt;/span>&lt;/p>
&lt;p>那么如此不直观的两个积分是如何被引入数学领域并在很多方向的起到奠基作用呢？这就用从&lt;strong>哥德巴赫对插值与阶乘的研究&lt;/strong>说起。&lt;/p>
&lt;h2 id="哥德巴赫的疑问插值与阶乘研究">哥德巴赫的疑问——插值与阶乘研究&lt;/h2>
&lt;p>克里斯蒂安·哥德巴赫（1690-1764）是活跃于17-18世纪的普鲁士（现德国）数学家，现在稍微对数学有些了解的人肯定会听过著名的“哥德巴赫猜想”，这个猜想描述起来十分简单：&lt;/p>
&lt;blockquote>
&lt;p>任一大于2的偶数，都可表示成两个素数之和。&lt;/p>
&lt;/blockquote>
&lt;p>但是，却是数论中存在最久的未解问题之一。哥德巴赫就是有这种能在简单事物中寻到复杂原理的直觉。两类欧拉积分函数的诞生，也同样来源于他对一个简单插值问题的研究。&lt;/p>
&lt;p>十七世纪的欧洲已经对科学实验与观测有了较为健全的认识，尤其是天文、海航领域，大量的观测与测量积累了丰富的相关数据，比如天文学上形体位置数据。由于每次观测都只获得一个结果，因此这些数据基本都是离散的数据。直观上来看，浩如烟海且庞杂多样的离散数据点令人头晕眼花，为了能提取出这些大量数据之中的精髓，总结数据的规律，数学家寄希望于&lt;strong>用一个相对简单的数学公式来替代大量的观测数据&lt;/strong>，&lt;strong>插值法&lt;/strong>的研究就此火热起来。内插，或称插值（英语：Interpolation），是一种通过已知的、离散的数据点，在范围内推求新数据点的过程或方法。求解科学和工程的问题时，通常有许多数据点借由采样、实验等方法获得，这些数据可能代表了有限个数值函数，其中自变量的值。而根据这些数据，我们往往希望得到一个连续的函数（曲线）。举个简单的例子：&lt;/p>
&lt;blockquote>
&lt;p>对于离散序列&lt;span class="math">\(\{(1,1),(2,q^1),(3,q^2),\dotsb,(k,q^{k-1}),\dotsb\},q\neq 1\)&lt;/span>的前&lt;span class="math">\(n\)&lt;/span>项之和，是否可以找出一条平滑的曲线穿过序列前&lt;span class="math">\(n\)&lt;/span>项的和？即 &lt;span class="math">\[f(n)=\sum_{i=1}^{n} a(i),\]&lt;/span> 找出一条过所有&lt;span class="math">\((n,f(n))\)&lt;/span>点且尽量简单的平滑曲线。&lt;/p>
&lt;/blockquote>
&lt;p>学过高中数学的读者很快就能发现，这个例子就是找的等比数列求和公式，画成图像是（&lt;span class="math">\(q=1.1\)&lt;/span>）：&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/插值等比序列.png" alt="插值等比序列" />&lt;p class="caption">插值等比序列&lt;/p>
&lt;/div>
&lt;p>当我们用将这些点用一条平滑的曲线连接起来之后，不禁会思考，可以不可以用一个简单的表达式（函数）来表示这条曲线呢？这也是插值研究的一个重要问题。对于上面这个例子，根据中学数学知识，我们不难给出这样一条非常符合要求的曲线，其函数表达式为： &lt;span class="math">\[
f(x)=\frac{1-q^x}{1-q}(q=1.1)\tag{3}
\]&lt;/span>&lt;/p>
&lt;p>显然所有离散点都在这条曲线上，并且得到这个十分简单的函数表达式意味着我们不用再记那些离散的点，即使序列有无限长也无所谓，只需要计算函数表达式就可以根据任意给出的&lt;span class="math">\(n\)&lt;/span>得到相应的结果&lt;span class="math">\(f(n)\)&lt;/span>。&lt;/p>
&lt;p>这里必须要指出，是不是我们只能使用这一条曲线穿过所有的点呢？当时不是。我们可以信手画很多种曲线，都穿过图中那些离散的点，但是为什么大家选择了图中那条曲线呢？一是因为在哥德巴赫和欧拉所处的时代，函数这一词不仅仅意味着定义域到值域的抽象映射，更需要有一个能写出来的解析表达式。如果无法写出来一个明确的表达式，这个函数通常是不会被考虑的。二是因为这条曲线要足够的“自然”，这意味这条曲线需要一定合理的意义。当然即使满足了以上两点，函数曲线也并不是唯一的，大多数时候我们只是采用了那条&lt;strong>最符合我们直观想法&lt;/strong>的函数曲线。&lt;/p>
&lt;p>此外，找到的这个函数还有一个非常重要的特点：&lt;strong>连续性：即使在非正整数的点，例如-1，0.4736，1.1,&lt;span class="math">\(\sqrt{2}\)&lt;/span>,100.12345，函数都是有值的&lt;/strong>。这意味着我们将表达式可用的范围（定义域）从正整数&lt;strong>解析延拓&lt;/strong>到了整个实数域（除了&lt;span class="math">\(q\neq 1\)&lt;/span>）。&lt;/p>
&lt;blockquote>
&lt;p>解析延拓（英语：Analytic continuation）是数学上将解析函数从较小定义域拓展到更大定义域的方法，延拓的基本原则是延拓后的函数在原来的区域上和原函数等值。&lt;/p>
&lt;/blockquote>
&lt;p>对离散数据的插值和延拓得到的解析表达式提升了问题处理的泛用性，算是提取了大量数据中的精髓。说句题外话，现在火热的神经网络监督学习方法本质上也是通过离散数据（训练数据）拟合和延拓最贴近现实的函数。&lt;/p>
&lt;p>哥德巴赫在处理一系列插值与延拓问题时，遇到了一个看似很简单，处理起来却很棘手的问题，即阶乘的插值。&lt;/p>
&lt;p>在一系列数列中，阶乘的表达方式并不复杂甚至说非常简单： &lt;span class="math">\[
1,1\times 2,1\times 2\times 3,\dotsb,1\times 2\times\dotsb\times n,\dotsb
\]&lt;/span> 哥德巴赫知道连加求和的通项公式非常好找，因此他希望找到一个优雅简洁的通项公式，即能准确地描述阶乘&lt;span class="math">\(n!\)&lt;/span>，又能够像求和公式&lt;span class="math">\(\frac{n(n+1)}{2}\)&lt;/span>那样可以推广到实数域。经过多次尝试，哥德巴赫并没有在这个问题上取得太大进展，因此，他决定向当时他所认识的多位著名数学家求助。&lt;/p>
&lt;h2 id="三封信中诞生的gamma函数">三封信中诞生的Gamma函数&lt;/h2>
&lt;h3 id="第一封丹尼尔-伯努利的解答">第一封：丹尼尔-伯努利的解答&lt;/h3>
&lt;p>1722年他找尼古拉斯-伯努利请教这个阶乘插值问题，不过没有取得任何进展。即便如此，哥德巴赫却多年来一直不忘思考这个问题，1729 年他又请教尼古拉斯-伯努利的弟弟丹尼尔-伯努利，正好当时丹尼尔-伯努利对无穷级数有着很深入的了解，他从中获取灵感，于当年 10 月给哥德巴赫的一封回信中以无穷级数的形式给出了漂亮的解答。 &lt;span class="math">\[
x!=\lim_{A\rightarrow\infty}(A+1+\frac{x}{2})^{x-1} \prod_{i=1}^A \frac{i+1}{i+x}\tag{4}
\]&lt;/span> 这个插值公式的效果随&lt;span class="math">\(A\)&lt;/span>的增大而收敛，我们给出了一些&lt;span class="math">\(A\)&lt;/span>值下的结果图： &lt;img src="../../images/Bernoulli_interpolation.png" alt="bernoulli_interpolation" />&lt;/p>
&lt;p>丹尼尔-伯努利通过无穷级数首先给出了一个阶乘解析表达式，虽然看上去很不好用，但是收敛速度还是挺快的，并且给接下来欧拉的研究提供灵感。&lt;/p>
&lt;h3 id="第二封欧拉的无穷级数型解答">第二封：欧拉的无穷级数型解答&lt;/h3>
&lt;p>当哥德巴赫向丹尼尔-伯努利写信咨询时，他正在圣彼得堡担任科学院成员，而他此时身边有一位好朋友叫莱昂纳德-欧拉，对这个找阶乘函数的问题也表现出了兴趣。同样，借助于&lt;strong>无穷&lt;/strong>这个强大工具，他在论文&lt;a href="https://arxiv.org/abs/1201.5631">《De termino generali serium hypergeometricarum》&lt;/a>中给出了自己的思路。&lt;/p>
&lt;blockquote>
&lt;p>Tips: 无穷的运算法则：&lt;/p>
&lt;ul>
&lt;li>&lt;span class="math">\(\infty\plusmn a=\infty,\forall a\in R\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\(-\infty\plusmn a=-\infty,\forall a\in R\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\(\infty\times a=\infty,\forall a&amp;gt;0\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\(\infty\times -a=-\infty,\forall a&amp;gt;0\)&lt;/span>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>对于一个无穷大数&lt;span class="math">\(n\rightarrow\infty\)&lt;/span>，任一有限数字&lt;span class="math">\(x\)&lt;/span>，有 &lt;span class="math">\[
(n+x)!=n!\times (n+1)\times(n+2)\times\dotsb\times(n+x)\tag{5}
\]&lt;/span> 显然，一般理解下式&lt;span class="math">\((5)\)&lt;/span>只有当&lt;span class="math">\(x\)&lt;/span>为正整数时才合理。为了方便讨论，欧拉假设已经找到了一个适用于整个正实数域的阶乘插值函数（负数和复数以后再讨论），不妨令其为&lt;span class="math">\(\Delta(x),x\in R^+\)&lt;/span>，即式(5)为： &lt;span class="math">\[
\Delta(n+x)=\Delta(n)\times(n+1)\times(n+2)\times\dotsb\times(n+x)\tag{5.1}
\]&lt;/span> 若&lt;span class="math">\(x\)&lt;/span>为正整数，则&lt;span class="math">\(\Delta(x)=x!\)&lt;/span>。而根据无穷大的计算法则，当&lt;span class="math">\(n\rightarrow \infty\)&lt;/span>： &lt;span class="math">\[
n+1=n\quad n+2=n\quad \dotsb \quad n+x=n
\]&lt;/span> 因此，式&lt;span class="math">\((5.1)\)&lt;/span>可以写成 &lt;span class="math">\[
\Delta(n+x)=\Delta(n)\times n^x\tag{6}
\]&lt;/span> 此时，欧拉再利用无穷大的性质，当&lt;span class="math">\(n\rightarrow \infty\)&lt;/span>时，&lt;span class="math">\(n+\alpha=n\)&lt;/span>，&lt;span class="math">\(\alpha\)&lt;/span>是任一有限数。欧拉再将式&lt;span class="math">\((6)\)&lt;/span>中的&lt;span class="math">\(n^x\)&lt;/span>代换为&lt;span class="math">\((n+\alpha)^x\)&lt;/span>，即 &lt;span class="math">\[
\Delta(n+x)=\Delta(n)\times (n+\alpha)^x\tag{7}
\]&lt;/span> 若取&lt;span class="math">\(\alpha=1\)&lt;/span>，则&lt;span class="math">\((7)\)&lt;/span>可写成： &lt;span class="math">\[
\Delta(x+n)=\Delta(n)\times (n+1)^x, n\rightarrow\infty\\
\Rightarrow \lim_{n\rightarrow\infty}\frac{\Delta(n)\times(n+1)^x}{\Delta(n+x)}=1\tag{8}
\]&lt;/span> 最终，两边同时乘以&lt;span class="math">\(x\)&lt;/span>的阶乘函数&lt;span class="math">\(\Delta(x)\)&lt;/span>，则有： &lt;span class="math">\[
\Delta(x)=\lim_{n\rightarrow\infty}\frac{\Delta(n)\times(n+1)^x}{\Delta(n+x)}\times\Delta(x)\\
=\lim_{n\rightarrow\infty}\frac{1\cdot 2\cdot\dotsb \cdot n\times(n+1)^x}{(x+1)(x+2)\dotsb(x+n)},x\in R^+\tag{9}
\]&lt;/span> 上式(9)就是欧拉得到的无穷乘积形式的阶乘函数。从欧拉给出的思路来看，他真是将无穷的性质玩出花来了，当&lt;span class="math">\(n\)&lt;/span>取值远大于&lt;span class="math">\(x\)&lt;/span>时，这些式子的精度都很高。反复利用无穷性质的缺点是欧拉所给出的无穷乘积（式(9)）表达式的收敛速度，并没有丹尼尔伯努利给出的无穷乘积表达式（式(4)）收敛速度快。同时，丹尼尔-伯努利和欧拉二者给出的不同结果也告诉我们：满足整数点阶乘计算结果的插值&lt;strong>阶乘函数并不唯一&lt;/strong>。&lt;/p>
&lt;h3 id="无穷乘积中欧拉的发现">无穷乘积中欧拉的发现&lt;/h3>
&lt;p>我们发现无论是式(4)还是式(9)，&lt;span class="math">\(x\)&lt;/span>的取值都可以是任意正实数，并非一定要是整数，不过欧拉的无穷乘积表达式却是一只会下金蛋的鸡。欧拉作为20岁前就熟读伐里农、牛顿、笛卡尔、伽利略、雅各布-伯努利、约翰-伯努利、泰勒、沃利斯著作的学神，发现自己的无穷乘积表达式（是(9)）和英国数学家沃利斯发现的沃利斯乘积具有相似性。沃里斯乘积： &lt;span class="math">\[
\prod_{n=1}^{\infty}{\frac{2n}{2n-1}}\cdot {\frac{2n}{2n+1}}={\frac{2}{1}}\cdot {\frac {2}{3}}\cdot {\frac {4}{3}}\cdot {\frac {4}{5}}\cdot {\frac {6}{5}}\cdot {\frac {6}{7}}\cdot {\frac {8}{7}}\cdot {\frac {8}{9}}\cdots ={\frac {\pi }{2}}\tag{10}
\]&lt;/span> 而自己的无穷乘积表达式在&lt;span class="math">\(x=\frac{1}{2}\)&lt;/span>的时候，有： &lt;span class="math">\[
\begin{aligned}
&amp;amp;\lim_{n\rightarrow\infty}\frac{1\cdot 2\cdot\dotsb \cdot n\times(n+1)^x}{(x+1)(x+2)\dotsb(x+n)}\bigg|_{x=\frac{1}{2}}\\
&amp;amp;=\lim_{n\rightarrow\infty}(n+1)^{\frac{1}{2}}\frac{1}{\frac{1}{2}+1}\cdot\frac{2}{\frac{1}{2}+2}\cdot\frac{3}{\frac{1}{2}+3}\cdot\dotsb\frac{n}{\frac{1}{2}+n}\\
&amp;amp;=\lim_{n\rightarrow\infty}\sqrt{n+1}\cdot \frac{2}{3}\cdot \frac{4}{5}\cdot \frac{6}{7}\dotsb \cdot \frac{2n}{2n+1}\\
&amp;amp;=\lim_{n\rightarrow\infty}\sqrt{n+1}\cdot \sqrt{(\frac{2}{3}\cdot \frac{4}{5}\cdot \frac{6}{7}\dotsb \cdot \frac{2n}{2n+1})\cdot (\frac{2}{3}\cdot \frac{4}{5}\cdot \frac{6}{7}\dotsb \cdot \frac{2n}{2n+1})}\\
&amp;amp;=\lim_{n\rightarrow\infty}\sqrt{n+1}\cdot \sqrt{\frac{2\cdot 2 \cdot 4 \cdot 4\cdot 6\cdot 6\dotsb 2n \cdot 2n}{3\cdot 3 \cdot 5 \cdot 5 \cdot 7 \dotsb \cdot(2n+1)\cdot(2n+1)}}\\
&amp;amp;=\lim_{n\rightarrow\infty}\sqrt{\frac{n+1}{2n+1}}\cdot \sqrt{\underbrace{\prod_{i=1}^{n}{\frac{2i}{2i-1}}\cdot {\frac{2i}{2i+1}}}_{沃利斯乘积=\frac{\pi}{2}}}\tag{11}
\end{aligned}
\]&lt;/span> 欧拉惊奇地发现，后面那一项正是沃里斯公式（式(10)）的表达式，由此，我们可以将上式简写成： &lt;span class="math">\[
\Delta(\frac{1}{2})=\frac{1}{2}!=\lim_{n\rightarrow\infty}\sqrt{\frac{n+1}{2n+1}}\cdot \sqrt{\prod_{i=1}^{n}{\frac{2i}{2i-1}}\cdot {\frac{2i}{2i+1}}}\\
=\sqrt{\frac{1}{2}}\sqrt{\frac{\pi}{2}}=\frac{\sqrt{\pi}}{2}\tag{12}
\]&lt;/span> 出乎意料，在阶乘的函数表达式中出现了&lt;span class="math">\(\pi\)&lt;/span>。此时，欧拉意识到这个阶乘表达式可能与圆或者求面积有着密切联系，而求面积是积分的本职工作。此外，沃利斯也是在研究曲线下方面积（用现在角度看就是积分）时得到的沃利斯乘积，因此欧拉闪过灵感，&lt;strong>能否用积分的形式来替代无穷乘积形式表示阶乘函数呢&lt;/strong>？&lt;/p>
&lt;h3 id="第三封欧拉的积分函数型解答">第三封：欧拉的积分函数型解答&lt;/h3>
&lt;p>参考了前辈沃利斯、牛顿和斯特林的积分研究成果，欧拉选取了以下积分形式： &lt;span class="math">\[
J(e,n)=\int_0^1 x^e(1-x)^n\mathrm{d}x\tag{13}
\]&lt;/span> 其中&lt;span class="math">\(e\)&lt;/span>是任意数，&lt;span class="math">\(n\)&lt;/span>是整数。这个式子细看其实已经是第一类欧拉积分的原型了，后来勒让德修改了式(13)的形式，得到式(1)，Beta函数。 &lt;span class="math">\[
B(x,y)=\int_0^1 t^{x-1}(1-t)^{y-1}\mathrm{d}t\tag{1}
\]&lt;/span> 相较于第二类欧拉积分，它出现的更早，并且由式(13)推导出了第二类欧拉积分（式(2)），因此我们反而把更复杂一些的式(13)的形式定义为“第一类”欧拉积 分。&lt;/p>
&lt;p>我们通过分部积分法来处理式(13): &lt;span class="math">\[
\begin{aligned}
J(e,n)&amp;amp;=\frac{1}{e+1}x^{e+1}(1-x)^n\bigg |_0^1-\int_0^1 \frac{-n}{e+1}x^{e+1}(1-x)^{n-1}\mathrm{d}x\\
&amp;amp;=0+\frac{n}{e+1}\int_0^1 x^{e+1}(1-x)^{n-1}\mathrm{d}x\\
&amp;amp;=\frac{n}{e+1}J(e+1,n-1)
\end{aligned}\tag{14}
\]&lt;/span> 每用一次分部积分，&lt;span class="math">\(e\)&lt;/span>加一，&lt;span class="math">\(n\)&lt;/span>减一。这样我们递归地使用分部积分法可得： &lt;span class="math">\[\begin{aligned}
J(e,n)&amp;amp;=\frac{n}{e+1}J(e+1,n-1)\\
&amp;amp;=\frac{n(n-1)}{(e+1)(e+2)}J(e+2,n-2)\\
&amp;amp;\qquad\qquad\vdots\\
&amp;amp;=\frac{n(n-1)\dotsb 2\cdot 1}{(e+1)(e+2)\dotsb(e+n)}J(e+n,0)\\
&amp;amp;=\frac{n(n-1)\dotsb 2\cdot 1}{(e+1)(e+2)\dotsb(e+n)}\int_0^1 x^{e+n}(1-x)^0\mathrm{d}x\\
&amp;amp;=\frac{n!}{(e+1)(e+2)\dotsb(e+n)(e+n+1)}
\end{aligned}\tag{15}
\]&lt;/span> 即 &lt;span class="math">\[
\int_0^1 x^{e}(1-x)^n\mathrm{d}x=\frac{n!}{(e+1)(e+2)\dotsb(e+n)(e+n+1)}\tag{15.1}
\]&lt;/span> 欧拉经过分部积分，已经将阶乘&lt;span class="math">\(n!\)&lt;/span>与积分&lt;span class="math">\(\int_0^1 x^{e}(1-x)^n\mathrm{d}x\)&lt;/span>联系了起来，此时如果能将分母中&lt;span class="math">\((e+1)(e+2)\dotsb(e+n)(e+n+1)\)&lt;/span>与&lt;span class="math">\(n\)&lt;/span>的相关内容分离出来，就能够得到&lt;span class="math">\(n!\)&lt;/span>的积分表达式了！&lt;/p>
&lt;p>欧拉使用了一个处理技巧，令&lt;span class="math">\(e=\frac{f}{g}\)&lt;/span>，代入得： &lt;span class="math">\[
\int_0^1 x^{\frac{f}{g}}(1-x)^n\mathrm{d}x=\frac{n!}{(\frac{f}{g}+1)(\frac{f}{g}+2)\dotsb(\frac{f}{g}+n)(\frac{f}{g} +n+1)}\\
=\frac{n!\cdot g^{n+1}}{(f+g)(f+2g)\dotsb(f+ng)(f+(n+1)g)}\tag{16}
\]&lt;/span> 将等式右侧的&lt;span class="math">\(g^{n+1}\)&lt;/span>转移到另一侧，可得 &lt;span class="math">\[
\frac{\int_0^1 x^{\frac{f}{g}}(1-x)^n\mathrm{d}x}{g^{n+1}}=\frac{n!}{(f+g)(f+2g)\dotsb(f+ng)(f+(n+1)g)}\tag{16.1}
\]&lt;/span> 如果我们取&lt;span class="math">\(f=1,g\rightarrow 0\)&lt;/span>，那么等式右侧(RHS)在取极限时就会只剩下&lt;span class="math">\(n!\)&lt;/span>，而等式左侧(LHS)则是一个奇怪的结构： &lt;span class="math">\[
\lim_{g\rightarrow 0},_{f=1}\frac{\int_0^1 x^{\frac{f}{g}}(1-x)^n\mathrm{d}x}{g^{n+1}}=\frac{\int_0^1 x^{\frac{1}{0}}(1-x)^n\mathrm{d}x}{0^{n+1}}\tag{17}
\]&lt;/span> 为了处理这个结构，欧拉对积分变量做了一个代换，令&lt;span class="math">\(y=x^{\frac{f+g}{g}}\)&lt;/span>，&lt;span class="math">\(y\)&lt;/span>的积分域显然也是&lt;span class="math">\([0,1]\)&lt;/span>，则&lt;span class="math">\(x=y^{\frac{g}{f+g}}\)&lt;/span>，那么式(16.1)左侧可改写成： &lt;span class="math">\[
\begin{aligned}
(16.1)LHS&amp;amp;=\frac{\int_0^1 (y^{\frac{g}{f+g}})^{f/g}(1-y^{\frac{g}{f+g}})^n\mathrm{d}(y^{\frac{g}{f+g}})}{g^{n+1}}\\
&amp;amp;=\frac{\int_0^1 y^{\frac{f}{f+g}}(1-y^{\frac{g}{f+g}})^n (\frac{g}{f+g}y^{\frac{-f}{f+g}})\mathrm{d}y}{g^{n+1}}\\
&amp;amp;=\frac{\int_0^1 (1-y^{\frac{g}{f+g}})^n \mathrm{d}y}{g^{n}(f+g)}\\
&amp;amp;=\frac{1}{(f+g)^{n+1}}\int_0^1(\frac{1-y^{\frac{g}{f+g}}}{\frac{g}{f+g}})^n\mathrm{d}y
\end{aligned}\tag{18}
\]&lt;/span> 此时，我们再看式(18)的结果，其关键结构就是&lt;span class="math">\(\frac{1-y^{\frac{g}{f+g}}}{\frac{g}{f+g}}\)&lt;/span>，为了方便我们令&lt;span class="math">\(z=\frac{g}{f+g}\)&lt;/span>，当取&lt;span class="math">\(f=1,g\rightarrow 0\)&lt;/span>时，显然有&lt;span class="math">\(z\rightarrow 0\)&lt;/span>，即 &lt;span class="math">\[
\lim_{z\rightarrow 0}\frac{1-y^z}{z}\xlongequal{洛必达法则}\frac{-y^z\ln y}{1}\\
=-\ln y\tag{19}
\]&lt;/span> 将式(19)的结果代入式(18)，并联立式(16)可得： &lt;span class="math">\[
\int_0^1 (-\ln y)^n\mathrm{d}y=n!\tag{20}
\]&lt;/span> 为了追寻最后结果好看，也可以把&lt;span class="math">\(y\)&lt;/span>写成&lt;span class="math">\(x\)&lt;/span>，但是本文为了标识清晰，就保留&lt;span class="math">\(y\)&lt;/span>来表示。式(20)就是欧拉在原式论文中给出的结果，不过和式(2)给出的第二类欧拉积分似乎还有点不同。其实式(2)和(20)式等价的，我们只要令&lt;span class="math">\(y=e^{-t}\)&lt;/span>，那么便有： &lt;span class="math">\[
n!=\int_0^1 (-\ln e^{-t})^n\mathrm{d}e^{-t}=\int_0^\infty t^n e^{-t}\mathrm{d}t\tag{21}
\]&lt;/span> 显然，其结果就是第二类欧拉积分，又称为&lt;span class="math">\(\Gamma\)&lt;/span>函数。其在正实数范围内的图像如下图：&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/gamma-function-posotive-real.png" alt="gamma-function-posotive-real" />&lt;p class="caption">gamma-function-posotive-real&lt;/p>
&lt;/div>
&lt;p>需要注意的是，上式的函数和真正的&lt;span class="math">\(\Gamma\)&lt;/span>函数有一位偏移。做出这个偏移决定的也是欧拉，这也使得&lt;span class="math">\(\Gamma(x)=(x-1)!\)&lt;/span>而非&lt;span class="math">\(x!\)&lt;/span>。&lt;/p>
&lt;p>哥德巴赫和欧拉在关于阶乘函数的通信中诞生了两类欧拉积分即Beta函数和Gamma函数，此时是1730年，欧拉只有23岁。从此数学家对他们的探索就从未停止过，并且得出了许多改变数学历史的结论。我们将这些细节在下一章中说明。&lt;/p>
&lt;h2 id="欧拉积分的进一步探究">欧拉积分的进一步探究&lt;/h2>
&lt;h3 id="beta和gamma函数的命名">Beta和Gamma函数的命名&lt;/h3>
&lt;p>当欧拉在给哥德巴赫的回信中第一次给出两类积分的时候，显然不会像后世有“后验”经验的数学家那样意识到这两个积分函数的将会带来多大的数学财富。由于欧拉在当时已经是名满欧洲的大数学家，并且涉猎的领域宽广，因此很多其他方面的问题让欧拉并不能专心深入研究两类积分。&lt;/p>
&lt;p>不过，当时很多著名的数学家都和欧拉有着密切的联系，比如法国18世纪末的三个著名数学家，即称为“法国3L”的拉格朗日（Lagrange）、拉普拉斯（Laplace）和勒让德（Legendre）。他们三人都是欧拉的后辈，且深受欧拉的影响，拉格朗日是欧拉的学生，拉普拉斯则是拉格朗日的同事，文章开头那句“读读欧拉，他是所有人的老师。”就是拉普拉斯说的。而勒让德是被拉格朗日发觉的数学家，其关于椭圆曲线和数论的研究很大程度上基于欧拉的研究，并且是欧拉时代到高斯时代的重要过渡者（虽然被夹在两个巨匠之间掩盖了勒让德本身的光芒，尤其是高斯&lt;sup>-&lt;/sup>）&lt;/p>
&lt;p>勒让德花了许多时间研究欧拉相关的积分，并发表了几篇文章，在&lt;strong>1792年的文章《Mémoires sur les transcendantes elliptiques》（关于超越椭圆函数的备忘录）中首次将式（1）的形式命名为第一类欧拉积分&lt;/strong>。在1809年的《Recherches sur diverses sortes d'intégrales définies》（各类定积分的研究）中，勒让德正式地命名和引入了第一类欧拉积分（式(1)）和第二类欧拉积分（式(2)），并引入了符号&lt;span class="math">\(\Gamma\)&lt;/span>来表示第二类欧拉积分，即 &lt;span class="math">\[
\Gamma(x)=\int_0^\infty t^{x-1}e^{-t}\mathrm{d}t \tag{2.1}
\]&lt;/span> 至于为什么勒让德只给第二类欧拉积分找了个代表符号容易理解，因为第二类欧拉积分正好是欧拉找到的表示阶乘的连续函数，得到了更多重视，而第一类欧拉积分则是在推导过程中的一个辅助积分。而勒让德选择符号&lt;span class="math">\(\Gamma\)&lt;/span>的原因，Julio González Cabillón猜测因为一是符号&lt;span class="math">\(\Gamma\)&lt;/span>是勒让德（LeGendre）中“L”倒过来写，二是“Gamma”中的“G”代表自己名字中的“Gendre”。&lt;/p>
&lt;p>不过，随着研究的深入，直到1839年Jacques P. M. Binet才引入了符号&lt;span class="math">\(\Beta\)&lt;/span>（Beta ）表示第一类欧拉积分，他选用&lt;span class="math">\(\Beta\)&lt;/span>的原因也很简单，一是因为他名字中有字母“B”，二是第二类欧拉积分是由第一类欧拉积分推导出来的，理应使用希腊字母表中“&lt;span class="math">\(\Gamma\)&lt;/span>”的前一位字母“&lt;span class="math">\(\Beta\)&lt;/span>”。&lt;/p>
&lt;h3 id="积分函数的偏移">积分函数的偏移&lt;/h3>
&lt;p>如果仔细看欧拉得出的结果式(21)然后对比勒让德定义的&lt;span class="math">\(\Gamma\)&lt;/span>函数的表达式(2.1) &lt;span class="math">\[
n!=\int_0^\infty t^n e^{-t}\mathrm{d}t=\Gamma(n+1)\tag{22}
\]&lt;/span> 可以发现，欧拉的得出表达式严格来说并不是现在使用的第二类欧拉积分的表达式，&lt;strong>他们之间有一位偏移&lt;/strong>，即&lt;span class="math">\(\Gamma(n)\neq n!\)&lt;/span>而是等于&lt;span class="math">\((n-1)!\)&lt;/span>。其实，如果我们将式(21)的形式定义成&lt;span class="math">\(\Gamma\)&lt;/span>函数也不是不可以，事实上欧拉最初研究这个问题就用的式(21)的结果，此外欧拉的后辈数学王子高斯在研究这个积分也使用的如下形式： &lt;span class="math">\[
\Pi(x)=\int_0^\infty t^x e^{-t}\mathrm{d}t\tag{23}
\]&lt;/span> 当时主推式(2)定义的人是勒让德，即上文定义的式(2.1) &lt;span class="math">\[
\Gamma(x)=\int_0^\infty t^{x-1}e^{-t}\mathrm{d}t \tag{2.1}
\]&lt;/span> 相应地，第一类欧拉积分在勒让德定义时也区别与刚被引入时的原始形式，也做了一位偏移，即 &lt;span class="math">\[
\int_0^1 t^x(1-t)^y\mathrm{d}t\rightarrow\int_0^1 t^{x-1}(1-t)^{y-1}\mathrm{d}t\tag{24}
\]&lt;/span> 从后世的角度来看，显然勒让德偏移一位的定义方式更被人普遍接受。实际上，勒让德在研究时发现，在1768年欧拉的著作《Institutiones calculi integralis》中，欧拉引入第一类积分时已经对积分参数做了-1的修改。欧拉在《Institutiones calculi integralis》中研究的积分形式如下： &lt;span class="math">\[
\int_0^1 \frac{x^{p-1}}{\sqrt[n]{1-x^n}^{n-q}}\mathrm{d}x\tag{25}
\]&lt;/span> 当&lt;span class="math">\(n=1\)&lt;/span>时，式(25)即为第一类欧拉积分（Beta函数）。勒让德依照欧拉的方式，同样对第二类欧拉积分做出了-1的偏移，可以说欧拉的研究影响了勒让德，让其决定采用了-1位的偏移。&lt;/p>
&lt;p>至于为什么要最终采用-1位偏移的定义，且更广为接受呢？一个可能的原因是Beta函数与Gamma函数关系。按照勒让德的定义方式（式(2.1)），那么两个函数之间的关系可以简洁地写成： &lt;span class="math">\[
\Beta(x,y)=\frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}\tag{26}
\]&lt;/span> 式(26)简洁、对称，优雅，很符合数学家们的审美。如果按照不偏移的定义，即高斯的定义（式(23)），那么他们之间的关系则是 &lt;span class="math">\[
\Beta&amp;#39;(x,y)=\frac{\Pi(x)\pi(y)}{\Pi(x+y+1)}\tag{27}
\]&lt;/span> 分母那个多余的1，不仅仅会破坏对称美感，而且在计算种种带来额外项。&lt;/p>
&lt;p>另一个可能的猜测则与抽象代数有关，按照勒让德的定义式(2.1)，&lt;span class="math">\(\Gamma\)&lt;/span>分布的概率密度函数和卷积可以组成一个半环，而不做偏移的定义形式则没有这个性质。虽然有关群论的内容需要等待欧拉死后大约半个世纪的阿贝尔和伽罗华才初步建立，但是欧拉未出版的一些手稿中已经体现了群论的初步思想。至于欧拉是否也发现式(2.1)的形式在群论计算中的便利性，我们就无从得知了。不过，正因为群论的发展，使得式(2.1)的定义方式更广泛地被接受。&lt;/p>
&lt;h3 id="第二类欧拉积分的负数复数延拓以及统一表达式">第二类欧拉积分的负数、复数延拓以及统一表达式&lt;/h3>
&lt;p>在欧拉进行阶乘延拓的时候，他考虑的是正实数场景，当&lt;span class="math">\(x\in R^+\)&lt;/span>时，第二类欧拉积分，即&lt;span class="math">\(\Gamma(x)\)&lt;/span>函数是有定义且连续的，具体证明可参考网页资料&lt;a href="../../网页资料/数学分析-学习笔记-Γ函数和B函数.html">数学分析-学习笔记-Γ函数和B函数.html&lt;/a>。正如从整数向正实数的解析延拓促使了&lt;span class="math">\(\Gamma\)&lt;/span>函数的诞生，在此之后，数学家们开始希望将阶乘的概念拓展到负数与复数。&lt;/p>
&lt;p>对于负数而言，虽说式(2)的形式并不适用，但是阶乘的思想还是能够借鉴的，关键就是递推公式： &lt;span class="math">\[
\Gamma(x+1)=x\Gamma(x)\tag{28}
\]&lt;/span> 那么如果我们不停地给自变量&lt;span class="math">\(x\)&lt;/span>减1，那么&lt;span class="math">\(x\)&lt;/span>很快就会落入负数的范围，比如： &lt;span class="math">\[
\begin{aligned}
&amp;amp;{1\over 2}!=\Gamma({3\over 2})=({1\over 2})\times \Gamma({3\over 2}-1)=({1\over 2})\times \Gamma({1\over 2})\\
&amp;amp;{1\over 2}!=({1\over 2})\times(-{1\over 2})\times \Gamma({1\over 2}-1)=({1\over 2})\times (-{1\over 2})\times \Gamma(-{1\over 2})\\
&amp;amp;{1\over 2}!=({1\over 2})\times(-{1\over 2})\times(-{3\over 2})\times \Gamma(-{1\over 2}-1)\\
&amp;amp;\qquad=({1\over 2})\times(-{1\over 2})\times (-{3\over 2})\times \Gamma(-{3\over 2})=(-{5\over 2})!\\
\end{aligned}\tag{29}
\]&lt;/span> 我们将递推关系反转过来，我们能够很轻易地得到阶乘的负数延拓，比如： &lt;span class="math">\[
(-{5\over 2})!=\Gamma(-{3\over 2})=({2\over 1})\times (-{2\over 1})\times (-{2\over 3})\times \underbrace{\Gamma({3\over 2})}_{=\frac{1}{2}!=\frac{\sqrt{\pi}}{2}}=\frac{4\sqrt{\pi}}{3}\tag{30}
\]&lt;/span> 依据递推关系，我们只要计算出&lt;span class="math">\(\Gamma\)&lt;/span>函数在0-1范围内的值，就可以推得&lt;strong>几乎所有&lt;/strong>负数&lt;span class="math">\(\Gamma\)&lt;/span>函数的值。注意，我这里使用的是“几乎”所有。这是因为使用递推关系有一个巨大的问题，即无法处理负整数的情形。比如-2的阶乘通过递推关系应该是： &lt;span class="math">\[
\Gamma(-1)=(-2)! \\
\Gamma(-1)\times (-1) \times 0 \times 1 = 1! =\Gamma(2)\tag{31}
\]&lt;/span> 但是这个连乘式子中有一个&lt;span class="math">\(\times 0\)&lt;/span>，结果理应是0，而不是&lt;span class="math">\(1!\)&lt;/span>，相应地，&lt;span class="math">\(\Gamma\)&lt;/span>函数在所有负整数的延拓都没有良好的定义，负整数是函数的极点。延拓到负数部分的&lt;span class="math">\(\Gamma\)&lt;/span>函数如下图：&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/Gamma-function-real.svg" alt="Gamma-function-real.svg" />&lt;p class="caption">Gamma-function-real.svg&lt;/p>
&lt;/div>
&lt;p>相比于负数的延拓，复数的延拓要容易的多，因为&lt;span class="math">\(\Gamma\)&lt;/span>函数在自变量是“兼容”复数的，对于实数部分为正的复数&lt;span class="math">\(z,Re(z)&amp;gt;0\)&lt;/span>，我们甚至不必修改欧拉给出的式子原型。对于实数部分为负的复数&lt;span class="math">\(z,Re(z)&amp;gt;0\)&lt;/span>，只要实部不是负整数，也可以通过递推关系式得到。而实部为负整数的点，就是函数在复平面的极点。&lt;/p>
&lt;blockquote>
&lt;p>TIPS：全纯函数（英语：Holomorphic function）是复分析研究的中心对象；它们是定义在复平面&lt;span class="math">\(\mathbb {C}\)&lt;/span>的开子集上的，在复平面&lt;span class="math">\(\mathbb {C}\)&lt;/span>中取值的，在每点上皆复可微的函数(处处解析)。&lt;/p>
&lt;p>在复变函数中，亚纯函数（meromorphic function）是在区域&lt;span class="math">\(D\)&lt;/span>上有定义，且除去极点之外处处解析的函数。具体来说就是在复分析中，一个复平面的开子集&lt;span class="math">\(D\)&lt;/span>上的亚纯函数是一个在&lt;span class="math">\(D\)&lt;/span>上除一个或若干个孤立点集合之外的区域全纯的函数，那些孤立点称为该函数的极点。&lt;/p>
&lt;p>显然&lt;span class="math">\(\Gamma(x)\)&lt;/span>函数由于在负整数为极点，其他位置处处解析，因此它是亚纯函数，而&lt;span class="math">\(\Gamma(x)\)&lt;/span>函数的倒数&lt;span class="math">\(\frac{1}{\Gamma(x)}\)&lt;/span>却是处处解析的全纯函数（&lt;span class="math">\(\frac{1}{\Gamma(x)}\)&lt;/span>实部为负整数的点函数值都为0），因此在处理&lt;span class="math">\(\Gamma(x)\)&lt;/span>函数，很多数学家会从&lt;span class="math">\(\frac{1}{\Gamma(x)}\)&lt;/span>着手。&lt;/p>
&lt;/blockquote>
&lt;p>在整个复平面，&lt;span class="math">\(\Gamma\)&lt;/span>函数的&lt;strong>绝对值&lt;/strong>图像如下（注：那些顶端平的部分是为了方便显示，函数值截断的结果）&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/Gamma_abs_3D.png" alt="Gamma_abs_3D" />&lt;p class="caption">Gamma_abs_3D&lt;/p>
&lt;/div>
&lt;p>数学家F.W. Newman在1848年给了&lt;span class="math">\(\Gamma\)&lt;/span>函数在整个复平面一个通用的表达式(32)，利用了&lt;span class="math">\(1/\Gamma(z)\)&lt;/span>是全纯函数的特性。 &lt;span class="math">\[
1/\Gamma(z)=ze^{\gamma z}\prod_{k=1}^{\infty}[(1+\frac{z}{k})e^{-\frac{z}{k}}],\qquad \gamma=0.5772156649\dotsb\tag{32}
\]&lt;/span> 其中，&lt;span class="math">\(\gamma\)&lt;/span>为欧拉-马斯刻若尼常数，简称欧拉常数&lt;span class="math">\(\gamma = \lim\limits_{n \rightarrow \infty }[( \sum_{k=1}^n \frac{1}{k} - \ln(n)]\)&lt;/span>。&lt;/p>
&lt;h3 id="第二类欧拉积分与阶乘延拓的唯一性">第二类欧拉积分与阶乘延拓的唯一性&lt;/h3>
&lt;p>阶乘的解析延拓是唯一的吗？答案是显然的：No。我们回到开头插值的问题，最开始介绍&lt;a href="#哥德巴赫的疑问插值与阶乘研究">哥德巴赫的疑问——插值与阶乘研究&lt;/a>的时候就提到如果单纯地找插值函数，数学家们可以找出无数条符合要求的曲线。在丹尼尔-伯努利和欧拉分别写信告诉哥德巴赫他们的无穷乘积结果时，给出的也是两个不同的无穷乘积形式，并且都能够很好地做为阶乘的插值函数。&lt;/p>
&lt;p>后来的数学家也解析延拓出了其他的阶乘函数，比如在1894年，法国数学家Hadamard利用&lt;span class="math">\(\Gamma\)&lt;/span>函数给出了一个在整个复平面内都解析的全纯函数： &lt;span class="math">\[
y=\frac{1}{\Gamma(1-x)}\frac{\mathrm{d}}{\mathrm{d}x}\log\left[\Gamma(\frac{1-x}{2})/\Gamma(1-\frac{x}{2})\right],x\in \mathbb{C}\tag{33}
\]&lt;/span> 其函数图像如下：&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/hadamard阶乘函数.png" alt="hadamard阶乘函数.png" />&lt;p class="caption">hadamard阶乘函数.png&lt;/p>
&lt;/div>
&lt;p>相较于&lt;span class="math">\(\Gamma(x)\)&lt;/span>，式(33)在整个复平面内没有奇异性，即使在负整数处也没有极点，从函数分析理论角度来看，它是一个更适合分析的函数。&lt;/p>
&lt;p>那么，为什么只有第二类欧拉积分，即&lt;span class="math">\(\Gamma(x)\)&lt;/span>函数得到了数学家们的广泛认可呢？&lt;/p>
&lt;p>从研究积分的角度看，这是显然的。因为欧拉积分在特殊函数中出现的频率非常高，第二类欧拉积分可以说是很多特殊积分的基础。而从插值的角度看，&lt;span class="math">\(\Gamma\)&lt;/span>函数的特殊性并不那么显然，虽然可以从美学上说，&lt;span class="math">\(\Gamma\)&lt;/span>函数简洁而优雅，但是数学要求我们找出更理性的证据。&lt;/p>
&lt;p>既然阶乘插值的结果千千万，那我们来考虑阶乘函数除插值外，还应当满足哪些必要的要求。首先，阶乘的核心是递推关系&lt;span class="math">\(n!=n(n-1)!\)&lt;/span>，我们先要把递推关系延拓到所有正实数&lt;span class="math">\(f(x+1)=xf(x)，x\in R^+\)&lt;/span>（注意我们这里仿照勒让德的定义方式做了一位偏移），这使得将阶乘的概念从正整数延拓到正实数。同时我们规定阶乘函数的起点值&lt;span class="math">\(f(x)|_{x=1}=1\)&lt;/span>，这二者共同保证了在所有正整数点的函数值与整数的阶乘值一致。综上总结出以下两个要求：&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>&lt;span class="math">\(f(1)=1\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\(f(x+1)=xf(x),\forall x\in R^+\)&lt;/span>&lt;/li>
&lt;/ol>
&lt;p>毫无疑问，&lt;span class="math">\(\Gamma(x)\)&lt;/span>是满足上述两个条件的，但问题是满足上述两个条件的函数也是无穷多个，这里我们给出一个典型的构造方法。&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>我们将数轴正半轴以1为单位划分成段，构造分段函数&lt;span class="math">\(g_0(x),x\in(0,1];g_1(x),x\in(1,2];g_2(x),x\in(2,3];\dotsb;g_n(x),x\in (n,n+1];\dotsb\)&lt;/span>&lt;/li>
&lt;li>在区间&lt;span class="math">\([1,2]\)&lt;/span>内任意找出一个连续函数&lt;span class="math">\(g_1\)&lt;/span>，使得&lt;span class="math">\(g_1(1)=g_1(2)=1\)&lt;/span>。因为根据条件1和2，&lt;span class="math">\(f(1)=1,f(2)=1\times f(1)=1\)&lt;/span>。&lt;/li>
&lt;li>根据条件2的递推关系，当&lt;span class="math">\(x\in (0,1]\)&lt;/span>，有&lt;span class="math">\(x\times g_0(x)=g_1(x)\Rightarrow g_0(x)=\frac{g_1(x)}{x}\)&lt;/span>。&lt;/li>
&lt;li>根据条件2的递推关系，当&lt;span class="math">\(x\in (n,n+1],n&amp;gt;1\)&lt;/span>时，有&lt;span class="math">\(g_n(x)=g_1(x)\prod_{k=1}^{n-1}(x-k)\)&lt;/span>&lt;/li>
&lt;li>将函数段&lt;span class="math">\(g_0,g_1,g_2,\dotsb\)&lt;/span>，组合起来，即构造为伪&lt;span class="math">\(\Gamma\)&lt;/span>函数同时满足条件1，2。&lt;/li>
&lt;/ol>
&lt;p>举个例子，令&lt;span class="math">\(g_1(x)=1\)&lt;/span>，其构造的函数分别为： &lt;span class="math">\[
\begin{aligned}
&amp;amp;g_0(x)=1/x,\qquad 0&amp;lt;x\le 1;\\
&amp;amp;g_1(x)=1,\qquad 1&amp;lt;x\le 2;\\
&amp;amp;g_2(x)=x-1,\qquad 2&amp;lt;x\le 3;\\
&amp;amp;g_3(x)=(x-1)(x-2),\qquad 3&amp;lt;x\le 4;\\
&amp;amp;g_4(x)=(x-1)(x-2)(x-3),\qquad 4&amp;lt;x\le 5;\\
&amp;amp;\qquad \vdots
\end{aligned}\tag{34}
\]&lt;/span> 函数图像为： &lt;img src="../../images/伪gamma函数1.png" alt="伪gamma函数1.png" />&lt;/p>
&lt;p>有些人觉得分段函数在每段连接处是生硬地转折，不可微，看上去不够自然。那么加上&lt;strong>可微这个条件&lt;/strong>，&lt;span class="math">\(\Gamma\)&lt;/span>函数是否就是唯一解呢？依旧不是。我们可以利用&lt;span class="math">\(\Gamma\)&lt;/span>函数构造出其他满足条件的例子，我们任意找一个解析并且周期为1的周期函数&lt;span class="math">\(p(x)\)&lt;/span>，同时确保&lt;span class="math">\(p(1)=1\)&lt;/span>，比如&lt;span class="math">\(p(x)=1+\sin(2\pi x)\)&lt;/span>，那么函数 &lt;span class="math">\[g(x)=\Gamma(x)p(x)\tag{35}\]&lt;/span> 就是一个符合上述三个要求的函数，其函数图像如下：&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/可微的伪Gamma函数.png" alt="可微的伪Gamma函数.png" />&lt;p class="caption">可微的伪Gamma函数.png&lt;/p>
&lt;/div>
&lt;p>既然，这样都不是充分条件，那么我们还要如何加强这个问题，使得&lt;span class="math">\(\Gamma\)&lt;/span>函数成为唯一解呢？在19世纪中叶，数学家们确实给出了能让&lt;span class="math">\(\Gamma\)&lt;/span>函数作为唯一满足条件的连续函数。&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>&lt;span class="math">\(\Gamma(1)=1\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\(\Gamma(x+1)=x\Gamma(x),\forall x\in R^+\)&lt;/span>&lt;/li>
&lt;li>满足反射公式：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;span class="math">\[\Gamma(z)\Gamma(1-z)=\frac{\pi}{\sin(\pi z)}\tag{35}\]&lt;/span>&lt;/li>
&lt;/ul>
&lt;ol start="4" style="list-style-type: decimal">
&lt;li>满足乘法公式：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;span class="math">\[\Gamma(nz)=(2\pi)^{\frac{1-n}{2}}n^{nz-\frac{1}{2}}\Gamma(z)\Gamma(z+\frac{1}{n})\Gamma(z+\frac{2 }{n})\dotsb\Gamma(z+\frac{n-1}{n})\tag{36}\]&lt;/span>&lt;/li>
&lt;/ul>
&lt;p>不过新加的两个条件很难说是“符合直觉的”，它们太复杂，而且与其说是条件，倒不如说是&lt;span class="math">\(\Gamma(x)\)&lt;/span>函数所特有的性质，有点先射箭，再画靶的嫌疑。&lt;/p>
&lt;p>传统的数学分析领域似乎已经无法为我们提供更多帮助了。很多时候，代数和分析是相辅相成的，在康托尔发展了集合论以及拓扑学的完善之后，在20世纪之交，一个很“视觉”的概念，“凸函数”被提出来。&lt;/p>
&lt;blockquote>
&lt;p>&lt;span class="math">\(f\)&lt;/span>称为凸函数，意思是对&lt;span class="math">\(0\leq t\leq 1\)&lt;/span>及任意&lt;span class="math">\(x_{1},x_{2}\in C\)&lt;/span>，皆有 &lt;span class="math">\[f\left(tx_{1}+(1-t)x_{2}\right)\leq tf\left(x_{1}\right)+(1-t)f\left(x_{2}\right)\tag{37}\]&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>在代数上的描述并不直观，但是从几何上来说，凸函数就是函数上任意两点的连续都在函数上方，如下图：&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/凸函数定义.png" alt="凸函数定义.png" />&lt;p class="caption">凸函数定义.png&lt;/p>
&lt;/div>
&lt;p>凸函数不像三角函数&lt;span class="math">\(\sin,\cos\)&lt;/span>那样上下波动，形状相对固定，在研究中有非常方便的性质，比如局部最优就是全局最优，二阶导非负（多元情况下就是Hessian矩阵半正定），这些方便的性质迅速让凸函数在均值理论、拓扑学、博弈论、线性规划中得到了广泛应用，为此还发展出了专门的一个方向：凸优化。因此，如果研究者发现需要研究的函数是“凸”的，那么他会大松一口气，很多问题就能够轻易的解决。&lt;/p>
&lt;p>而欧拉给出的&lt;span class="math">\(\Gamma(x)\)&lt;/span>函数恰好在正实数范围内是“凸”的，同时在负数部分的每一小段也都是“凸”的，我们从&lt;span class="math">\(\Gamma\)&lt;/span>函数的图像中很容易看出这一点。而Hadamard延拓出的函数式(33)和我们构造的解析的伪&lt;span class="math">\(\Gamma\)&lt;/span>函数&lt;span class="math">\(g(x)=\Gamma(x)p(x)\)&lt;/span>（式(35)）显然不满足“凸”这个性质。那么，很多数学家自然而然的想到，&lt;span class="math">\(\Gamma\)&lt;/span>函数是不是唯一满足条件1，2的凸函数呢？&lt;/p>
&lt;p>答案显然也不是，其实我们在前面已经给出了反例，就是前面构造出来的分段函数式(34)。虽然它是一段段曲线拼接起来的，且在拼接处不解析，但它是货真价实的凸函数。&lt;/p>
&lt;p>不过，抓到“凸”这个特性，我们离真正的答案也就不远了。&lt;/p>
&lt;p>在1922年，丹麦数学家Harald Bohr和Johannes Mollerup发现，&lt;span class="math">\(\Gamma(x)\)&lt;/span>函数不仅仅是凸的，而且&lt;span class="math">\(\log\Gamma(x)\)&lt;/span>也是凸函数，即&lt;strong>对数凸函数&lt;/strong>！对数凸函数是一个比凸函数更强的条件，对数凸函数必然是凸函数，由于对数函数会大幅降低函数成长的速率，因此若取对数后仍为凸函数，表示函数上升的速度比凸函数还快，因此会称为超凸函数。两位数学家证明：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Bohr–Mollerup定理&lt;/strong>：在&lt;span class="math">\(x&amp;gt;0\)&lt;/span>的区间上，&lt;span class="math">\(Γ\)&lt;/span>函数 &lt;span class="math">\[\Gamma(x)=\int_0^\infty t^{x-1}e^{-t}\mathrm{d}t \tag{2.1}\]&lt;/span> 是&lt;strong>唯一&lt;/strong>同时满足以下3条性质的函数 f ：&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>&lt;span class="math">\(f(1)=1\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\(f(x+1)=xf(x),\forall x\in R^+\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math">\(f\)&lt;/span>是对数凸函数。&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>这个定理最早是出现在一本复分析教科书中，并且证明过程并不复杂，以至于当时Bohr和Mollerup都以为这是一个人们肯定已经知道的结果。不过这个定理确实是第一个给出了阶乘函数的解析延拓在何种情形下一定是&lt;span class="math">\(Γ\)&lt;/span>函数的简明充要条件。后来，数学家Emil Artin简化了定理的证明，因此这个定理也被称为“Bohr–Mollerup-Artin定理”。&lt;/p>
&lt;p>这个定理让数学家非常满意，让&lt;span class="math">\(\Gamma\)&lt;/span>函数充满了优雅与简洁的独特美学，甚至让追求严格性著称的尼古拉·布尔巴基合作者协会都以此作为阐述&lt;span class="math">\(\Gamma\)&lt;/span>函数的切入点。&lt;/p>
&lt;h3 id="不完全gamma函数与不完全beta函数">不完全Gamma函数与不完全Beta函数&lt;/h3>
&lt;p>不完全&lt;span class="math">\(Γ\)&lt;/span>、&lt;span class="math">\(\Beta\)&lt;/span>函数是&lt;span class="math">\(Γ\)&lt;/span>函数与&lt;span class="math">\(\Beta\)&lt;/span>函数的不定积分形式。这里不打算介绍太多，只介绍基本思想。由于两类欧拉积分都是定积分，在给出参数后就是固定值，后来数学家为了将它们推广到不定积分，就分别给出了不完全&lt;span class="math">\(Γ\)&lt;/span>函数与不完全&lt;span class="math">\(\Beta\)&lt;/span>函数。&lt;/p>
&lt;p>&lt;span class="math">\(Γ\)&lt;/span>函数式(2.1)，根据将上限变成不定积分和下限变成不定积分又分成上不完全&lt;span class="math">\(Γ\)&lt;/span>函数和下不完全&lt;span class="math">\(Γ\)&lt;/span>函数，其解析表达式如下：&lt;/p>
&lt;p>上不完全&lt;span class="math">\(Γ\)&lt;/span>函数： &lt;span class="math">\[\Gamma(s,x) = \int_x^{\infty} t^{s-1}\,e^{-t}\,{\rm d}t\quad \Re(s)&amp;gt;0, x\in\mathbb R_0^+\tag{38}\]&lt;/span> 当&lt;span class="math">\(x=0\)&lt;/span>时，上不完全&lt;span class="math">\(Γ\)&lt;/span>函数就是&lt;span class="math">\(Γ\)&lt;/span>函数&lt;span class="math">\(\Gamma(s,0)=\Gamma(s)\)&lt;/span>。&lt;/p>
&lt;p>下不完全&lt;span class="math">\(Γ\)&lt;/span>函数： &lt;span class="math">\[\gamma(s,x) = \int_0^x t^{s-1}\,e^{-t}\,{\rm d}t \quad \Re(s)&amp;gt;0, x\in\mathbb R_0^+\tag{39}\]&lt;/span>&lt;/p>
&lt;p>不完全&lt;span class="math">\(\Beta\)&lt;/span>函数是&lt;span class="math">\(\Beta\)&lt;/span>函数的一个推广，把&lt;span class="math">\(\Beta\)&lt;/span>函数中的定积分用不定积分来代替，需要指出的是不同于不完全&lt;span class="math">\(\Gamma\)&lt;/span>函数，不完全&lt;span class="math">\(\Beta\)&lt;/span>函数只会将上限改为不定积分。&lt;/p>
&lt;p>不完全&lt;span class="math">\(\Beta\)&lt;/span>函数： &lt;span class="math">\[
\Beta(x;\,a,b)=\int _{0}^{x}t^{{a-1}}\,(1-t)^{{b-1}}\,dt \quad x\in [0,1],a&amp;gt;0,b&amp;gt;0\tag{40}
\]&lt;/span> 当&lt;span class="math">\(x = 1\)&lt;/span>，上式即化为&lt;span class="math">\(\Beta\)&lt;/span>函数。&lt;/p>
&lt;h2 id="两类欧拉积分在概率论中的应用">两类欧拉积分在概率论中的应用&lt;/h2>
&lt;p>第二类欧拉积分在概率统计中频繁现身，众多的高阶统计分布，包括常见的统计学三大分布 (&lt;span class="math">\(t\)&lt;/span>分布，&lt;span class="math">\(χ^2\)&lt;/span>分布，&lt;span class="math">\(F\)&lt;/span>分布)、&lt;span class="math">\(\Beta\)&lt;/span>分布、狄利克雷分布的密度公式中都有&lt;span class="math">\(\Gamma\)&lt;/span>函数的身影。而第一类欧拉积分则和二项分布、伯努利分布有着密切关系，常作为贝叶斯统计中的先验分布。&lt;/p>
&lt;h3 id="gamma分布">Gamma分布&lt;/h3>
&lt;p>Gamma分布概率密度函数： &lt;span class="math">\[
p_{_\Gamma}(x|\alpha)=\frac{x^{\alpha-1}e^{-x}}{\Gamma(\alpha)}\tag{41}
\]&lt;/span>&lt;/p>
&lt;p>与&lt;span class="math">\(\Gamma\)&lt;/span>函数有最直接联系的概率分布当然是直接由&lt;span class="math">\(\Gamma\)&lt;/span>函数变换得到的&lt;span class="math">\(\Gamma\)&lt;/span>分布，实际上&lt;span class="math">\(\Gamma\)&lt;/span>分布就是借&lt;span class="math">\(\Gamma\)&lt;/span>函数作为归一化分母而得到的概率分布。如果做一个变换&lt;span class="math">\(x = βt\)&lt;/span>，就得到伽玛分布的更一般的形式 &lt;span class="math">\[
p_{_\Gamma}(t|\alpha,\beta)=\frac{\beta^{\alpha
}t^{\alpha-1}e^{-\beta t}}{\Gamma(\alpha)}\tag{42}
\]&lt;/span> &lt;span class="math">\(α\)&lt;/span>称为 shape parameter，主要决定了分布曲线的形状；&lt;span class="math">\(β\)&lt;/span>称为rate parameter，主要决定曲线有多陡。&lt;span class="math">\(θ=1/β\)&lt;/span>称为scale parameter，同样决定曲线有多陡。&lt;/p>
&lt;p>固定&lt;span class="math">\(α=4\)&lt;/span>,随着&lt;span class="math">\(β\)&lt;/span>（或&lt;span class="math">\(θ=1/β\)&lt;/span>）参数的增加，x轴的scale在减小，其分布相对就越窄。若放在同一个x轴上， 增加&lt;span class="math">\(β\)&lt;/span>将得到更陡的曲线 （相应地，y轴的scale增加）。&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/gamma分布rate参数.gif" alt="gamma分布rate参数.gif" />&lt;p class="caption">gamma分布rate参数.gif&lt;/p>
&lt;/div>
&lt;p>固定&lt;span class="math">\(β=1\)&lt;/span>，&lt;span class="math">\(α\)&lt;/span>改变，曲线的形态发生改变。&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/gamma分布shape参数.gif" alt="gamma分布shape参数.gif" />&lt;p class="caption">gamma分布shape参数.gif&lt;/p>
&lt;/div>
&lt;p>在这个形式下，Gamma分布期望&lt;span class="math">\(E(T)=\frac{\alpha}{\beta}\)&lt;/span>，方差&lt;span class="math">\(Var(T)=\frac{\alpha}{\beta^2}\)&lt;/span>。&lt;/p>
&lt;h3 id="beta分布">Beta分布&lt;/h3>
&lt;p>Beta分布概率密度函数： &lt;span class="math">\[
p_{B}=\frac{x^{\alpha-1}(1-x)^{\beta-1}} {\Beta(\alpha,\beta)}\!\tag{43}
\]&lt;/span> 其中，参数&lt;span class="math">\(\alpha,\beta&amp;gt;0\)&lt;/span>，定义域&lt;span class="math">\(x\in(0,1)\)&lt;/span>,分母&lt;span class="math">\(\Beta(\alpha,\beta)\)&lt;/span>为Beta函数。&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/Beta_distribution.png" alt="Beta_distribution.png" />&lt;p class="caption">Beta_distribution.png&lt;/p>
&lt;/div>
&lt;p>期望值和方差分别是：&lt;span class="math">\(\mu =\operatorname {E}(X)={\frac{\alpha }{\alpha +\beta }}\)&lt;/span>，&lt;span class="math">\(\operatorname {Var}(X)=\operatorname {E}(X-\mu )^{2}={\frac {\alpha \beta }{(\alpha +\beta )^{2}(\alpha +\beta +1)}}\)&lt;/span>。&lt;/p>
&lt;h3 id="gamma分布与一些常见分布的联系">Gamma分布与一些常见分布的联系&lt;/h3>
&lt;p>为了理解Gamma分布的广泛一般性，我们从分布的&lt;strong>可加性&lt;/strong>入手，从最简单的分布开始逐渐深入到Gamma分布。&lt;/p>
&lt;p>回想我们在研究最基础的伯努利分布时，将N个伯努利分布叠加后，形成了二项分布&lt;span class="math">\(B(N,p)\)&lt;/span>，换句话说二项分布就是独立同分布(i.i.d)的伯努利分布加出来的，因此多几个伯努力分布相加还是二项分布，只是二项分布的参数有所改变。这是二项分布可加性的来源。而泊松分布是二项分布在&lt;span class="math">\(\lambda=np\)&lt;/span>为定值时, &lt;span class="math">\(p\rightarrow 0, n\rightarrow\infty\)&lt;/span>的极限，因此本质也是一种二项分布，不难理解为什么泊松分布也有可加性了。此外，作为二项分布&lt;span class="math">\(n\rightarrow \infty\)&lt;/span>的极限的正态分布，自然也是有可加性的，但是这已经拓展到连续分布了。（&lt;span class="math">\(e\)&lt;/span>是联系离散和连续的桥梁之一，这也是从离散的二项分布到正态分布表达式突然多出自然常数的一个暗示）。而其它具有可加性的离散分布，比如负二项分布是由N个独立同分布的几何分布加出来的，带有可加性也算是自然而然了。&lt;/p>
&lt;p>在连续分布中，也有一些分布是“加”出来的。最常见、应用最广泛的是&lt;strong>指数分布&lt;span class="math">\(X\thicksim \exp(\lambda)\)&lt;/span>的和&lt;/strong>，k个指数分布&lt;span class="math">\(X_i\thicksim \exp(\lambda),i\in\{1,2,\dotsb,k\}\)&lt;/span>相加是Erlang分布 &lt;span class="math">\[
X_{i}\sim \exp (\lambda ),\\
\sum_{i=1}^{k}{X_{i}}\sim \operatorname {Erlang} (k,\lambda )\Rightarrow p(x;k,\lambda )=\sum_{i=1}^{k}{X_{i}}\sim \operatorname {Erlang} (k,\lambda )\\
p(x;k,\lambda )={\lambda ^{k}x^{{k-1}}e^{{-\lambda x}} \over (k-1)!}\quad {\text{for }}x,\lambda \geq 0,k\geq 1\tag{44}
\]&lt;/span> 它和指数分布的参数&lt;span class="math">\(\lambda\)&lt;/span>是一样的，参数&lt;span class="math">\(k\)&lt;/span>是指由&lt;span class="math">\(k\)&lt;/span>个指数分布相加。其实际含义可以指代&lt;span class="math">\(k\)&lt;/span>个用户/物件到达所用的时间间隔等。显然，有指数分布加出来的Erlang分布也有可加性，无非就是多几个指数分布的和。而将&lt;span class="math">\(k\rightarrow \alpha\)&lt;/span>延拓到正实数域，就是Gamma分布&lt;span class="math">\(X\sim \Gamma(\alpha,\lambda)\)&lt;/span>。 &lt;span class="math">\[p(x;\alpha ,\lambda )={\frac {\lambda ^{\alpha }x^{\alpha -1}e^{-\lambda x}}{\Gamma (\alpha )}}\quad {\text{for }}x&amp;gt;0\quad \alpha ,\lambda &amp;gt;0\tag{45}\]&lt;/span> 其中,&lt;span class="math">\(\Gamma(\alpha)\)&lt;/span>是Gamma函数而卡方分布又是Gamma分布的特例，即&lt;span class="math">\(X\sim \chi^2(n)=\Gamma(\frac{n}{2},\frac{1}{2})\)&lt;/span>， &lt;span class="math">\[
p(x;n)={\frac {1}{2^{\frac {n}{2}}\Gamma(\frac{n}{2})}}x^{\frac {n}{2}-1}e^{\frac {-x}{2}}\tag{46}
\]&lt;/span> 因此这两种分布(Gamma分布、卡方分布)也不出意外的有可加性。实际上，这些分布都可以看成是Gamma分布在某种情况下的特例，&lt;strong>虽然说历史进程上是从常见分布到Gamma分布，但是Gamma分布确是其他常见分布的根本&lt;/strong>。&lt;/p>
&lt;p>Gamma分布的可加性的直接证明一般有两种思路，一是使用两个独立随机变量和的概率密度函数等于其概率密度函数的卷积；二是使用特征函数，独立随机变量的和等于特征函数的积。假设两个独立的服从Gamma分布的随机变量&lt;span class="math">\(X\sim p_{_X}(x;\alpha_1,\lambda),Y\sim p_{_Y}(x;\alpha_2,\lambda)\)&lt;/span>，现需证明&lt;span class="math">\(Z=X+Y\sim \Gamma(\alpha_1+\alpha_2,\lambda)\)&lt;/span>。&lt;/p>
&lt;p>&lt;strong>证明方法1&lt;/strong>：独立随机变量和等于概率密度函数卷积。由独立随机变量和的关系可知: &lt;span class="math">\[
\begin{aligned}
p_{_Z}(x)&amp;amp;=p_{_X}(x)*p_{_Y}(x)\\
&amp;amp;=\int_{-\infty}^{+\infty} p_{_X}(x-\tau)p_{_Y}(\tau)\mathrm{d}\tau
\end{aligned}\tag{47}
\]&lt;/span> 由于Gamma分布的概率密度函数在负数区域都为0，即&lt;span class="math">\(\tau\leq 0\)&lt;/span>时，&lt;span class="math">\(p_{_Y}(\tau)=0\)&lt;/span>，因此积分限 可以简化为&lt;span class="math">\((0,\infty)\)&lt;/span>，式（47）带入具体表达式有： &lt;span class="math">\[
\begin{aligned}
p_{_Z}(x)&amp;amp;=\int_{-\infty}^{+\infty} p_{_X}(x-\tau)p_{_Y}(\tau)\mathrm{d}\tau\\
&amp;amp;= \int_{0}^{+\infty} {\frac {\lambda ^{\alpha_1}(x-\tau)^{\alpha_1-1}e^{-\lambda (x-\tau)}}{\Gamma (\alpha_1)}}\times{\frac {\lambda ^{\alpha_2}\tau^{\alpha_2-1}e^{-\lambda\tau}}{\Gamma (\alpha_2)}}\mathrm{d}\tau\\
&amp;amp;=\frac{\lambda^{\alpha_1+\alpha_2}}{\Gamma(\alpha_1)\Gamma(\alpha_2)}e^{-\lambda x}\int_{0}^{+\infty}(x-\tau)^{\alpha_1-1}\tau^{\alpha_2-1}\mathrm{d}\tau\\
&amp;amp;\overset{提取x}{=}\frac{\lambda^{\alpha_1+\alpha_2}}{\Gamma(\alpha_1)\Gamma(\alpha_2)}e^{-\lambda x}x^{\alpha_1+\alpha_2-2}\int_{0}^{+\infty}(1-\frac{\tau}{x})^{\alpha_1-1}(\frac{\tau}{x})^{\alpha_2-1}\mathrm{d}\tau\\
\end{aligned}
\tag{48}
\]&lt;/span> 我们令&lt;span class="math">\(\tau/x=t\)&lt;/span>，则有&lt;span class="math">\(\mathrm{d}\tau=x\mathrm{d}t\)&lt;/span>。同时由于&lt;span class="math">\(x&amp;gt;\tau&amp;gt;0\)&lt;/span>，所以&lt;span class="math">\(t=\frac{\tau}{x}\in(0,1)\)&lt;/span>。式（48）可写为 &lt;span class="math">\[
\begin{aligned}
p_{_Z}(x)&amp;amp;=\frac{\lambda^{\alpha_1+\alpha_2}}{\Gamma(\alpha_1)\Gamma(\alpha_2)}e^{-\lambda x}x^{\alpha_1+\alpha_2-2}\int_{0}^{+\infty}(1-t)^{\alpha_1-1}t^{\alpha_2-1}x\mathrm{d}t\\
&amp;amp;=\frac{\lambda^{\alpha_1+\alpha_2}}{\Gamma(\alpha_1)\Gamma(\alpha_2)}e^{-\lambda x}x^{\alpha_1+\alpha_2-1}\Beta(\alpha_1,\alpha_2)\\
&amp;amp;=\frac{\lambda^{\alpha_1+\alpha_2}x^{\alpha_1+\alpha_2-1}e^{-\lambda x}}{\Gamma(\alpha_1+\alpha_2)}=p(x;\alpha_1+\alpha_2,\lambda)
\end{aligned}\tag{49}
\]&lt;/span> 即服从&lt;span class="math">\(p_{_\Gamma}(x|\alpha_1+\alpha_2,\lambda)\)&lt;/span>，得证。&lt;/p>
&lt;p>&lt;strong>证明方法2&lt;/strong>：使用特征函数。可知Gamma分布的特征函数为&lt;span class="math">\(\phi_{_\Gamma}(t)=(1-it/\beta)^{-\alpha}\)&lt;/span>，特征函数有一个性质：&lt;/p>
&lt;blockquote>
&lt;p>若 &lt;span class="math">\(X_1,\ldots,X_n\)&lt;/span> 相互独立， &lt;span class="math">\(X_k\)&lt;/span> 特征函数为 &lt;span class="math">\(\phi_k(t)\)&lt;/span>，则 &lt;span class="math">\(Y=X_1+\cdots+X_n\)&lt;/span> 的特征函数为 &lt;span class="math">\(\phi_Y(t)=\phi_1(t)\cdots\phi_{k}(t)\)&lt;/span>。&lt;/p>
&lt;/blockquote>
&lt;p>那么&lt;span class="math">\(X+Y\)&lt;/span>的特征函数应为&lt;span class="math">\(\phi_{_{X+Y}}(t)=(1-it/\lambda)^{-\alpha_1}(1-it/\lambda)^{-\alpha_2}=(1-it/\lambda)^{-(\alpha_1+\alpha_2)}\)&lt;/span>。再由特征函数的反演唯一性可得&lt;span class="math">\((1-it/\lambda)^{-(\alpha_1+\alpha_2)}\)&lt;/span>对应的概率密度函数为&lt;span class="math">\(p_{_\Gamma}(x|\alpha_1+\alpha_2,\lambda)\)&lt;/span>，得证。&lt;/p>
&lt;h2 id="附gamma函数beta函数关系以及其他函数">附：Gamma函数、Beta函数关系以及其他函数&lt;/h2>
&lt;h3 id="gamma函数与beta函数关系推导">Gamma函数与Beta函数关系推导&lt;/h3>
&lt;p>从文章开头的式(1)我们就给出了&lt;span class="math">\(\Gamma\)&lt;/span>函数和&lt;span class="math">\(\Beta\)&lt;/span>函数二者的关系，其具体推导过程如下： &lt;span class="math">\[
\begin{aligned}
\Gamma(x) \Gamma(y) &amp;amp;= \int_0^{+\infty} e^{-t} t^{x-1} \mathrm{d}t \int_0^{+\infty} e^{-s} s^{y-1} \mathrm{d}s \\
&amp;amp; = \int_0^{+\infty} \int_0^{+\infty} e^{-(s+t)} t^{x-1} s^{y-1} \mathrm{d}s \mathrm{d}t \\
&amp;amp;=4 \int_0^{+\infty} \int_0^{+\infty} e^{-(u^2+v^2)} u^{2x-2} v^{2y-2} \cdot uv \mathrm{d}u \mathrm{d}v \quad (t=u^2,s=v^2)\\
&amp;amp;= 4 \int_0^{+\infty} \int_0^{+\infty} e^{-(u^2+v^2)} u^{2x-1} v^{2y-1} \mathrm{d}u \mathrm{d}v \\
&amp;amp;= \int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} e^{-(u^2+v^2)} |u|^{2x-1}|v|^{2y-1} \mathrm{d}u \mathrm{d}v \\
&amp;amp;= \int_0^{+\infty} \int_0^{2\pi} r e^{-r^2} r^{2x-1} |\cos \theta|^{2x-1} r^{2y-1} |\sin \theta|^{2y-1} \mathrm{d}r \mathrm{d}\theta \quad (u=r\cos \theta,v=r\sin \theta) \\
&amp;amp;= \int_0^{+\infty} r e^{-r^2} r^{2x+2y-2} \mathrm{d}r \int_0^{2\pi} |\cos \theta|^{2x-1} |\sin \theta|^{2y-1} \mathrm{d} \theta \\
&amp;amp;= \frac{1}{2} \int_0^{+\infty} e^{-r^2} r^{2(x+y-1)} \mathrm{d}r^2 \int_0^{2\pi} |\cos \theta|^{2x-1} |\sin \theta|^{2y-1} \mathrm{d} \theta \\
&amp;amp;= \frac{1}{2} \Gamma(x+y) \int_0^{2\pi} |\cos \theta|^{2x-1} |\sin \theta|^{2y-1} \mathrm{d} \theta \\
&amp;amp;= \Gamma(x+y) \cdot 2\int_0^{\frac{\pi}{2}} \cos^{2x-1} \theta \sin^{2y-1} \theta \mathrm{d} \theta \\
&amp;amp;= \Gamma(x+y) \cdot 2 \int_0^1 t^{x-\frac{1}{2}} (1-t)^{y-\frac{1}{2}} \frac{1}{2} t^{-\frac{1}{2}} (1-t)^{-\frac{1}{2}} \mathrm{d}t \quad (t=\cos^2 \theta,\sin \theta =(1-t)^\frac{1}{2}, \mathrm{d}t = -2 t^{\frac{1}{2}} (1-t)^{\frac{1}{2}} \mathrm{d} \theta) \\
&amp;amp;= \Gamma(x+y) \int_0^1 t^{x-1} (1-t)^{y-1} \mathrm{d}t \\
&amp;amp;= \Gamma(x+y) \Beta (x,y).\\
&amp;amp;\Rightarrow \Beta(x,y)=\frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
\end{aligned}\tag{A1}
\]&lt;/span>&lt;/p>
&lt;h3 id="gamma函数与psi函数">Gamma函数与Psi函数&lt;/h3>
&lt;p>&lt;span class="math">\(\psi\)&lt;/span>函数又称双伽玛函数，是伽玛函数的对数导数，即 &lt;span class="math">\[
\psi (x)={\frac {d}{dx}}\ln {\Gamma (x)}={\frac {\Gamma &amp;#39;(x)}{\Gamma (x)}}\tag{A2}
\]&lt;/span> 由&lt;span class="math">\(\psi\)&lt;/span>函数可以推导出Stirling级数。&lt;/p>
&lt;h3 id="gamma函数与zeta函数">Gamma函数与zeta函数&lt;/h3>
&lt;p>黎曼泽塔函数，写作&lt;span class="math">\(ζ(z)\)&lt;/span>的定义如下：设一复数&lt;span class="math">\(z\)&lt;/span>使得&lt;span class="math">\(Re(z)&amp;gt;1\)&lt;/span>，则定义： &lt;span class="math">\[
\zeta(z)=\sum_{n=1}^\infty \frac{1}{n^z}\tag{A3}
\]&lt;/span> 它亦可以用积分定义： &lt;span class="math">\[
\zeta(z)=\frac{1}{\Gamma(z)}\int_{0}^{\infty} \frac{x^ {z-1}}{e^x-1} \mathrm{d}x\tag{A4}
\]&lt;/span> 黎曼的&lt;span class="math">\(ζ\)&lt;/span>函数被数学家认为主要和“最纯”的数学领域数论相关，黎曼函数最著名的就是黎曼猜想：&lt;/p>
&lt;blockquote>
&lt;p>黎曼猜想：黎曼&lt;span class="math">\(ζ\)&lt;/span>函数的非平凡零点（在此情况下是指&lt;span class="math">\(z\)&lt;/span>不为-2，-4，-6，...，等点的值）的实数部分是&lt;span class="math">\(\frac{1}{2}\)&lt;/span>。&lt;/p>
&lt;/blockquote>
&lt;p>而&lt;span class="math">\(\Gamma\)&lt;/span>函数与&lt;span class="math">\(ζ\)&lt;/span>函数有如下关系： &lt;span class="math">\[
\pi ^{-{\frac {z}{2}}}\;\Gamma \left({\frac {z}{2}}\right)\zeta (z)=\pi ^{-{\frac {1-z}{2}}}\;\Gamma \left({\frac {1-z}{2}}\right)\;\zeta (1-z)\tag{A5}
\]&lt;/span>&lt;/p></description></item><item><title>数学分析之投影内积和傅里叶级数</title><link>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E5%86%85%E7%A7%AF%E5%92%8C%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0/</link><pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E5%86%85%E7%A7%AF%E5%92%8C%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0/</guid><description>
&lt;h2 id="数学分析之投影内积和傅里叶级数">数学分析之投影内积和傅里叶级数&lt;!-- omit in toc -->&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="#内积点积传统定义">内积（点积）传统定义&lt;/a>&lt;/li>
&lt;li>&lt;a href="#性质">性质&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#基本运算规则">基本运算规则&lt;/a>&lt;/li>
&lt;li>&lt;a href="#空间关系">空间关系&lt;/a>&lt;/li>
&lt;li>&lt;a href="#内积与投影">内积与投影&lt;/a>&lt;/li>
&lt;/ul>&lt;/li>
&lt;li>&lt;a href="#内积的推广">内积的推广&lt;/a>&lt;/li>
&lt;li>&lt;a href="#复数的内积">复数的内积&lt;/a>&lt;/li>
&lt;li>&lt;a href="#矩阵的内积">矩阵的内积&lt;/a>&lt;/li>
&lt;li>&lt;a href="#函数的内积">函数的内积&lt;/a>&lt;/li>
&lt;li>&lt;a href="#从内积角度理解傅里叶级数">从内积角度理解傅里叶级数&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>点积是线性代数、矩阵论中常用的概念，我们最开始学习的点积就是向量空间中的点积，但是内积在其他领域比如复数、矩阵、函数中也是有定义的，本笔记将介绍内积及其拓展。&lt;/p>
&lt;h2 id="内积点积传统定义">内积（点积）传统定义&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>点积（Dot Product）又称数量积或标量积&lt;/strong>，是一种接受两个等长的数字序列（通常是坐标向量）、返回单个数字的代数运算。&lt;/p>
&lt;/blockquote>
&lt;p>在欧几里得几何中，两个笛卡尔坐标向量的点积常称为内积。点积的名称源自表示点乘运算的点号（&lt;span class="math">\(a\cdot b\)&lt;/span>），读作&lt;span class="math">\(a\ dot\ b\)&lt;/span>，标量积的叫法则是在强调其运算结果为标量而非向量。&lt;/p>
&lt;p>从代数角度看，先对两个数字序列中的&lt;strong>每组对应元素求积，再对所有积求和&lt;/strong>，结果即为点积。从几何角度看，点积则是&lt;strong>两个向量的长度与它们夹角余弦的积&lt;/strong>。这两种定义在笛卡尔坐标系中等价。&lt;/p>
&lt;p>代数角度，点积表示为： &lt;span class="math">\({\vec{a}}=[a_{1},a_{2},\cdots ,a_{n}]\)&lt;/span>和&lt;span class="math">\({\vec{b}}=[b_{1},b_{2},\cdots ,b_{n}]\)&lt;/span>的点积定义为： &lt;span class="math">\[
\vec{a}\cdot \vec{b} = \sum_{i=1}^n a_ib_i = a_1b_1 + a_2b_2 + \cdots + a_nb_n
\]&lt;/span> 点积还可以写为向量积的形式（注意这里的向量都是行向量，很多文章中默认向量是列向量）： &lt;span class="math">\[{\vec{a}}\cdot {\vec{b}}={\vec{a}}{\vec{b}}^{T}
\]&lt;/span> 几何角度，在欧几里得空间中，点积可以直观地定义为 &lt;span class="math">\[\vec{a} \cdot \vec{b} = |\vec{a}| \, |\vec{b}| \cos \theta \;\]&lt;/span> 这里&lt;span class="math">\(|\vec{x}|\)&lt;/span> 表示&lt;span class="math">\(\vec{x}\)&lt;/span>的模（长度），&lt;span class="math">\(\theta\)&lt;/span>表示两个向量之间的角度。&lt;/p>
&lt;h3 id="性质">性质&lt;/h3>
&lt;h4 id="基本运算规则">基本运算规则&lt;/h4>
&lt;ol style="list-style-type: decimal">
&lt;li>满足交换律。&lt;span class="math">\({\vec {a}}\cdot {\vec {b}}={\vec {b}}\cdot {\vec {a}}\)&lt;/span>&lt;/li>
&lt;li>对向量加法满足分配律。&lt;span class="math">\(\vec{a} \cdot (\vec{b} + \vec{c}) = \vec{a} \cdot \vec{b} + \vec{a} \cdot \vec{c}\)&lt;/span>&lt;/li>
&lt;li>点积是双线性算子。&lt;span class="math">\({\vec {a}}\cdot (r{\vec {b}}+{\vec {c}})=r({\vec {a}}\cdot {\vec {b}})+({\vec {a}}\cdot {\vec {c}})\)&lt;/span>&lt;/li>
&lt;li>在乘以标量时满足：&lt;span class="math">\((c_1\vec{a}) \cdot (c_2\vec{b}) = (c_1c_2) (\vec{a} \cdot \vec{b})\)&lt;/span>&lt;/li>
&lt;li>不满足结合律！不满足结合律！不满足结合律！&lt;/li>
&lt;li>正交性：两个非零向量&lt;span class="math">\(\vec{a}\)&lt;/span>和&lt;span class="math">\(\vec{b}\)&lt;/span>是正交的，当且仅当&lt;span class="math">\({\vec{a}}\cdot {\vec{b}}=0\)&lt;/span>&lt;/li>
&lt;/ol>
&lt;h4 id="空间关系">空间关系&lt;/h4>
&lt;ol style="list-style-type: decimal">
&lt;li>线性空间+点积=内积空间。&lt;/li>
&lt;li>内积空间必为线性赋范空间，但线性赋范空间不一定是内积空间，因为可以通过点积定义范数，但是单单范数无法引入角度概念，定义不了内积。&lt;/li>
&lt;li>内积空间+完备性=希尔伯特空间&lt;/li>
&lt;/ol>
&lt;h4 id="内积与投影">内积与投影&lt;/h4>
&lt;p>欧氏空间中向量&lt;span class="math">\(\vec A\)&lt;/span>在向量&lt;span class="math">\(\vec B\)&lt;/span>上的标量投影是指 &lt;span class="math">\[
\vec A_B=|\vec A|\cos\theta
\]&lt;/span> 这里&lt;span class="math">\(\theta\)&lt;/span>是&lt;span class="math">\(\vec A\)&lt;/span>和&lt;span class="math">\(\vec B\)&lt;/span>的夹角。从点积的几何定义&lt;span class="math">\(\vec A\cdot\vec B=|\vec{A}||\vec{B}|\cos\theta\)&lt;/span>不难得出，两个向量的点积：&lt;span class="math">\(\vec A\cdot\vec B\)&lt;/span>可以理解为向量&lt;span class="math">\(\vec A\)&lt;/span>在向量&lt;span class="math">\(\vec B\)&lt;/span>上的投影再乘以&lt;span class="math">\(\vec B\)&lt;/span>的长度。&lt;/p>
&lt;p>![内积与投影.gif(/images/内积与投影.gif)&lt;/p>
&lt;h2 id="内积的推广">内积的推广&lt;/h2>
&lt;p>传统的内积定义环境都是实数线性空间，如欧几里得空间，然而内积不仅仅可以定义在实数线性空间上，还可以定义在其他空间，同时满足已有的内积性质。&lt;/p>
&lt;h3 id="复数的内积">复数的内积&lt;/h3>
&lt;p>复数内积与实数内积的区别就是做二者乘法的时候需要加&lt;strong>共轭&lt;/strong>，如果不加共轭，内积的性质就会变得完全不一样： &lt;span class="math">\[
\vec{a} \cdot \vec{b} =\sum _{i}{{a_{i}}\,{\overline {b_{i}}}}
\]&lt;/span> 其中，&lt;span class="math">\({\overline {b_{i}}}\)&lt;/span>表示&lt;span class="math">\(b_i\)&lt;/span>的共轭。写出向量乘积形式为： &lt;span class="math">\[
\vec{a} \cdot \vec{b} =\vec{b} ^{\mathsf {H}}\vec{a}
\]&lt;/span> 相应的，两个复向量的夹角&lt;span class="math">\(\theta\)&lt;/span>也定义为： &lt;span class="math">\[
\cos \theta ={\frac {\operatorname {Re} (\vec{a} \cdot \vec{b} )}{\|\vec{a}\| \|\vec{b}\|}}.
\]&lt;/span>&lt;/p>
&lt;h3 id="矩阵的内积">矩阵的内积&lt;/h3>
&lt;p>矩阵具有弗罗比尼乌斯内积，可以类比于向量的内积。它被定义为两个相同大小的矩阵&lt;span class="math">\(\mathbf {A}\)&lt;/span>和&lt;span class="math">\(\mathbf {B}\)&lt;/span>的对应元素的内积之和。&lt;/p>
&lt;p>复矩阵情况下： &lt;span class="math">\[
\mathbf {A} :\mathbf {B} =\sum_{i}\sum_{j}A_{ij}{\overline {B_{ij}}}=\mathrm {tr} (\mathbf {B} ^{\mathrm {H} }\mathbf {A} )=\mathrm {tr} (\mathbf {A} \mathbf {B} ^{\mathrm {H} })
\]&lt;/span> 实矩阵情况下： &lt;span class="math">\[
\mathbf {A} :\mathbf {B} =\sum_{i}\sum_{j}A_{ij}B_{ij}=\mathrm {tr} (\mathbf {B} ^{\mathrm {T} }\mathbf {A} )=\mathrm {tr} (\mathbf {A} \mathbf {B} ^{\mathrm {T} })=\mathrm {tr} (\mathbf {A} ^{\mathrm {T} }\mathbf {B} )=\mathrm {tr} (\mathbf {B} \mathbf {A} ^{\mathrm {T} })
\]&lt;/span>&lt;/p>
&lt;h3 id="函数的内积">函数的内积&lt;/h3>
&lt;p>函数内积是离散维度往连续维度的延拓。内积的核心过程是&lt;strong>对应元素求积再累加&lt;/strong>。对于可积且平方可积（平方可积是为了&lt;span class="math">\(f(x)=g(x)\)&lt;/span>情形）函数例如&lt;span class="math">\(f(x),g(x)\)&lt;/span>而言，对应元素求积好办，只要二者相乘&lt;span class="math">\(f(x)g(x)\)&lt;/span>就行，离散场景的求和进入到连续场景就是&lt;strong>求积分&lt;/strong>，因此我们可以将函数的内积定义为： &lt;span class="math">\[
&amp;lt;f(x),g(x)&amp;gt;=\int f(x)g(x)\mathrm{d}x
\]&lt;/span> 然而，到这里还没有结束。我们在内积的时累加指的是所有维度的累加，而函数的所有维度是什么呢？是它的定义域&lt;span class="math">\(\mathbf{D}\)&lt;/span>，因此我们还要在上述积分中添加积分域： &lt;span class="math">\[
&amp;lt;f(x),g(x)&amp;gt;=\int_{\mathbf{D}} f(x)g(x)\mathrm{d}x
\]&lt;/span> 注意，这里要求两个函数必须可积且平方可积。容易验证，函数内积的定义也满足传统内积的性质。&lt;/p>
&lt;h2 id="从内积角度理解傅里叶级数">从内积角度理解傅里叶级数&lt;/h2>
&lt;p>我们在笔记&lt;a href="线性代数与矩阵之理解向量、线性变换与矩阵乘法.md">线性代数与矩阵之理解向量、线性变换与矩阵乘法&lt;/a>了解到，空间中任意向量都可以拆解成空间中一组基来表示，如果这组基是标准正交基是最好了。那么，自变量&lt;span class="math">\(x\)&lt;/span>所有函数组成的集合是不是也是一种空间呢？答案是肯定的。&lt;/p>
&lt;p>既然所有的函数组成了一个空间，那么我们是否也能找到一组标准正交基呢？傅里叶用傅里叶级数和傅里叶变换给我们答案。我们可以对任意函数做傅里叶展开，得到表达式： &lt;span class="math">\[
f(x)=a_0+a_1 \cos x+b_1\sin x+a_2 \cos 2x+b_2\sin 2x+\dotsb
\]&lt;/span> 与之前的有限个标准正交向量组成的正交矩阵不同，这个空间是无限维，它的一组基是&lt;span class="math">\(1，\cos x，\sin x，\cos 2x，\sin 2x\dotsb\)&lt;/span>。我们计算基的任意两个分量，可验证其正交性： &lt;span class="math">\[
\int_0^{2\pi}\sin mx\cos nx \mathrm{d}x=0(n\neq m)
\]&lt;/span> 我们知道，在基分量上的系数等于在其上的投影大小，因此采用和标准正交基相似的内积运算可以得到傅里叶变换的参数。我们以&lt;span class="math">\(a_1\)&lt;/span>为例： &lt;span class="math">\[
\begin{aligned}
&amp;lt;f(x),\cos x&amp;gt;&amp;amp;=\int_0^{2\pi} f(x) \cos x\mathrm{d}x\\
&amp;amp;=\int_0^{2\pi} (a_0+a_1 \cos x+b_1\sin x+a_2 \cos 2x+b_2\sin 2x+\dotsb) \cos x\\
&amp;amp;=0+\int_0^{2\pi} a_1 \cos^2 x\mathrm{d}x+0+0+\dotsb\\
&amp;amp;=a_1\pi
\end{aligned}
\]&lt;/span> 可以得到&lt;span class="math">\(a_1=\frac{1}{\pi}&amp;lt;f(x),\cos x&amp;gt;=\frac{1}{\pi}\int_0^{2\pi} f(x) \cos x\mathrm{d}x\)&lt;/span>，同理可以求得其它参数。我们这样就得到了一组傅里叶基下的函数表示形式。&lt;strong>也就是说傅里叶级数的系数是函数在&lt;span class="math">\(\cos nx\)&lt;/span>与&lt;span class="math">\(\sin nx\)&lt;/span>上的投影&lt;/strong>。&lt;/p>
&lt;p>当函数&lt;span class="math">\(f(x)\)&lt;/span>是周期函数时，我们可以采用最小周期与函数相同的三角函数作为基的开始，然后其他的基周期分别为函数周期的&lt;span class="math">\(1/2,1/3,\dotsb,1/n,\dotsb\)&lt;/span>。当函数从周期函数变成非周期函数时，我们可以当成是周期无穷的周期函数，此时三角函数的间隔就会趋于0，函数的基也从离散无穷变成连续无穷，即由傅里叶级数变成傅里叶编号。&lt;/p></description></item><item><title>数学分析之泰勒级数与高阶中值定理</title><link>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E6%B3%B0%E5%8B%92%E7%BA%A7%E6%95%B0%E4%B8%8E%E9%AB%98%E9%98%B6%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E6%B3%B0%E5%8B%92%E7%BA%A7%E6%95%B0%E4%B8%8E%E9%AB%98%E9%98%B6%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/</guid><description>
&lt;h2 id="泰勒级数与高阶中值定理">泰勒级数与高阶中值定理&lt;!-- omit in toc -->&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="#费马引理">费马引理&lt;/a>&lt;/li>
&lt;li>&lt;a href="#费马引理证明">费马引理证明&lt;/a>&lt;/li>
&lt;li>&lt;a href="#一阶微分中值定理">一阶微分中值定理&lt;/a>&lt;/li>
&lt;li>&lt;a href="#罗尔rolle中值定理">罗尔（Rolle）中值定理&lt;/a>&lt;/li>
&lt;li>&lt;a href="#拉格朗日langrange中值定理">拉格朗日（Langrange）中值定理&lt;/a>&lt;/li>
&lt;li>&lt;a href="#柯西cauchy中值定理">柯西（Cauchy）中值定理&lt;/a>&lt;/li>
&lt;li>&lt;a href="#泰勒中值定理">泰勒中值定理&lt;/a>&lt;/li>
&lt;li>&lt;a href="#泰勒中值定理的一阶展开">泰勒中值定理的一阶展开&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="费马引理">费马引理&lt;/h2>
&lt;p>设函数&lt;span class="math">\(f(x)\)&lt;/span>在点&lt;span class="math">\(x_0\)&lt;/span>的某邻域&lt;span class="math">\(U(x_0)\)&lt;/span>内有定义，并且在&lt;span class="math">\(x_0\)&lt;/span>处可导，如果对任意的&lt;span class="math">\(x\in U(x_0)\)&lt;/span>，有 &lt;span class="math">\[f(x)\le f(x_0)或f(x)\ge f(x_0)\]&lt;/span> 那么&lt;span class="math">\(f^\prime(x_0)=0\)&lt;/span>。&lt;/p>
&lt;p>费马引理的一个推论是，函数&lt;span class="math">\(f\)&lt;/span>在定义域&lt;span class="math">\(A\)&lt;/span>内的最大值和最小值只能在&lt;strong>边界&lt;/strong>上，&lt;strong>不可导的点&lt;/strong>，或&lt;strong>驻点&lt;/strong>取得。&lt;/p>
&lt;h3 id="费马引理证明">费马引理证明&lt;/h3>
&lt;p>假设&lt;span class="math">\(x_0\)&lt;/span>是一个极大值（如果&lt;span class="math">\(x_{0}\)&lt;/span>是极小值，证明亦类似）。那么存在一个&lt;span class="math">\(\delta &amp;gt;0\)&lt;/span>，使得对于所有的&lt;span class="math">\(|x-x_{0}|&amp;lt;\delta\)&lt;/span>，都有&lt;span class="math">\(f(x_{0})\geq f(x)\)&lt;/span>。因此对于任何&lt;span class="math">\(h \in (0,\delta)\)&lt;/span>，有： &lt;span class="math">\[\frac{f(x_0+h) - f(x_0)}{h}\leq 0 \tag{1}\]&lt;/span> 由于当&lt;span class="math">\(h\)&lt;/span>从上方趋于0时，这个比值的极限存在且为 &lt;span class="math">\(f&amp;#39;(x_0)\)&lt;/span>，我们便有&lt;span class="math">\(f&amp;#39;(x_0) \le 0\)&lt;/span>。另一方面，当 &lt;span class="math">\(h \in (-\delta,0)\)&lt;/span>时，我们注意到： &lt;span class="math">\[\frac{f(x_0+h) - f(x_0)}{h} \geq 0\tag{2}\]&lt;/span> 当&lt;span class="math">\(h\)&lt;/span>从下方趋于0时，这个极限存在，且等于 &lt;span class="math">\(f&amp;#39;(x_0)\)&lt;/span>，我们又有&lt;span class="math">\(f&amp;#39;(x_0) \ge 0\)&lt;/span>。&lt;/p>
&lt;p>因此&lt;span class="math">\(f&amp;#39;(x_0) = 0\)&lt;/span>。&lt;/p>
&lt;h2 id="一阶微分中值定理">一阶微分中值定理&lt;/h2>
&lt;h3 id="罗尔rolle中值定理">罗尔（Rolle）中值定理&lt;/h3>
&lt;p>&lt;span class="math">\(y=f(x)\)&lt;/span>满足：&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>在区间[a,b]上连续&lt;/li>
&lt;li>在区间（a，b）内可导&lt;/li>
&lt;li>&lt;span class="math">\(f(a)=f(b)\)&lt;/span>&lt;/li>
&lt;/ol>
&lt;p>&lt;span class="math">\(\Rightarrow\)&lt;/span>在(a,b)内至少存在一点&lt;span class="math">\(\xi\)&lt;/span>，使&lt;span class="math">\(f&amp;#39;(\xi)=0\)&lt;/span>&lt;/p>
&lt;p>罗尔（Rolle）中值定理证明：&lt;/p>
&lt;p>因&lt;span class="math">\(f(x)\)&lt;/span>在[a,b]上连续，故在[a,b]上取得最大值M和最小值m。&lt;/p>
&lt;p>若&lt;span class="math">\(M=m\)&lt;/span>，则&lt;span class="math">\(f(x)\equiv M,x\in [a,b],\)&lt;/span>，因此&lt;span class="math">\(\forall\xi\in(a,b),f&amp;#39;(\xi)=0\)&lt;/span>&lt;/p>
&lt;p>若&lt;span class="math">\(M&amp;gt;m\)&lt;/span>，则M和m中至少有一个与端点值不相同，不妨设极大值&lt;span class="math">\(M\neq f(a)\)&lt;/span>，则至少存在一点&lt;span class="math">\(\xi\in(a,b)\)&lt;/span>，使&lt;span class="math">\(f(\xi)=M\)&lt;/span>，则费马引理可知&lt;span class="math">\(f&amp;#39;(\xi)=0\)&lt;/span>（只有在驻点才可能取得极值）。&lt;/p>
&lt;p>注意：定理条件不全具备，结论不一定成立。&lt;/p>
（1）函数不连续 &lt;span class="math">\[f(x)=\begin{cases}
x,\quad 0\leq x &amp;lt;1 \\
0,\quad x=1
\end{cases}\]&lt;/span> &lt;img src="../../images/f_uncontinus.png" alt="函数不连续" />
&lt;center>
图1 函数不连续
&lt;/center>
(2)函数不可导 &lt;span class="math">\[f(x)=\|x\|,x\in [-1,1]\]&lt;/span> &lt;img src="../../images/f_not_deriv.png" alt="函数不可导" />
&lt;center>
图2 函数不可导
&lt;/center>
&lt;h3 id="拉格朗日langrange中值定理">拉格朗日（Langrange）中值定理&lt;/h3>
&lt;p>&lt;span class="math">\(y=f(x)\)&lt;/span>满足：&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>在区间[a,b]上连续&lt;/li>
&lt;li>在区间（a，b）内可导&lt;/li>
&lt;/ol>
&lt;p>&lt;span class="math">\(\Rightarrow\)&lt;/span>至少存在一点&lt;span class="math">\(\xi\in(a,b)\)&lt;/span>，使&lt;span class="math">\(f&amp;#39;(\xi)=\frac{f(b)-f(a)}{b-a}\)&lt;/span>&lt;/p>
&lt;p>拉格朗日（Langrange）中值定理证明：&lt;/p>
&lt;p>可以把问题转为证明&lt;span class="math">\(f&amp;#39;(\xi)-\frac{f(b)-f(a)}{b-a}=0\)&lt;/span>。我们作辅助函数： &lt;span class="math">\[\phi(x)=f(x)-\frac{f(b)-f(a)}{b-a}x\]&lt;/span> 显然，&lt;span class="math">\(\phi(x)\)&lt;/span>在[a,b]上连续，在(a,b)内可导，且&lt;span class="math">\(\phi(a)=\frac{bf(a)-af(b)}{b-a}=\phi(b)\)&lt;/span>。&lt;/p>
&lt;p>&lt;span class="math">\(\phi(x)\)&lt;/span>函数可由罗尔定理只至少存在一点&lt;span class="math">\(\xi\in(a,b)\)&lt;/span>，使&lt;span class="math">\(\phi&amp;#39;(\xi)=0\)&lt;/span>，即定理结论整理。证毕。&lt;/p>
&lt;h3 id="柯西cauchy中值定理">柯西（Cauchy）中值定理&lt;/h3>
&lt;p>&lt;span class="math">\(f(x)\)&lt;/span>及&lt;span class="math">\(F(x)\)&lt;/span>满足：&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>在闭区间[a,b]上连续&lt;/li>
&lt;li>在开区间(a,b)内可导&lt;/li>
&lt;li>在开区间(a,b)内&lt;span class="math">\(F(x)\neq0\)&lt;/span>&lt;/li>
&lt;/ol>
&lt;p>&lt;span class="math">\(\Rightarrow\)&lt;/span>至少存在一点&lt;span class="math">\(\xi\in(a,b)\)&lt;/span>，使&lt;span class="math">\(\frac{f(b)-f(a)}{F(b)-F(a)}=\frac{f&amp;#39;(\xi)}{F&amp;#39;(\xi)}\)&lt;/span>&lt;/p>
&lt;p>证明同拉格朗日中值定理。&lt;/p>
&lt;img src="../../images/mean_value.png" alt="中值定理之间关系" />
&lt;center>
图3 中值定理之间关系
&lt;/center>
&lt;h2 id="泰勒中值定理">泰勒中值定理&lt;/h2>
&lt;p>若&lt;span class="math">\(f(x)\)&lt;/span>在包含&lt;span class="math">\(x_0\)&lt;/span>的某开区间（a，b）内具有直到n+1阶导数，则当&lt;span class="math">\(x\in(a,b)\)&lt;/span>时，有 &lt;span class="math">\[f(x)=f(x_0)+f&amp;#39;(x_0)(x-x_0)+\frac{f&amp;#39;&amp;#39;(x_0)}{2!}(x-x_0)^2+\cdots+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)(1)\]&lt;/span> &lt;span class="math">\[R_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{(n+1)}（2）\]&lt;/span> 其中，&lt;span class="math">\(\xi\)&lt;/span>在&lt;span class="math">\(x\)&lt;/span>和&lt;span class="math">\(x_0\)&lt;/span>之间(&lt;span class="math">\(x\in [min(x,x_0),max(x,x_0)]\)&lt;/span>)。&lt;/p>
&lt;p>公式（1）为泰勒n+1阶展开式。公式（2）为n+1阶泰勒余式，称为拉格朗日余项。&lt;/p>
&lt;h3 id="泰勒中值定理的一阶展开">泰勒中值定理的一阶展开&lt;/h3>
&lt;p>如果&lt;span class="math">\(f(x)\in C^2,P=1,\xi在x_0和x之间\)&lt;/span>，那么 &lt;span class="math">\[f(x)=f(x_0)+f&amp;#39;(x_0)(x-x_0)+\frac{f&amp;#39;&amp;#39;(\xi)}{2!}(x-x_0)^2,\xi\in\]&lt;/span> 变量&lt;span class="math">\(x\)&lt;/span>变成高维（&lt;span class="math">\(0\leq \alpha \leq 1\)&lt;/span>）： &lt;span class="math">\[f(\textbf{x}+\boldsymbol{\delta})=f(\textbf{x})+\textbf{g}(\textbf{x})^T\boldsymbol{\delta}+\frac{1}{2}\boldsymbol{\delta}^T\textbf{H}(\textbf{x}+\alpha\boldsymbol{\delta})\boldsymbol{\delta}\]&lt;/span> 其中，&lt;span class="math">\(\textbf{g}(\textbf{x})\)&lt;/span>为一阶导函数向量（梯度），&lt;span class="math">\(\textbf{H}(\textbf{x})\)&lt;/span>为多元函数的海森矩阵。&lt;/p></description></item><item><title>数学分析之水平集</title><link>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E6%B0%B4%E5%B9%B3%E9%9B%86/</link><pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E6%B0%B4%E5%B9%B3%E9%9B%86/</guid><description>
&lt;h2 id="数学分析之水平集">数学分析之水平集&lt;!-- omit in toc -->&lt;/h2>
&lt;p>水平集是数学中的中一个重要概念，这个概念和函数图像有着直观的联系，同时水平集也和函数的连续性，拟凸性，等高线图有着直接的联系。&lt;/p>
&lt;h2 id="水平集">水平集&lt;/h2>
&lt;p>在数学领域中, 一个具有&lt;span class="math">\(n\)&lt;/span>变量的实值函数&lt;span class="math">\(f\)&lt;/span>的&lt;strong>水平集&lt;/strong>是具有以下形式的集合 &lt;span class="math">\[
\{(x_1,...,x_n)|f(x_1,...,x_n)=c\}
\]&lt;/span>&lt;/p>
&lt;p>其中&lt;span class="math">\(c\)&lt;/span>是常数， 即使得函数值具有给定常数的变量集合。当具有&lt;strong>两个变量&lt;/strong>时, 称为&lt;strong>水平曲线(等高线)&lt;/strong>, 如果有&lt;strong>三个变量, 称为水平曲面&lt;/strong>, 更多变量时, 水平集被叫做&lt;strong>水平超曲面&lt;/strong>。&lt;/p>
&lt;h3 id="例子">例子&lt;/h3>
&lt;p>例如, 指定一个半径&lt;span class="math">\(r\)&lt;/span>, 圆的方程可以定义为一个等高线： &lt;span class="math">\[
r^2=x^2 + y^2
\]&lt;/span> 如果取&lt;span class="math">\(r=5\)&lt;/span>, 那么等高值为&lt;span class="math">\(c=5^2=25\)&lt;/span>。&lt;/p>
&lt;p>所有使得&lt;span class="math">\(x^2 + y^2=25\)&lt;/span>的点&lt;span class="math">\((x,y)\)&lt;/span>构成了它的等高线。 这就是说他们属于等高线的水平集。 如果&lt;span class="math">\(x^2 + y^2\)&lt;/span>小于 25 这个点&lt;span class="math">\((x,y)\)&lt;/span>就在等高线的内部;如果大于25，这个点就在等高线外部。&lt;/p>
&lt;h2 id="水平集与梯度">水平集与梯度&lt;/h2>
&lt;blockquote>
&lt;p>定理： 函数&lt;span class="math">\(f\)&lt;/span>在一点处的梯度与在该点处&lt;span class="math">\(f\)&lt;/span>的水平集垂直。&lt;/p>
&lt;/blockquote>
&lt;p>这个定理是十分不寻常的。为更好的理解定理的含义，设想两个旅行者在一座山峰的同一位置。其中一个人很大胆，决定从坡度最大的地方走。另一个人比较保守；他不想向上爬，也不想走下去，选择了一条在同一高度的路。上面的定理就是说，这两个旅行者相互离开的方向是互相垂直的。&lt;/p>
&lt;div class="figure">
&lt;img src="../../images/Level_grad.png" alt="Level_grad.png" />&lt;p class="caption">Level_grad.png&lt;/p>
&lt;/div>
&lt;h2 id="上水平集和下水平集">上水平集和下水平集&lt;/h2>
&lt;blockquote>
&lt;p>集合&lt;span class="math">\(\{ (x_1,...,x_n) | f(x_1,...,x_n) ≤ c \}\)&lt;/span>被称为&lt;span class="math">\(f\)&lt;/span>的下水平集或子水平集;&lt;/p>
&lt;p>集合&lt;span class="math">\(\{ (x_1,...,x_n) | f(x_1,...,x_n) \geq c \}\)&lt;/span>被称为&lt;span class="math">\(f\)&lt;/span>的上水平集。&lt;/p>
&lt;/blockquote>
&lt;p>上下水平集与&lt;strong>最大最小值定理&lt;/strong>相关：&lt;/p>
&lt;blockquote>
&lt;p>定义：对于一个拓扑空间&lt;span class="math">\(X\)&lt;/span>，如果&lt;/p>
&lt;ul>
&lt;li>&lt;span class="math">\(f:X→R\)&lt;/span>是下半连续的，则其任意下水平集是闭的。&lt;/li>
&lt;li>&lt;span class="math">\(f:X→R\)&lt;/span>是上半连续的，则其任意上水平集是闭的。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>通过半连续性，我们可以知道一个映射是否可以取到最值&lt;/strong>： &amp;gt;定理：设&lt;span class="math">\(X\)&lt;/span>是非空紧集，&lt;span class="math">\(f:X→R\)&lt;/span>则： &amp;gt; &amp;gt;- &lt;span class="math">\(f\)&lt;/span>下半连续&lt;span class="math">\(\Rightarrow\)&lt;/span>函数有最小值 &amp;gt;- &lt;span class="math">\(f\)&lt;/span>上半连续&lt;span class="math">\(\Rightarrow\)&lt;/span>函数有最大值&lt;/p>
&lt;p>具体可以参考&lt;a href="https://en.wikipedia.org/wiki/Extreme_value_theorem#Extension_to_semi-continuous_functions">魏尔斯特拉斯极值定理&lt;/a>&lt;/p>
&lt;p>上下水平集与&lt;strong>拟凸拟凹函数&lt;/strong>有关：&lt;/p>
&lt;blockquote>
&lt;p>&lt;span class="math">\(f:R^n→R, \mathop{dom}f\)&lt;/span>是凸集，&lt;span class="math">\(\alpha-\)&lt;/span>下水平集是凸集，则&lt;span class="math">\(f(x)\)&lt;/span>为&lt;strong>拟凸函数&lt;/strong>。即 &lt;span class="math">\[f:R^n→R,s.t.\, S_\alpha=\{x\in \mathop{dom} f| f(x)\geq \alpha\}为凸集\]&lt;/span> &lt;span class="math">\(f\)&lt;/span>是拟凸函数，我们称&lt;span class="math">\(-f\)&lt;/span>为&lt;strong>拟凹&lt;/strong>函数,拟凹函数的&lt;span class="math">\(\alpha-\)&lt;/span>&lt;strong>上水平集是凸集&lt;/strong>。&lt;/p>
&lt;/blockquote></description></item><item><title>数学分析之连续性</title><link>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9E%E7%BB%AD%E6%80%A7/</link><pubDate>Sun, 15 Mar 2020 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E8%BF%9E%E7%BB%AD%E6%80%A7/</guid><description>
&lt;h2 id="数学分析之连续性">数学分析之连续性&lt;!-- omit in toc -->&lt;/h2>
&lt;p>设有一个&lt;span class="math">\(f:\mathcal R^n→\mathcal R^m\)&lt;/span>的映射。&lt;/p>
&lt;blockquote>
&lt;p>点的连续性：&lt;span class="math">\(f\)&lt;/span>称为在&lt;span class="math">\(x_0\in \mathcal R^n\)&lt;/span>处&lt;strong>连续&lt;/strong>，若&lt;span class="math">\(\forall \varepsilon&amp;gt;0, \exists \delta&amp;gt;0\)&lt;/span>，&lt;span class="math">\(s.t. \forall x\in \mathcal R^n\)&lt;/span>，若&lt;span class="math">\(\Vert x-x_0\Vert&amp;lt;\delta\)&lt;/span>，则有&lt;span class="math">\(\Vert f(x)-f(x_0)\Vert &amp;lt;\varepsilon\)&lt;/span>。&lt;/p>
&lt;/blockquote>
&lt;p>如果我们用开球（又称邻域）&lt;span class="math">\(B(x_0;r)=\{x\in \mathcal{R^n} \big\vert \Vert x-x_0\Vert &amp;lt;r\}\)&lt;/span>，来描述连续性： &amp;gt;&lt;span class="math">\(\forall \varepsilon&amp;gt;0, \exists \delta&amp;gt;0有f(B(x_0;\delta))\subset B(f(x_0);\varepsilon)\)&lt;/span> ---------------------------------------- &amp;gt;映射的连续性：&lt;span class="math">\(f:\mathcal R^n→\mathcal R^m\)&lt;/span>称为连续映射，若&lt;span class="math">\(\forall x_0 \in \mathcal R^n\)&lt;/span>，&lt;span class="math">\(f\)&lt;/span>在&lt;span class="math">\(x_0\)&lt;/span>出连续。&lt;/p>
&lt;h2 id="连续与开集的关系">连续与开集的关系&lt;/h2>
&lt;p>设开集为&lt;span class="math">\(U\)&lt;/span>，若对于&lt;span class="math">\(\forall U \underset{open}{\subset} \mathcal{R^m}\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>&lt;span class="math">\(f\)&lt;/span>连续&lt;span class="math">\(\Rightarrow\)&lt;/span>开集的原像是开集&lt;/strong>&lt;/p>
&lt;p>考虑&lt;span class="math">\(U\)&lt;/span>的原像&lt;span class="math">\(f^{-1}(U),\forall x_0\in f^{-1}(U),f(x_0)\in U\)&lt;/span>。&lt;/p>
&lt;p>由于&lt;span class="math">\(U\)&lt;/span>是开集，对于其中的点&lt;span class="math">\(f(x_0)，\exist \varepsilon&amp;gt;0. s.t. B(f(x_0);\varepsilon)\subset U\)&lt;/span>&lt;/p>
&lt;p>又因为&lt;span class="math">\(f\)&lt;/span>在&lt;span class="math">\(x_0\)&lt;/span>出连续，则&lt;span class="math">\(\exist \delta&amp;gt;0\)&lt;/span>使得&lt;span class="math">\(f(B(x_0;\delta))\subset B(f(x_0);\varepsilon)\Rightarrow B(x_0;\delta)\subset f^{-1}(B(f(x_0);\varepsilon))\subset f^{-1}(U)\)&lt;/span>。对于&lt;span class="math">\(U\)&lt;/span>中每一点都成立，所以&lt;span class="math">\(f^{-1}(U)\)&lt;/span>为&lt;span class="math">\(\mathcal{R^n}\)&lt;/span>中开集。&lt;/p>
&lt;p>&lt;strong>开集的原像是开集&lt;span class="math">\(\Rightarrow f\)&lt;/span>连续&lt;/strong>&lt;/p>
&lt;p>&lt;span class="math">\(\forall x_0 \in \mathcal{R^n}\)&lt;/span>，先证&lt;span class="math">\(f\)&lt;/span>在任一点&lt;span class="math">\(x_0\)&lt;/span>出连续。&lt;/p>
&lt;p>&lt;span class="math">\(\forall \varepsilon&amp;gt;0\)&lt;/span>，考虑&lt;span class="math">\(B(f(x_0);\varepsilon)\)&lt;/span>,由于条件开集的原像为开集，开球的原像&lt;span class="math">\(f^{-1}(B(f(x_0);\varepsilon))\)&lt;/span>也是开集，即&lt;span class="math">\(x_0\in f^{-1}(B(f(x_0);\varepsilon))且\exist\delta&amp;gt;0\)&lt;/span>，s.t. &lt;span class="math">\(B(x_0;\delta)\subset f^{-1}(B(f(x_0);\varepsilon))\Rightarrow f(B(x_0;\delta))\subset B(f(x_0);\varepsilon)\Rightarrow f\)&lt;/span>在&lt;span class="math">\(x_0\)&lt;/span>出连续。由于对任意&lt;span class="math">\(x_0\)&lt;/span>都成立，所以映射&lt;span class="math">\(f\)&lt;/span>连续。&lt;/p>
&lt;p>总结：&lt;strong>&lt;span class="math">\(f:\mathcal{R^n}→\mathcal{R^m}\)&lt;/span>连续映射&lt;span class="math">\(\Leftrightarrow\)&lt;/span>在&lt;span class="math">\(f\)&lt;/span>下，开集的原像为开集&lt;/strong>。这样我们可以&lt;strong>仅通过开集的概念来验证映射的连续性&lt;/strong>。&lt;/p></description></item><item><title>数学分析-三角函数与三角级数的正交性</title><link>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%89%E8%A7%92%E7%BA%A7%E6%95%B0%E7%9A%84%E6%AD%A3%E4%BA%A4%E6%80%A7/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%89%E8%A7%92%E7%BA%A7%E6%95%B0%E7%9A%84%E6%AD%A3%E4%BA%A4%E6%80%A7/</guid><description>
&lt;h2 id="三角函数与三角级数的正交性">三角函数与三角级数的正交性&lt;!-- omit in toc -->&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="#三角恒等式和差化积与积化和差">三角恒等式——和差化积与积化和差&lt;/a>&lt;/li>
&lt;li>&lt;a href="#三角级数与三角函数系的正交性">三角级数与三角函数系的正交性&lt;/a>&lt;/li>
&lt;li>&lt;a href="#应用傅里叶级数展开">应用——傅里叶级数展开&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="三角恒等式和差化积与积化和差">三角恒等式——和差化积与积化和差&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th align="center">积化和差&lt;/th>
&lt;th align="center">和差化积&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td align="center">&lt;span class="math">\({\displaystyle \sin \alpha \cos \beta ={\sin(\alpha +\beta )+\sin(\alpha -\beta ) \over 2}}\)&lt;/span>&lt;/td>
&lt;td align="center">&lt;span class="math">\({\displaystyle \sin \alpha +\sin \beta =2\sin {\frac {\alpha +\beta }{2}}\cos {\frac {\alpha -\beta }{2}}}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td align="center">&lt;span class="math">\({\displaystyle \cos \alpha \sin \beta ={\sin(\alpha +\beta )-\sin(\alpha -\beta ) \over 2}}\)&lt;/span>&lt;/td>
&lt;td align="center">&lt;span class="math">\({\displaystyle \sin \alpha -\sin \beta =2\cos {\alpha +\beta \over 2}\sin {\alpha -\beta \over 2}}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td align="center">&lt;span class="math">\({\displaystyle \cos \alpha \cos \beta ={\cos(\alpha +\beta )+\cos(\alpha -\beta ) \over 2}}\)&lt;/span>&lt;/td>
&lt;td align="center">&lt;span class="math">\({\displaystyle \cos \alpha +\cos \beta =2\cos {\frac {\alpha +\beta }{2}}\cos {\frac {\alpha -\beta }{2}}}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td align="center">&lt;span class="math">\({\displaystyle \sin \alpha \sin \beta =-{\cos(\alpha +\beta )-\cos(\alpha -\beta ) \over 2}}\)&lt;/span>&lt;/td>
&lt;td align="center">&lt;span class="math">\({\displaystyle \cos \alpha -\cos \beta =-2\sin {\alpha +\beta \over 2}\sin {\alpha -\beta \over 2}}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="三角级数与三角函数系的正交性">三角级数与三角函数系的正交性&lt;/h2>
&lt;blockquote>
&lt;p>定理1： 组成三角级数的函数系 &lt;span class="math">\[1, \sin x, \cos x, \sin 2x, \cos 2x, \dotsb, \sin nx, \cos nx\]&lt;/span> 在区间&lt;span class="math">\([-\pi , \pi]或[0, 2\pi]\)&lt;/span>上正交，即其中任意两个&lt;strong>不同&lt;/strong>函数之积在区间&lt;span class="math">\([-\pi , \pi]或[0, 2\pi]\)&lt;/span>积分为0.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>证明&lt;/strong>：&lt;/p>
可以用积化和差公式证明，&lt;span class="math">\(\sin kx \cos nx={1 \over 2}[\sin (kx+nx)+\sin (kx-nx)]\)&lt;/span>，其中&lt;span class="math">\(k,n\)&lt;/span>为整数，且&lt;span class="math">\(k \neq n\)&lt;/span>。 $$
&lt;p>&lt;span class="math">\[
由于对任意**非0**整数$n$，有$\sin nx, \cos nx$在区间$[-\pi , \pi]或[0, 2\pi]$积分为0，所以上式右侧积分为0，即
\]&lt;/span> &lt;em>0^{2}kx nx x = 0 &lt;span class="math">\[
同理可以证明
\]&lt;/span> &lt;/em>0^{2}kx nx x = 0\ &lt;em>0^{2}kx nx x = 0\ &lt;/em>0^{2}kx nx x = 0 &lt;span class="math">\[
需要指出的是三角函数系中相同函数的乘积在在区间$[-\pi , \pi]或[0, 2\pi]$积分不为0，即
\]&lt;/span> &lt;em>0^{2}nx nx x 0\ &lt;/em>0^{2}nx nx x 0\ $$ 我们从积化和差公式中也可以窥出原因，即出现了直流项。&lt;/p>
&lt;h2 id="应用傅里叶级数展开">应用——傅里叶级数展开&lt;/h2>
&lt;blockquote>
&lt;p>狄利克雷定理 (傅里叶级数):&lt;/p>
&lt;p>设&lt;span class="math">\(f(x)\)&lt;/span>是周期为&lt;span class="math">\(2\pi\)&lt;/span>的周期函数，并满足狄利克雷条件：&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>在一个周期内连续或只有有限个第一类间断点；&lt;/li>
&lt;li>在一个周期内只有有限个极限点；&lt;/li>
&lt;/ol>
&lt;p>则&lt;span class="math">\(f(x)\)&lt;/span>的傅里叶级数收敛，且有 &lt;span class="math">\[
\frac{a_0}{2}+\sum_{n=1}^\infty(a_n \cos nx + b_n \sin nx)=\\
\begin{cases}
f(x), x为连续点\\
\frac{f(x^+)+f(x^-)}{2}, x为间断点
\end{cases}
\]&lt;/span> 其中，&lt;span class="math">\(a_n, b_n\)&lt;/span>为&lt;span class="math">\(f(x)的傅里叶系数\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>可以发现傅里叶级数比幂级数的条件要宽松很多，对可导没有要求。&lt;/p>
&lt;p>另外，对奇函数，偶函数可以有对应的正弦级数和余弦级数。&lt;/p></description></item><item><title>数学分析-等幂求和公式</title><link>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90-%E7%AD%89%E5%B9%82%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F/</link><pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90-%E7%AD%89%E5%B9%82%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F/</guid><description>
&lt;h2 id="等幂求和公式">等幂求和公式&lt;!-- omit in toc -->&lt;/h2>
&lt;h2 id="一阶求和公式">一阶求和公式&lt;/h2>
&lt;p>一阶求和公式就是我们熟知的高斯求和公式 &lt;span class="math">\[
S_1(n) = 1+2+3+\dotsb+n=\frac{n(n+1)}{2}
\]&lt;/span>&lt;/p>
&lt;h2 id="二阶求和公式">二阶求和公式&lt;/h2>
&lt;p>&lt;span class="math">\[
S_2(n) = 1^2+2^2+3^2+\dotsb+n^2=\frac{n(n+1)(2n+1)}{6}
\]&lt;/span>&lt;/p>
&lt;p>二阶求和公式在高中也学过，但当时使用的是猜测加数学归纳法，公式的推导过程不够直观。下面，我们用一个直观的构造法来推导二阶求和公式。&lt;/p>
&lt;p>构造直到&lt;span class="math">\(2n\)&lt;/span>的平方和： &lt;span class="math">\[
\begin{aligned}
S_2(2n)&amp;amp;=1^2+2^2+3^2+\dotsb+n^2+(n+1)^2+\dotsb+(n+n)^2\\
&amp;amp;=\underbrace{1^2+2^2+3^2+\dotsb+n^2}_{S_2(n)}+(n^2+2n+1^2)+\dotsb+(n^2+2n\times n+n^2)\\
&amp;amp;=S_2(n)+n\times n^2 + 2n\underbrace{(1+2+3+\dotsb+n)}_{S_1(n)}+\underbrace{(1^2+2^2+\dotsb+n^2)}_{S_2(n)}\\
&amp;amp;=2S_2(n)+n^3+2n\times \frac{n(n+1)}{2}\\
&amp;amp;=2S_2(n)+2n^3+n^2 \dotsb(1)\\
\end{aligned}
\]&lt;/span> 另一个方面，我们可以将&lt;span class="math">\(S_2(2n)\)&lt;/span>根据奇偶性拆分： &lt;span class="math">\[
\begin{aligned}
S_2(2n)&amp;amp;=1^2+2^2+3^2+\dotsb+n^2+(n+1)^2+\dotsb+(n+n)^2\\
&amp;amp;=1^2+3^2+\dotsb+(2n-1)^2+2^2+4^2+\dotsb+(2n)^2\\
&amp;amp;=(2\times 1-1)^2+(2\times 2-1)^2+\dotsb+(2\times n-1)^2+4\underbrace{(1^2+2^2+\dotsb+n^2)}_{S_(n)}\\
&amp;amp;=(2^2\times 1^2 - 2\times 2\times 1 + 1^2)+(2^2\times 2^2 - 2\times 2\times 2 + 1^2)+\dotsb\\
&amp;amp;+(2^2\times n^2 - 2\times 2\times n + 1^2)+4S_2(n)\\
&amp;amp;=4\underbrace{(1^2+2^2+\dotsb+n^2)}_{S_2(n)}-4(1+2+\dotsb+n)+n+4S_2(n)\\
&amp;amp;=8S_2(n)-4\frac{n(n+1)}{2}+n=8S_2(n)-2n^2-n\dotsb(2)
\end{aligned}
\]&lt;/span> 显然公式&lt;span class="math">\((1)\)&lt;/span>等于公式&lt;span class="math">\((2)\)&lt;/span>，因此有： &lt;span class="math">\[
2S_2(n)+2n^3+n^2=8S_2(n)-2n^2-n\\
\Rightarrow S_2(n)=\frac{n(n+1)(2n+1)}{6}
\]&lt;/span>&lt;/p>
&lt;h2 id="三阶求和公式">三阶求和公式&lt;/h2>
&lt;p>&lt;span class="math">\[
S_3(n)=\left[{\frac {n(n+1)}{2}}\right]^{{2}}
\]&lt;/span> 三阶求和公式也需要一个构造，这个构造利用了对称性，比二阶求和公式好懂一些。 &lt;span class="math">\[
S_3(n)=1^3 +2^3 +3^3 +\dotsb+n^3\\
S_3(n)=n^3+(n-1)^3+(n-2)^3+\dotsb+1^3
\]&lt;/span> 两者相加有： &lt;span class="math">\[
\begin{aligned}
2S_3(n)&amp;amp;=n^3+1^3+(n-1)^3+2^3+(n-2)^3+3^3+\dotsb+1^3+n^3\\
&amp;amp;根据立方和公式a^3+b^3=(a+b)(a^2-ab+b^2)有：\\
2S_3(n)&amp;amp;=(n+1)(n^2-n+1)+[n+1]((n-1)^2-2(n-1)+2^2)\\
&amp;amp;+[n+1]((n-2)^2-3(n-2)+3^2)+\dotsb+[n+1](1^2-n+n^2)\\
&amp;amp;=[n+1](2\underbrace{(1^2+2^2+\dotsb+n^2)}_{S_2(n)}-(1\times n+2(n-1)+3(n-2)+\dotsb+n\times (n-(n-1)))\\
&amp;amp;=[n+1](2S_2(n)-n\underbrace{(1+2+\dotsb+n)}_{S_1(n)}+2\times 1+3\times 2+\dotsb+n\times(n-1))\\
&amp;amp;=[n+1](2S_2(n)-nS_1(n)+1^2+1+2^2+2+\dotsb+(n-1)^2+(n-1))\\
&amp;amp;=[n+1](2S_2(n)-nS_1(n)+(S_2(n)-n^2)+(S_1(n)-n))\\
&amp;amp;=[n+1](3S_2(n)-(n-1)S_1(n)-n^2-n)\\
&amp;amp;代入S_1(n),S_2(n)结果可得：\\
&amp;amp;=[n+1](\frac{n(n+1)(2n+1)}{2}-\frac{(n-1)n(n+1)}{2}-n(n+1))\\
&amp;amp;={1\over 2}(n+1)^2[n(2n+1)-(n-1)n-2n]=\frac{1}{2}n^2(n+1)^2\\
\Rightarrow S_3(n)&amp;amp;=\frac{1}{4}n^2(n+1)^2=[\frac{n(n+1)}{2}]^2
\end{aligned}
\]&lt;/span>&lt;/p>
&lt;h2 id="等幂求和公式推断">等幂求和公式推断&lt;/h2>
&lt;p>我们根据1~3阶的求和公式发现，&lt;span class="math">\(m\)&lt;/span>阶&lt;span class="math">\(n\)&lt;/span>个连续自然数的和是&lt;strong>一个和&lt;span class="math">\(n\)&lt;/span>相关的&lt;span class="math">\(m+1\)&lt;/span>阶多项式(且没有0阶项)&lt;/strong>，因此可以猜测，&lt;span class="math">\(m\)&lt;/span>阶&lt;span class="math">\(n\)&lt;/span>个连续自然数和的形式为: &lt;span class="math">\[
a_{m+1} n^{m+1}+a_{m} n^{m}+\dotsb+a_1 n^1
\]&lt;/span> 这样我们可以先找出&lt;span class="math">\(m+1\)&lt;/span>个初始条件，然后以待定系数法求得求和公式。以2阶求和公式为例： &lt;span class="math">\[
\begin{aligned}
1^2 = 1 &amp;amp;= 1^3 a_3+ 1^2 a_2 + 1^1 a_1 \\
1^2 +2^2 = 5&amp;amp;= 2^3 a_3+ 2^2 a_2 + 2^1 a_1\\
1^2 +2^2 + 3^2= 14&amp;amp;= 3^3 a_3+ 3^2 a_2 + 3^1 a_1
\end{aligned}
\]&lt;/span> 根据高斯消元法或者克莱姆法则可知： &lt;span class="math">\[
\begin{cases}
a_1=\frac{1}{3}\\
a_2=\frac{1}{2}\\
a_3=\frac{1}{6}\\
\end{cases}
\]&lt;/span> 即2阶求和公式为&lt;span class="math">\(S_2(n)=\frac{1}{3}n^3+\frac{1}{2}n^2+\frac{1}{6}n\)&lt;/span>。&lt;/p>
&lt;p>当然这只是通过推断得出的结论，没有直接的证明。下面直接给出等幂求和公式 &lt;span class="math">\[
S_m(n)={1 \over {m+1}}\sum_{{i=0}}^{m}{m+1 \choose {i}}B_{i}(n+1)^{{m+1-i}}\tag{3}
\]&lt;/span> 其中&lt;span class="math">\(B_i\)&lt;/span>是伯努利数。关于伯努利数请参考维基百科&lt;a href="https://zh.wikipedia.org/wiki/%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0">https://zh.wikipedia.org/wiki/%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0&lt;/a>.&lt;/p></description></item><item><title>数学分析-基础</title><link>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80/</link><pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80/</guid><description>
&lt;h2 id="数学分析基础">数学分析基础&lt;!-- omit in toc -->&lt;/h2>
&lt;div class="figure">
&lt;img src="../../images/数学分析定理关系.jpg" alt="数学分析定理关系" />&lt;p class="caption">数学分析定理关系&lt;/p>
&lt;/div>
&lt;ul>
&lt;li>&lt;a href="#实数完备性定理">实数完备性定理&lt;/a>&lt;/li>
&lt;li>&lt;a href="#确界定理">确界定理&lt;/a>&lt;/li>
&lt;li>&lt;a href="#单调有界定理">单调有界定理&lt;/a>&lt;/li>
&lt;li>&lt;a href="#闭区间套定理">闭区间套定理&lt;/a>&lt;/li>
&lt;li>&lt;a href="#列紧性定理致密性定理">列紧性定理(致密性定理)&lt;/a>&lt;/li>
&lt;li>&lt;a href="#柯西收敛准则">柯西收敛准则&lt;/a>&lt;/li>
&lt;li>&lt;a href="#有限覆盖定理紧性">有限覆盖定理（紧性）&lt;/a>&lt;/li>
&lt;li>&lt;a href="#聚点定理">聚点定理&lt;/a>&lt;/li>
&lt;li>&lt;a href="#导集内核闭包">导集内核闭包&lt;/a>&lt;/li>
&lt;li>&lt;a href="#从完备性列紧紧看定理体系">从完备性，列紧，紧看定理体系&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="实数完备性定理">实数完备性定理&lt;/h2>
&lt;p>详细请看&lt;a href="../文档/实变函数/实数完备性基本定理的相互证明(30个).pdf">实数完备性基本定理的相互证明(30个).pdf&lt;/a>&lt;/p>
&lt;h2 id="确界定理">确界定理&lt;/h2>
&lt;blockquote>
&lt;p>上（下）确界的两种定义方式：&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>严格定义：若&lt;span class="math">\(\beta\)&lt;/span>是数集&lt;span class="math">\(S\)&lt;/span>的一个上（下）界，并且有&lt;span class="math">\(\forall \varepsilon&amp;gt;0，\exists x_\varepsilon ∈ S\)&lt;/span>，满足&lt;span class="math">\(x_\varepsilon&amp;gt;\beta-\varepsilon(x_\varepsilon&amp;lt;\beta+\varepsilon)\)&lt;/span>，则称&lt;span class="math">\(\beta\)&lt;/span>是数集&lt;span class="math">\(S\)&lt;/span>的上（下）确界。&lt;/li>
&lt;li>简化定义：上确界是最小上界，下确界是最大下界。&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>确界原理可以被看做&lt;strong>公理&lt;/strong>，它是实数的&lt;strong>连续性或完备性&lt;/strong>的体现，即实数包含了数轴上所有的点，没有空隙。数集&lt;span class="math">\(S\)&lt;/span>的上确界常被记作&lt;span class="math">\(\sup S\)&lt;/span>，下确界记作&lt;span class="math">\(\inf S\)&lt;/span>。&lt;/p>
&lt;blockquote>
&lt;p>有上界的非空数集必有上确界。有下界的非空数集必有下确界。&lt;/p>
&lt;p>空集的上确界是&lt;span class="math">\(-∞\)&lt;/span>，下确界是&lt;span class="math">\(+∞\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h2 id="单调有界定理">单调有界定理&lt;/h2>
&lt;blockquote>
&lt;p>单调有界定理:单调有界数列必有极限。&lt;/p>
&lt;/blockquote>
&lt;p>证明：&lt;/p>
&lt;p>考虑有上界的单调递增序列，确定定理指出，有上界必有上确界。&lt;/p>
&lt;p>首先指出有上确界&lt;span class="math">\(a，\forall a_n和\varepsilon&amp;gt;0，a_n≤a&amp;lt;a+\varepsilon\)&lt;/span>。&lt;/p>
&lt;p>其次根据上确界的定义，&lt;span class="math">\(\forall \varepsilon&amp;gt;0，\exists a_N\)&lt;/span>，使得&lt;span class="math">\(a_N&amp;gt;a-\varepsilon\)&lt;/span>。由于序列递增，所以当&lt;span class="math">\(n&amp;gt;N\)&lt;/span>时，&lt;span class="math">\(a_n≥a_N&amp;gt;a-\varepsilon\)&lt;/span>。&lt;/p>
&lt;p>综上，当&lt;span class="math">\(n&amp;gt;N\)&lt;/span>时，&lt;span class="math">\(\forall \varepsilon&amp;gt;0\)&lt;/span>， &lt;span class="math">\[a_n&amp;lt;a+\varepsilon\Rightarrow a_n-a&amp;lt;\varepsilon\\
a_n≥a_N&amp;gt;a-\varepsilon\Rightarrow a-a_n&amp;lt;\varepsilon\]&lt;/span> 即&lt;span class="math">\(|a_n-a|&amp;lt;\varepsilon\)&lt;/span>，上确界&lt;span class="math">\(a\)&lt;/span>为序列的极限。同理对于有下界的递减数列同样可得极限为下确界。&lt;/p>
&lt;blockquote>
&lt;p>推论：&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>如果单调序列的一个子序列收敛，则这个单调序列收敛。&lt;/li>
&lt;li>如果单调序列的一个子序列趋向无穷，则这个序列发散。&lt;/li>
&lt;li>一个单调序列要么收敛要么发散。&lt;/li>
&lt;li>单调序列收敛的&lt;strong>充分必要&lt;/strong>条件是序列有界。&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h2 id="闭区间套定理">闭区间套定理&lt;/h2>
&lt;blockquote>
&lt;p>设&lt;span class="math">\(I_n=[a_n,b_n],n∈N^+\)&lt;/span>，为一列闭区间，满足：&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>&lt;span class="math">\(I_1\supset I_2\supset I_3\supset\dotsb\supset I_n\supset I_{n+1} \dotsb\)&lt;/span>&lt;/li>
&lt;li>区间长度&lt;span class="math">\(|I_n|=b_n-a_n → 0(n→∞)\)&lt;/span>，&lt;/li>
&lt;/ol>
&lt;p>则存在&lt;strong>唯一一点&lt;/strong>&lt;span class="math">\(\xi满足\xi\in\bigcap\limits_{n=1}^∞ I_n\)&lt;/span>。&lt;/p>
&lt;/blockquote>
&lt;p>即&lt;span class="math">\(\lim_{n→∞}a_n=\lim_{n→∞}b_n=\xi\)&lt;/span>。&lt;strong>R中长度趋于0的区间套有且只有一个公共点。&lt;/strong> &lt;img src="../../images/闭区间套定理.png" alt="闭区间套定理" />&lt;/p>
&lt;p>证明：由区间的包含关系可知，左端点组成的数列&lt;span class="math">\(\{a_n\}\)&lt;/span>递增，右端点组成的数列&lt;span class="math">\(\{b_n\}\)&lt;/span>递减，并且&lt;span class="math">\(\{a_n\}\)&lt;/span>有上界&lt;span class="math">\(b_1\)&lt;/span>，&lt;span class="math">\(\{b_n\}\)&lt;/span>有下界&lt;span class="math">\(a_1\)&lt;/span>。由&lt;strong>单调有界定理&lt;/strong>可知，下面两式有极限： &lt;span class="math">\[\lim_{n→∞}a_n=a\\
\lim_{n→∞}b_n=b\]&lt;/span> 由于&lt;span class="math">\(a_n\leq b_n\)&lt;/span>恒成立，所以&lt;span class="math">\(a\leq b\)&lt;/span>，因此由不等式： &lt;span class="math">\[a_n≤a≤b≤b_n(n∈N^+)\\
\Rightarrow 0≤b-a≤b_n-a_n=|I_n|\]&lt;/span> 由区间长度&lt;span class="math">\(|I_n|→0(n→∞)\)&lt;/span>可知，&lt;span class="math">\(a=b\)&lt;/span>。此时： &lt;span class="math">\[a_n≤a=b≤b_n，对\forall n∈N^+成立，即a ∈ I_n\]&lt;/span> 由此可得：&lt;span class="math">\(a ∈ \bigcap\limits_{n=1}^∞ I_n\)&lt;/span>，&lt;span class="math">\(a\)&lt;/span>的唯一性可有极限的唯一性(Hausdorff空间极限都唯一)推得。&lt;/p>
&lt;h2 id="列紧性定理致密性定理">列紧性定理(致密性定理)&lt;/h2>
&lt;blockquote>
&lt;p>列紧性定理(致密性定理)：任意有界数列中必可造出收敛子列。&lt;/p>
&lt;/blockquote>
&lt;p>证明：&lt;/p>
&lt;p>方法1：区间套定理。&lt;/p>
&lt;p>设&lt;span class="math">\(\{x_n\}\)&lt;/span>为一有界数列，有&lt;span class="math">\(a≤x_n≤b\)&lt;/span>，将区间&lt;span class="math">\([a,b]\)&lt;/span>分成&lt;span class="math">\([a,(a+b)/2]\)&lt;/span>和&lt;span class="math">\([(a+b)/2,b]\)&lt;/span>两部分，显然至少一个区间包含无穷多项，取那个区间的下界记作&lt;span class="math">\(a_1\)&lt;/span>，上界记作&lt;span class="math">\(b_1\)&lt;/span>。在该区间任取一项记作&lt;span class="math">\(c_1\)&lt;/span>。依次取下去得到数列&lt;span class="math">\(\{a_n\}\)&lt;/span>和&lt;span class="math">\(\{b_n\}\)&lt;/span>和闭区间列&lt;span class="math">\(\{[a_n,b_n]\}\)&lt;/span>，且&lt;span class="math">\(\lim\limits_{n→∞}(b_n-a_n)=\lim\limits_{n→∞}\frac{b-a}{2^n}=0\)&lt;/span>。根据区间套定理，&lt;span class="math">\(\lim\limits_{n→∞}a_n=\lim\limits_{n→∞}b_n=\xi\)&lt;/span>，由于每一个区间包含无穷多项，因而可以取到完整的子列&lt;span class="math">\(\{c_n\}\)&lt;/span>，并且有&lt;span class="math">\(a_n≤c_n≤b_n\)&lt;/span>，根据夹逼定理有&lt;span class="math">\(\lim\limits_{n→∞}c_n=\xi\)&lt;/span>。&lt;/p>
&lt;p>方法2：此外还可以依赖&lt;strong>单调有界定理&lt;/strong>，以下重点说明。&lt;/p>
&lt;blockquote>
&lt;p>引理：每一个无限实数序列必包含一个单调子序列。&lt;/p>
&lt;p>如果对于一个正整数&lt;span class="math">\(n\)&lt;/span>，有如果&lt;span class="math">\(n&amp;lt;m\)&lt;/span>，那么&lt;span class="math">\(a_n&amp;gt;a_m\)&lt;/span>，则称&lt;span class="math">\(a_n\)&lt;/span>为一个“峰”。即峰值比以后任意一个数值都要大。&lt;/p>
&lt;p>如果峰的个数有无限多个，&lt;span class="math">\(n_{1}&amp;lt;n_{2}&amp;lt;n_{3}&amp;lt;\dots &amp;lt;n_{j}&amp;lt;\dots\)&lt;/span>，那么我们构造峰的子序列&lt;span class="math">\(\{a_{n_j}\}\)&lt;/span>。由于峰值递减，所以子序列&lt;span class="math">\(\{a_{n_j}\}\)&lt;/span>为一&lt;strong>单调递减&lt;/strong>子序列。如果峰的个数有限，那么设&lt;span class="math">\(N\)&lt;/span>为&lt;strong>最后一个峰&lt;/strong>的序号，取&lt;span class="math">\(n_1=N+1\)&lt;/span>，&lt;span class="math">\(n_1\)&lt;/span>不是峰，那意味着&lt;span class="math">\(\exists n_2&amp;gt;n_1\)&lt;/span>，使得&lt;span class="math">\(a_{n_2}≥a_{n_1}\)&lt;/span>。同样的，&lt;span class="math">\(n_2\)&lt;/span>也不是峰，那么&lt;span class="math">\(\exists n_3&amp;gt;n_2\)&lt;/span>，使得&lt;span class="math">\(a_{n_3}≥a_{n_2}\)&lt;/span>。重复这个过程，我们就可以取得一个&lt;strong>单调递增&lt;/strong>序列&lt;span class="math">\(\{a_{n_1},a_{n_2},a_{n_3},\dotsb\}\)&lt;/span>。&lt;/p>
&lt;p>引理证毕。&lt;/p>
&lt;/blockquote>
&lt;p>我们已知序列&lt;span class="math">\(\{a_n\}\)&lt;/span>中必存在一个单调子序列。并且原序列是有界的，所以子序列是一个单调有界子序列，根据&lt;strong>单调有界定理&lt;/strong>，此子序列收敛（存在极限）。&lt;/p>
&lt;p>定理证毕。&lt;/p>
&lt;h2 id="柯西收敛准则">柯西收敛准则&lt;/h2>
&lt;blockquote>
&lt;p>柯西基本序列：对给定数列&lt;span class="math">\(x_n\)&lt;/span>，如&lt;span class="math">\(\forall \varepsilon&amp;gt;0，\exists N ∈ \mathbb{N^+}\)&lt;/span>，当&lt;span class="math">\(m，n ∈ \mathbb{N^+}，且m，n&amp;gt;N\)&lt;/span>时，都有 &lt;span class="math">\[|x_m-x_n|&amp;lt;\varepsilon\]&lt;/span> 则称&lt;span class="math">\(x_n\)&lt;/span>为基本列。或者叙述为：&lt;/p>
&lt;span class="math">\(\forall \varepsilon &amp;gt; 0, \exists N ∈ \mathbb{N^+}，当n&amp;gt;N时，\forall p ∈ \mathbb{N^+}，有\)&lt;/span> &lt;span class="math">\[|x_{n+p}-x_n|&amp;lt;\varepsilon\]&lt;/span> &lt;img src="../../images/柯西基本序列.png" alt="柯西基本序列" />
&lt;center>
柯西基本序列示意
&lt;/center>
&lt;/blockquote>
&lt;blockquote>
&lt;p>柯西收敛准则：&lt;span class="math">\(\{a_n\}\)&lt;/span>是基本列&lt;span class="math">\(\Leftrightarrow\)&lt;/span>数列&lt;span class="math">\(\{a_n\}\)&lt;/span>收敛 。柯西收敛准则还体现了实数的完备性。&lt;/p>
&lt;/blockquote>
&lt;p>证明：&lt;/p>
&lt;p>&lt;strong>柯西基本列&lt;span class="math">\(\Rightarrow\)&lt;/span>收敛&lt;/strong>。设&lt;span class="math">\(\{a_n\}\)&lt;/span>为基本列.&lt;/p>
&lt;p>(1)先证明&lt;span class="math">\(\{a_n\}\)&lt;/span>有界，取&lt;span class="math">\(\varepsilon_0=1\)&lt;/span>，根据基本列定义，&lt;span class="math">\(\exists N ∈ \mathbb{N}^+，n&amp;gt;N\)&lt;/span>时： &lt;span class="math">\[|a_n-a_{N+1}|&amp;lt;\varepsilon_0=1\\
|a_n|=|a_n-a_{N+1}+a_{N+1}|≤|a_n-a_{N+1}|+|a_{N+1}|\\
≤1+|a_{N+1}|\]&lt;/span> 取&lt;span class="math">\(M=\max\{|a_1|,|a_2|,\dots,|a_N|,1+|a_{N+1}|\},\)&lt;/span>则对&lt;span class="math">\(\forall n\)&lt;/span>，有&lt;span class="math">\(|a_n|≤M\)&lt;/span>，即数列&lt;span class="math">\(\{a_n\}\)&lt;/span>有界。&lt;/p>
&lt;p>(2)由列紧性定理可知，数列&lt;span class="math">\(\{a_n\}\)&lt;/span>有界则存在收敛子序列&lt;span class="math">\(\{a_{i_n}\}\)&lt;/span>。设&lt;span class="math">\(\lim_{n→∞}a_{i_n}=a\)&lt;/span>，则&lt;span class="math">\(\forall \varepsilon&amp;gt;0，\exists N_1 ∈ \mathbb{N^+}\)&lt;/span>，当&lt;span class="math">\(i_n&amp;gt;N_1\)&lt;/span>时: &lt;span class="math">\[|a_{i_n}-a|&amp;lt;\frac{\varepsilon}{2}\]&lt;/span> 由&lt;span class="math">\(\{a_n\}\)&lt;/span>是基本列可知，&lt;span class="math">\(\exists N_2 ∈ \mathbb{N}^+\)&lt;/span>，&lt;span class="math">\(m，n&amp;gt;N_2\)&lt;/span>时： &lt;span class="math">\[|a_m-a_n|&amp;lt;\frac{\varepsilon}{2}\]&lt;/span> 我们取&lt;span class="math">\(i_k&amp;gt;max(N_1,N_2)\)&lt;/span>则 &lt;span class="math">\[|a_n-a|=|a_n-a_{i_k}+a_{i_k}-a|≤|a_n-a_{i_k}|+|a_{i_k}-a|&amp;lt;\varepsilon\]&lt;/span> 所以&lt;span class="math">\(\lim_{n→∞}a_n=a\)&lt;/span>，得证。&lt;/p>
&lt;p>&lt;strong>收敛&lt;span class="math">\(\Rightarrow\)&lt;/span>柯西基本列&lt;/strong>。设&lt;span class="math">\(\{a_n\}\)&lt;/span>收敛于&lt;span class="math">\(a\)&lt;/span>，则&lt;span class="math">\(\forall\varepsilon&amp;gt;0，\exists N ∈ \mathbb{N^+}，n&amp;gt;N\)&lt;/span>，有&lt;span class="math">\(|a_n-a|&amp;lt;\varepsilon/2\)&lt;/span>。当&lt;span class="math">\(m,n&amp;gt;N\)&lt;/span>时 &lt;span class="math">\[|a_m-a_n|=|a_m-a+a-a_n|≤|a_m-a|+|a_n-a|&amp;lt;\varepsilon/2+\varepsilon/2=\varepsilon\]&lt;/span> 所以&lt;span class="math">\(\{a_n\}\)&lt;/span>是柯西基本列。&lt;/p>
&lt;p>&lt;strong>更重要的是其他6个定理可由柯西收敛准则直接推出&lt;/strong>。&lt;/p>
&lt;h2 id="有限覆盖定理紧性">有限覆盖定理（紧性）&lt;/h2>
&lt;blockquote>
&lt;p>覆盖定义：设&lt;span class="math">\(Ф\)&lt;/span>是拓扑空间&lt;span class="math">\(X\)&lt;/span>的&lt;strong>子集族&lt;/strong>，称&lt;span class="math">\(Ф\)&lt;/span>是&lt;span class="math">\(X\)&lt;/span>的一个覆盖，如果对任意&lt;span class="math">\(x∈X，x\)&lt;/span>至少包含在&lt;span class="math">\(Ф\)&lt;/span>的一个成员之中。&lt;/p>
&lt;blockquote>
&lt;p>等价定义：给定集合&lt;span class="math">\(X\)&lt;/span>若有一族开区间&lt;span class="math">\(\{I_\lambda,\lambda ∈ \Lambda\}\)&lt;/span>，使&lt;span class="math">\(A\subset\bigcup\limits_{\lambda ∈ \Lambda}I_\lambda\)&lt;/span>，则称开区间族&lt;span class="math">\(\{I_\lambda\}\)&lt;/span>是&lt;span class="math">\(X\)&lt;/span>的一个开覆盖。&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;hr />
&lt;blockquote>
&lt;p>有限覆盖定理（海涅-博雷尔定理）不同表述：&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>若开区间所成的区间集&lt;span class="math">\(\{I_\lambda\}\)&lt;/span>覆盖闭区间&lt;span class="math">\([a,b]\)&lt;/span>，则可以从&lt;span class="math">\(\{I_\lambda\}\)&lt;/span>中选出&lt;strong>有限个&lt;/strong>区间覆盖&lt;span class="math">\([a,b]\)&lt;/span>。区间集必须为开区间集，否则集合不能成立。&lt;/li>
&lt;li>R中的有界闭集是紧的。&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>证明：&lt;strong>反证法&lt;/strong>。&lt;/p>
&lt;p>设&lt;span class="math">\([a,b]\)&lt;/span>不能被&lt;span class="math">\(\{I_\lambda\}\)&lt;/span>中的有限个开区间覆盖。将&lt;span class="math">\([a,b]\)&lt;/span>二等分，必至少有一个区间&lt;span class="math">\([a_1,b_1]\)&lt;/span>不能被有限覆盖。&lt;/p>
&lt;p>&lt;span class="math">\([a_1,b_1]\)&lt;/span>二等分，必至少有一个闭区间&lt;span class="math">\([a_2,b_2]\)&lt;/span>不能被有限覆盖。如此继续操作得到比区间套&lt;span class="math">\(\{ [a_n,b_n]\}\)&lt;/span>，且其中每一个闭区间都不能被&lt;strong>有限的覆盖&lt;/strong>。&lt;/p>
&lt;p>由&lt;strong>闭区间套定理&lt;/strong>可知，&lt;span class="math">\(\exists \eta ∈ \bigcap\limits_{n=1}^∞[a_n,b_n]\)&lt;/span>，且&lt;span class="math">\(\lim_{n→∞}a_n=\lim_{n→∞}b_n=\eta\)&lt;/span>.&lt;/p>
&lt;p>因为&lt;span class="math">\(\eta ∈ [a,b]\)&lt;/span>，所以根据覆盖定义在&lt;span class="math">\(\{I_\lambda\}\)&lt;/span>中至少有一个开区间&lt;span class="math">\((\alpha,\beta)\)&lt;/span>覆盖了&lt;span class="math">\(\eta\)&lt;/span>。由数列极限定义给出，对于&lt;span class="math">\(\forall \eta-\alpha&amp;gt;0，\exists N ∈ \mathbb N^+\)&lt;/span>，当&lt;span class="math">\(n&amp;gt;N\)&lt;/span>，&lt;span class="math">\(|a_n-\eta|&amp;lt;\eta-\alpha\)&lt;/span>；同理有&lt;span class="math">\(|b_n-\eta|&amp;lt;\beta-\eta\)&lt;/span>，所以： &lt;span class="math">\[|a_n-\eta|&amp;lt;\eta-\alpha\Rightarrow \eta-a_n&amp;lt;\eta-\alpha\Rightarrow a_n&amp;gt;\alpha\\
|b_n-\eta|&amp;lt;\beta-\eta\Rightarrow b_n-\eta&amp;lt;\beta-\eta\Rightarrow b_n&amp;lt;\beta\]&lt;/span> 即&lt;span class="math">\([a_n,b_n]\subset(\alpha,\beta)\)&lt;/span>可以被一个开区间覆盖。与上文说的每一个&lt;span class="math">\([a_n,b_n]\)&lt;/span>都不能被有限的覆盖矛盾。&lt;/p>
&lt;p>所以反命题不成立，原命题得证。&lt;/p>
&lt;p>我觉得联系聚点的概念更容易理解有限覆盖定理。&lt;/p>
&lt;h2 id="聚点定理">聚点定理&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>邻域&lt;/strong>：设&lt;span class="math">\(\delta&amp;gt;0\)&lt;/span>，开区间&lt;span class="math">\((a-\delta,a+\delta)\)&lt;/span>称为&lt;span class="math">\(a\)&lt;/span>的&lt;span class="math">\(\delta\)&lt;/span>邻域，记作&lt;span class="math">\(U(a,\delta)\)&lt;/span>,&lt;span class="math">\(\delta\)&lt;/span>称作该邻域的半径。 &lt;strong>去心邻域&lt;/strong>：设&lt;span class="math">\(\delta&amp;gt;0\)&lt;/span>，&lt;span class="math">\(U(a,\delta)-{a}\)&lt;/span>称为&lt;span class="math">\(a\)&lt;/span>的去心&lt;span class="math">\(\delta\)&lt;/span>邻域，记作&lt;span class="math">\(U^\circ(a,\delta)\)&lt;/span> &lt;strong>聚点&lt;/strong>：设X是数集，实数&lt;span class="math">\(a\)&lt;/span>满足，&lt;span class="math">\(\forall \delta&amp;gt;0\)&lt;/span>，满足&lt;span class="math">\(U^\circ(a,\delta)\cap X \neq \emptyset\)&lt;/span>，则称&lt;span class="math">\(a\)&lt;/span>为&lt;span class="math">\(X\)&lt;/span>的聚点。&lt;/p>
&lt;blockquote>
&lt;p>等价描述为：如果点&lt;span class="math">\(a\)&lt;/span>的任何邻域 &lt;span class="math">\[U^\circ(a,\delta)=\{x|0&amp;lt;|x-a|&amp;lt;\delta\}\]&lt;/span> 都含有X中无穷多个点，则称&lt;span class="math">\(a\)&lt;/span>为&lt;span class="math">\(X\)&lt;/span>的聚点。&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;p>借助这些概念我们有如下定理：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>聚点定理&lt;/strong>：任何有界无穷点集至少有一个聚点。&lt;/p>
&lt;/blockquote>
&lt;p>证明：反证法（利用有限覆盖定理）。设有界无限点集&lt;span class="math">\(S\)&lt;/span>无聚点，则由&lt;span class="math">\(S\)&lt;/span>有界可知：&lt;/p>
&lt;p>存在实数&lt;span class="math">\(a，b\)&lt;/span>使得&lt;span class="math">\(S \subset [a,b]\)&lt;/span>。因为&lt;span class="math">\(S\)&lt;/span>无聚点，所以&lt;span class="math">\([a,b]\)&lt;/span>中的点都不是&lt;span class="math">\(S\)&lt;/span>的聚点。&lt;span class="math">\(\forall x ∈ [a,b], \exists \delta_x\)&lt;/span>，使得&lt;span class="math">\(U^\circ(x,\delta_x)\)&lt;/span>仅含有&lt;strong>有限&lt;/strong>个&lt;span class="math">\(S\)&lt;/span>中的点。&lt;/p>
&lt;p>记&lt;span class="math">\(F=\{U^\circ(x,\delta_x)|x ∈ [a,b]\}\)&lt;/span>，则&lt;span class="math">\(F\)&lt;/span>为&lt;span class="math">\(S\)&lt;/span>的一开覆盖。由&lt;strong>有限覆盖定理&lt;/strong>可知，存在&lt;span class="math">\(S\)&lt;/span>的有限个数的子覆盖。而每个开区间邻域内只有有限个点，有限个覆盖&lt;span class="math">\(\times\)&lt;/span>有限个点&amp;lt;&lt;span class="math">\(∞\)&lt;/span>，不可能得到无穷点集，矛盾。所以反命题不成立。得证。&lt;/p>
&lt;p>此外，我们再来写一个证明来完整闭环。聚点定理&lt;span class="math">\(\Rightarrow\)&lt;/span>致密性定理。&lt;/p>
&lt;p>设数列&lt;span class="math">\(\{a_n\}\)&lt;/span>有界，显然可以看做一无穷点集，根据聚点定理，至少存在一个聚点&lt;span class="math">\(\xi\)&lt;/span>。依次从&lt;span class="math">\(\xi\)&lt;/span>的&lt;span class="math">\(1/i\)&lt;/span>邻域中取一项，记作&lt;span class="math">\(x_i\)&lt;/span>，根据聚点定义，可以无限取下去构成子列&lt;span class="math">\(\{x_n\}\)&lt;/span>，且有&lt;span class="math">\(|x_n-\xi|&amp;lt;1/n\)&lt;/span>，易证&lt;span class="math">\(\lim\limits_{n→ ∞}x_n=\xi\)&lt;/span>。得证。&lt;/p>
&lt;h3 id="导集内核闭包">导集内核闭包&lt;/h3>
&lt;blockquote>
&lt;p>内核：设&lt;span class="math">\(E\)&lt;/span>是&lt;span class="math">\(R^n\)&lt;/span>中的点集，由&lt;span class="math">\(E\)&lt;/span>的所有内点组成的集合称为&lt;span class="math">\(E\)&lt;/span>的内核，记为&lt;span class="math">\(E^\circ\)&lt;/span>。&lt;/p>
&lt;p>导集：设&lt;span class="math">\(E\)&lt;/span>是&lt;span class="math">\(R^n\)&lt;/span>中的点集，由&lt;span class="math">\(E\)&lt;/span>的所有聚点组成的集合称为&lt;span class="math">\(E\)&lt;/span>的导集，记为&lt;span class="math">\(E&amp;#39;\)&lt;/span>。&lt;/p>
&lt;p>闭包：设&lt;span class="math">\(E\)&lt;/span>是&lt;span class="math">\(R^n\)&lt;/span>中的点集，称&lt;span class="math">\(E^\circ\cup E&amp;#39;\)&lt;/span>为&lt;span class="math">\(E\)&lt;/span>的闭包，记为&lt;span class="math">\(\overline{E}\)&lt;/span>。&lt;/p>
&lt;/blockquote>
&lt;p>关于导集、内核、闭包有以下定理： &amp;gt;如果&lt;span class="math">\(A \subset B\)&lt;/span>，则&lt;span class="math">\(A^\circ \subset B^\circ，A&amp;#39;\subset B&amp;#39;，\overline{A}\subset\overline{B}\)&lt;/span>。即导集、内核、闭包的运算具有单调性。&lt;/p>
&lt;h2 id="从完备性列紧紧看定理体系">从完备性，列紧，紧看定理体系&lt;/h2>
&lt;div class="figure">
&lt;img src="../../images/实数完备列紧与紧.jpg" alt="实数完备列紧与紧" />&lt;p class="caption">实数完备列紧与紧&lt;/p>
&lt;/div></description></item><item><title>数学分析之拉格朗日余项与误差</title><link>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%BD%99%E9%A1%B9%E4%B8%8E%E8%AF%AF%E5%B7%AE/</link><pubDate>Thu, 05 Sep 2019 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%BD%99%E9%A1%B9%E4%B8%8E%E8%AF%AF%E5%B7%AE/</guid><description>
&lt;h2 id="拉格朗日余项与误差">拉格朗日余项与误差&lt;!-- omit in toc -->&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="#拉格朗日余项">拉格朗日余项&lt;/a>&lt;/li>
&lt;li>&lt;a href="#拉格朗日误差界">拉格朗日误差界&lt;/a>&lt;/li>
&lt;li>&lt;a href="#例题">例题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#交错级数">交错级数&lt;/a>&lt;/li>
&lt;li>&lt;a href="#拉格朗日插值余项">拉格朗日插值余项&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="拉格朗日余项">拉格朗日余项&lt;/h2>
&lt;p>拉格朗日余项和泰勒公式密不可分。泰勒级数的全形如下： &lt;span class="math">\[
\begin{aligned}
f(x)&amp;amp;=f(a)+f&amp;#39;(a)(x-a)+\frac{f&amp;#39;&amp;#39;(a)}{2!}(x-a)^2+\dotsb+\frac{f^{(n)}(a)}{n!}(x-a)^n+\dotsb \\
&amp;amp;=\sum^{\infty}_{n=0}\frac{f^{(n)}(a)}{n!}(x-a)^n
\end{aligned}\]&lt;/span> 其中，前n项可以称为函数在点&lt;span class="math">\(x=a\)&lt;/span>处的&lt;span class="math">\(n\)&lt;/span>阶泰勒展开式。&lt;strong>所谓的阶，是指&lt;span class="math">\(x\)&lt;/span>的幂次；&lt;span class="math">\(n\)&lt;/span>阶就是&lt;span class="math">\(x\)&lt;/span>的最高次幂为&lt;span class="math">\(n\)&lt;/span>，而不是展开到第&lt;span class="math">\(n\)&lt;/span>项。&lt;/strong>&lt;/p>
&lt;p>但是，泰勒展开能够无限地逼近原函数，是以n趋向于无穷为前提条件的。如果我们只是将函数展开到n阶，则后面的部分（我们称为&lt;strong>余项&lt;/strong>, remainder）就被省略了，这必然会产生误差。记余项的表达式为&lt;span class="math">\(R_n(x)\)&lt;/span>，用它表示n项之后的余项（&lt;strong>注意下标是 n 而不是 n+1&lt;/strong>），我们可以将泰勒展开写成如下形式: &lt;span class="math">\[
f(x)=f(a)+f&amp;#39;(a)(x-a)+\frac{f&amp;#39;&amp;#39;(a)}{2!}(x-a)^2+\dotsb+\frac{f^{(n)}(a)}{n!}(x-a)^n+R_n(x)
\]&lt;/span> 或者说 &lt;span class="math">\[f(x)=P_n(x)+R_n(x)\]&lt;/span> 这式子的意思是原函数可以分解为两个部分，一部分是 n 阶泰勒展开，另一部分就是拉格朗日余项。那么，做一个移项，就可以有：&lt;span class="math">\(R_n(x)=f(x)-P_n(x)\)&lt;/span>。&lt;/p>
&lt;p>这就是说，用n阶幂级数来逼近原函数，其误差就是这一余项。而拉格朗日余项就是表达这些被省略部分的一个公式，我们可以用它来估计误差。为此，我们先写出函数的第 n+1 阶展开式： &lt;span class="math">\[\frac{f^{(n+1)}(a)}{(n+1)!}(x-a)^{n+1}\]&lt;/span> 而&lt;strong>拉格朗日余项&lt;/strong>（在具体题目中，我们也称为&lt;strong>拉格朗日误差界&lt;/strong> Lagrange Error Bound） 在形式上就类似于函数的第 n+1 阶，其表达式如下： &lt;span class="math">\[R_n(x)=\frac{f^{(n+1)}(c)}{(n+1)!}(x-a)^{n+1},c在x与a之间。\]&lt;/span> 需要注意的是，c只是在x与a之间，可能是&lt;span class="math">\(x\le c\le a\)&lt;/span>，也可能是&lt;span class="math">\(a\le c\le x\)&lt;/span>。同时，拉格朗日余项定理像微分中值定理（Mean Value Theorem）、介值定理（Intermediate Value Theorem）一样，都是存在性定理，即只能告知值的存在（我们知道有这样一个值），但不能告知其具体位置（但不知道它到底是多少）。如果我们使用麦克劳林式（Maclaurin Series，即&lt;span class="math">\(a = 0\)&lt;/span>时的特殊形式），就可以将拉格朗日余项变成较简单的形式: &lt;span class="math">\[R_n(x)=\frac{f^{(n+1)}(c)}{(n+1)!}x^{n+1},c在x与0之间。\]&lt;/span>&lt;/p>
&lt;h2 id="拉格朗日误差界">拉格朗日误差界&lt;/h2>
&lt;p>观察拉格朗日余项定理的形式，对于给定&lt;span class="math">\(a、n和x\)&lt;/span>的情况下，如果要确定这个余项的界限，唯一要确定的就是前面的这个第 n+1 阶导数的取值范围。若令有&lt;strong>正数&lt;/strong>&lt;span class="math">\(M=|f^{(n+1)}(c)|\)&lt;/span>，则只需要确定M的范围，那么，整个余项的范围也就唯一给定了。由于误差值可能为正，也可能为负，为便利讨论，我们一般都取其绝对值进行考查，即 &lt;span class="math">\[\begin{aligned}
|R_n(x)|&amp;amp;=|\frac{f^{(n+1)}(c)}{(n+1)!}(x-a)^{n+1}| \\
&amp;amp;=\frac{M}{(n+1)!}|(x-a)^{n+1}|
\end{aligned}\]&lt;/span> 而对于麦克劳林式，我们就变成考查： &lt;span class="math">\[\begin{aligned}
|R_n(x)|&amp;amp;=|\frac{f^{(n+1)}(c)}{(n+1)!}x^{n+1}| \\
&amp;amp;=\frac{M}{(n+1)!}|x^{n+1}|
\end{aligned}\]&lt;/span> 这时我们就要介绍一个基本定理，即拉格朗日余项定理：&lt;/p>
&lt;blockquote>
&lt;p>若存在正数Max，使得对任意&lt;span class="math">\(\xi\)&lt;/span>，如果&lt;span class="math">\(a \le \xi \le x\)&lt;/span>或&lt;span class="math">\(x \le \xi \le a\)&lt;/span>，均有&lt;span class="math">\(|f^{(n+1)}(\xi)|\le M\)&lt;/span>，则: &lt;span class="math">\[|R_n(x)|=|\frac{f^{(n+1)}(c)}{(n+1)!}(x-a)^{n+1}| \le \frac{M}{(n+1)!}|(x-a)^{n+1}|\]&lt;/span> 也就是说&lt;span class="math">\(M\)&lt;/span>的取值范围其实就由&lt;span class="math">\(|f^{(n+1)}(\xi)|,(a \le \xi \le x\)&lt;/span>或&lt;span class="math">\(x \le \xi \le a)\)&lt;/span>唯一给定。这一不等式也叫&lt;strong>泰勒不等式&lt;/strong>。这是我们进行余项范围估计的主要理论基础。&lt;/p>
&lt;/blockquote>
&lt;h2 id="例题">例题&lt;/h2>
&lt;p>&lt;strong>例1&lt;/strong> 将&lt;span class="math">\(y=sin(x)\)&lt;/span>展开成麦克劳林式，并估计其误差：&lt;/p>
&lt;p>根据基本公式：&lt;span class="math">\(sin(x)=x-\frac{1}{3!}x^3+\frac{1}{5!}x^5-\frac{1}{7!}x^7+\dotsb+(-1)^n\frac{x^{2n+1}}{(2n+1)!}+\dotsb\)&lt;/span>，很容易得出5阶麦克劳林式：&lt;span class="math">\(sin(x)\approx x-\frac{1}{3!}x^3+\frac{1}{5!}x^5\)&lt;/span>&lt;/p>
&lt;p>其余项按照拉格朗日余项定理，可以写成（注意：&lt;strong>5阶的余项是6次方&lt;/strong>）： &lt;span class="math">\[R_5(x)=\frac{f^6(c)}{6!}x^6,c在0和x之间\]&lt;/span> 而&lt;span class="math">\(|f^6(x)|=|-sin(x)| \le 1\)&lt;/span>，所以&lt;span class="math">\(R_5(x) \le \frac{x^6}{6!}\)&lt;/span>。&lt;/p>
&lt;p>&lt;strong>例2&lt;/strong> 将&lt;span class="math">\(y=sin(x)\)&lt;/span>展开成麦克劳林式，据此估计sin 0.2的值，并计算其误差。&lt;/p>
&lt;p>使用例1结论：&lt;span class="math">\(sin(0.2)\approx 0.2-\frac{1}{3!}(0.2)^3+\frac{1}{5!}(0.2)^5 \approx 0.1986693333\)&lt;/span>&lt;/p>
&lt;p>同时，&lt;span class="math">\(R_5(0.2) \le \frac{0.2^6}{6!}=8.888889*10^{-8}\)&lt;/span>&lt;/p>
&lt;h2 id="交错级数">交错级数&lt;/h2>
&lt;p>在一些情况下，使用交错级数计算误差相对简单，其基本定理如下：&lt;/p>
&lt;blockquote>
&lt;p>若交错级数&lt;span class="math">\(\sum^{\infty}\limits_{n=0}u_n=\sum^{\infty}\limits_{n=0}(-1)^{n+1}(v_{n})\)&lt;/span>满足以下条件：&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>正项递减，即&lt;span class="math">\(0\le v_{n+1} \le v_n;\)&lt;/span>&lt;/li>
&lt;li>正项趋零，即&lt;span class="math">\(\lim\limits_{x \to +\infty}v_n=0\)&lt;/span>&lt;/li>
&lt;/ol>
&lt;p>则必有其余项的范围&lt;span class="math">\(|R_n(x)|=|S-S_n|&amp;lt;|u_{n+1}|=v_{n+1}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>其中，S表示全部和，&lt;span class="math">\(S_n\)&lt;/span>表示部分和，也就是我们高中数学里习惯说的前n项和。简单的讲，&lt;strong>交错级数前n项和的余项，不会超过接下来这一项的绝对值，这就是交错级数的余项公式。&lt;/strong>&lt;/p>
&lt;h2 id="拉格朗日插值余项">拉格朗日插值余项&lt;/h2>
&lt;p>在插值过程中，有一个拓展概念叫拉格朗日插值余项。取插值结点：&lt;span class="math">\(a≤x0&amp;lt;x1&amp;lt;······&amp;lt;xn≤b\)&lt;/span> 满足&lt;span class="math">\(L_n(x_k)=f(x_k)\)&lt;/span>的 n 次多项式插值余项： &lt;span class="math">\[R_n(x)=f(x)-L_n(x) \\
=\frac{f^{(n+1)}(\xi_n)}{(n+1)!}\omega_{n+1}(x)\]&lt;/span> 其中，&lt;span class="math">\(\omega_{n+1}(x)=(x-x_0)(x-x_1)\dotsb (x-x_n)\)&lt;/span>。选取：&lt;span class="math">\(x_0,x_1,\dotsb,x_n\)&lt;/span>，使&lt;span class="math">\(\underset{a\le x \le b}{max}|\omega_{n+1}(x)|=min\)&lt;/span>&lt;/p>
&lt;p>结论:选取切比雪夫多项式&lt;span class="math">\(T_{n+1}(x)\)&lt;/span>的全部零点。&lt;/p>
&lt;p>使用切比雪夫节点插值和等距插值对函数&lt;span class="math">\(f(x)=\frac{1}{1+x^2}\)&lt;/span>模拟：&lt;/p>
&lt;img src="../../images/chebyshev_point.bmp" alt="切比雪夫结点插值" />
&lt;center>
插值函数L10(x)取切比雪夫结点插值
&lt;/center>
&lt;img src="../../images/equal_distance_point.png" alt="等距结点插值" />
&lt;center>
插值函数L10(x)取等距结点插值
&lt;/center></description></item><item><title>数学分析-四次阶乘</title><link>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90-%E5%9B%9B%E6%AC%A1%E9%98%B6%E4%B9%98/</link><pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90-%E5%9B%9B%E6%AC%A1%E9%98%B6%E4%B9%98/</guid><description>
&lt;h2 id="四次阶乘">四次阶乘&lt;!-- omit in toc -->&lt;/h2>
&lt;p>所谓的四次阶乘（又称四重阶乘） 不是&lt;span class="math">\(n!^{(4)}\)&lt;/span>，而是&lt;span class="math">\((2n)!/n!\)&lt;/span>,前几个四次阶乘为 &lt;span class="math">\[1, 2, 12, 120, 1680, 30240, 665280, ....\]&lt;/span> 它也等于 &lt;span class="math">\[{\begin{aligned}
2^{n}{\frac {(2n)!}{n!2^{n}}}&amp;amp;=2^{n}{\frac {[2\cdot 4\cdots 2n](1\cdot 3\cdots (2n-1))}{2\cdot 4\cdots 2n}}\\
&amp;amp;=(1\cdot 2)\cdot (3\cdot 2)\cdots [(2n-1)\cdot 2]=(4n-2)!^{{(4)}}.\end{aligned}}\]&lt;/span>&lt;/p></description></item><item><title>数学分析-数学中几个点（驻点，极值点，鞍点，拐点）</title><link>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90-%E6%95%B0%E5%AD%A6%E4%B8%AD%E5%87%A0%E4%B8%AA%E7%82%B9%E9%A9%BB%E7%82%B9%E6%9E%81%E5%80%BC%E7%82%B9%E9%9E%8D%E7%82%B9%E6%8B%90%E7%82%B9/</link><pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate><guid>https://surprisedcat.github.io/studynotes/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90-%E6%95%B0%E5%AD%A6%E4%B8%AD%E5%87%A0%E4%B8%AA%E7%82%B9%E9%A9%BB%E7%82%B9%E6%9E%81%E5%80%BC%E7%82%B9%E9%9E%8D%E7%82%B9%E6%8B%90%E7%82%B9/</guid><description>
&lt;h2 id="数学中几个点驻点极值点鞍点拐点">数学中几个点（驻点，极值点，鞍点，拐点）&lt;!-- omit in toc -->&lt;/h2>
&lt;p>函数的导数导致了图像中出现了几种点，现在详细理一下。&lt;/p>
&lt;h2 id="驻点">驻点&lt;/h2>
&lt;p>在数学，特别在微积分，函数在一点处的&lt;strong>一阶导数为零&lt;/strong>，该点即函数的&lt;strong>驻点&lt;/strong>（Stationary Point）或&lt;strong>稳定点&lt;/strong>，也就是说若p为驻点则 &lt;span class="math">\[\frac{dy}{dx}\biggm\vert_p=0\]&lt;/span>&lt;/p>
&lt;p>在这一点，函数的输出值停止增加或减少。驻点有一个&lt;strong>先决条件&lt;/strong>，就是函数在这个点可微（可导）。在此之上，只有一个条件，即一阶导数为零。&lt;/p>
&lt;h2 id="极值点">极值点&lt;/h2>
&lt;p>在数学中，极大值与极小值（又被称为极值）是指在一个域（邻域或定义域）上函数取得最大值（或最小值）的点的函数值。而使函数取得极值的点（的横坐标）被称作极值点。&lt;/p>
&lt;p>值得注意的是，一个函数的&lt;strong>驻点不一定是这个函数的极值点&lt;/strong>（考虑到这一点左右一阶导数符号不改变的情况）；反过来，在某设定区域内，一个函数的&lt;strong>极值点也不一定是这个函数的驻点&lt;/strong>（考虑到边界条件）或者不可微点。对于可微函数，&lt;strong>极值点一定是驻点。&lt;/strong>&lt;/p>
&lt;h2 id="鞍点">鞍点&lt;/h2>
&lt;p>一个&lt;strong>不是局部极值点的驻点&lt;/strong>称为鞍点。驻点--》鞍点 思考一个只有一个变数的函数。这函数在鞍点的一次导数等于零，二次导数换正负符号·例如，函数 &lt;span class="math">\[y=x^3\]&lt;/span> 就有一个鞍点在原点。&lt;/p>
&lt;p>思考一个拥有两个以上变数的函数。它的曲面在鞍点好像一个马鞍，在某些方向往上曲，在其他方向往下曲。在一幅等高线图里，一般来说，当两个等高线圈圈相交叉的地点，就是鞍点。例如，两座山中间的山口就是一个鞍点&lt;/p>
&lt;h2 id="拐点">拐点&lt;/h2>
&lt;p>设&lt;span class="math">\(f(x)\)&lt;/span>在（a，b）内，二阶可导，在&lt;span class="math">\(x_0\)&lt;/span>处的二阶导数为零 &lt;span class="math">\[f&amp;#39;&amp;#39;(x_0)=0\]&lt;/span> 若在&lt;span class="math">\(x_0\)&lt;/span>两侧附近，&lt;span class="math">\(f&amp;#39;&amp;#39;(x)\)&lt;/span>异号，则点&lt;span class="math">\((x_0，f(x_0))\)&lt;/span>为曲线的拐点。否则（保持同号），不是拐点。&lt;/p>
&lt;img src="../../images/points_in_math.png" alt="数学中的各种点" />
&lt;center>
图1 数学中的各种点
&lt;/center></description></item></channel></rss>